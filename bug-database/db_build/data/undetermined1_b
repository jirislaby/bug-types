Error: ATOMICITY:
mm/swap.c:359: lock: Locking "zone->lru_lock".
mm/swap.c:337: def: Assigning: "page" = data that might be protected by the lock.
mm/swap.c:356: unlock: Unlocking "zone->lru_lock". "page" might now be unreliable because other threads can now change the data that it depends on.
mm/swap.c:359: lockagain: Locking "zone->lru_lock" again.
mm/swap.c:362: use: Using an unreliable value of "page" inside the second locked section.  If the data that "page" depends on was changed by another thread, this use might be incorrect.

Error: ATOMICITY:
mm/swap.c:441: lock: Locking "zone->lru_lock".
mm/swap.c:433: def: Assigning: "page" = data that might be protected by the lock.
mm/swap.c:439: unlock: Unlocking "zone->lru_lock". "page" might now be unreliable because other threads can now change the data that it depends on.
mm/swap.c:441: lockagain: Locking "zone->lru_lock" again.
mm/swap.c:446: use: Using an unreliable value of "page" inside the second locked section.  If the data that "page" depends on was changed by another thread, this use might be incorrect.

Error: ATOMICITY:
mm/swap.c:118: lock: Locking "zone->lru_lock".
mm/swap.c:111: def: Assigning: "page" = data that might be protected by the lock.
mm/swap.c:116: unlock: Unlocking "zone->lru_lock". "page" might now be unreliable because other threads can now change the data that it depends on.
mm/swap.c:118: lockagain: Locking "zone->lru_lock" again.
mm/swap.c:120: use: Using an unreliable value of "page" inside the second locked section.  If the data that "page" depends on was changed by another thread, this use might be incorrect.

Error: ATOMICITY:
mm/vmscan.c:1251: lock: Locking "zone->lru_lock".
mm/vmscan.c:1266: def: Assigning: "lru" = data that might be protected by the lock.
mm/vmscan.c:1280: unlock: Unlocking "zone->lru_lock". "lru" might now be unreliable because other threads can now change the data that it depends on.
mm/vmscan.c:1286: lockagain: Locking "zone->lru_lock" again.
mm/vmscan.c:1276: use: Using an unreliable value of "lru" inside the second locked section.  If the data that "lru" depends on was changed by another thread, this use might be incorrect.

Error: ATOMICITY:
kernel/sched.c:4463: lock: Locking "rq->lock".
kernel/sched.c:4498: def: Assigning: "cpu" = data that might be protected by the lock.
kernel/sched.c:4501: unlock: Unlocking "rq->lock". "cpu" might now be unreliable because other threads can now change the data that it depends on.
kernel/sched.c:4463: lockagain: Locking "rq->lock" again.
kernel/sched.c:4481: use: Using an unreliable value of "cpu" inside the second locked section.  If the data that "cpu" depends on was changed by another thread, this use might be incorrect.

Error: ATOMICITY:
kernel/sched.c:4463: lock: Locking "rq->lock".
kernel/sched.c:4452: def: Assigning: "prev" = data that might be protected by the lock.
kernel/sched.c:4501: unlock: Unlocking "rq->lock". "prev" might now be unreliable because other threads can now change the data that it depends on.
kernel/sched.c:4463: lockagain: Locking "rq->lock" again.
kernel/sched.c:4465: use: Using an unreliable value of "prev" inside the second locked section.  If the data that "prev" depends on was changed by another thread, this use might be incorrect.

Error: ATOMICITY:
kernel/sched.c:4463: lock: Locking "rq->lock".
kernel/sched.c:4469: def: Assigning: "prev->state" = data that might be protected by the lock.
kernel/sched.c:4501: unlock: Unlocking "rq->lock". "prev->state" might now be unreliable because other threads can now change the data that it depends on.
kernel/sched.c:4463: lockagain: Locking "rq->lock" again.
kernel/sched.c:4468: use: Using an unreliable value of "prev->state" inside the second locked section.  If the data that "prev->state" depends on was changed by another thread, this use might be incorrect.

Error: ATOMICITY:
kernel/sched.c:4463: lock: Locking "rq->lock".
kernel/sched.c:4450: def: Assigning: "rq" = data that might be protected by the lock.
kernel/sched.c:4501: unlock: Unlocking "rq->lock". "rq" might now be unreliable because other threads can now change the data that it depends on.
kernel/sched.c:4463: lockagain: Locking "rq->lock" again.
kernel/sched.c:4464: use: Using an unreliable value of "rq" inside the second locked section.  If the data that "rq" depends on was changed by another thread, this use might be incorrect.

Error: ATOMICITY:
kernel/sched.c:4463: lock: Locking "rq->lock".
kernel/sched.c:4499: def: Assigning: "rq" = data that might be protected by the lock.
kernel/sched.c:4501: unlock: Unlocking "rq->lock". "rq" might now be unreliable because other threads can now change the data that it depends on.
kernel/sched.c:4463: lockagain: Locking "rq->lock" again.
kernel/sched.c:4464: use: Using an unreliable value of "rq" inside the second locked section.  If the data that "rq" depends on was changed by another thread, this use might be incorrect.

Error: ATOMICITY:
kernel/printk.c:994: lock: Locking "logbuf_lock".
kernel/printk.c:1000: def: Assigning: "con_start" = data that might be protected by the lock.
kernel/printk.c:1001: unlock: Unlocking "logbuf_lock". "con_start" might now be unreliable because other threads can now change the data that it depends on.
kernel/printk.c:994: lockagain: Locking "logbuf_lock" again.
kernel/printk.c:998: use: Using an unreliable value of "con_start" inside the second locked section.  If the data that "con_start" depends on was changed by another thread, this use might be incorrect.

Error: ATOMICITY:
lib/idr.c:753: lock: Locking "ida->idr.lock".
lib/idr.c:755: def: Assigning: "ida->free_bitmap" = data that might be protected by the lock.
lib/idr.c:756: unlock: Unlocking "ida->idr.lock". "ida->free_bitmap" might now be unreliable because other threads can now change the data that it depends on.
lib/idr.c:753: lockagain: Locking "ida->idr.lock" again.
lib/idr.c:754: use: Using an unreliable value of "ida->free_bitmap" inside the second locked section.  If the data that "ida->free_bitmap" depends on was changed by another thread, this use might be incorrect.

Error: ATOMICITY:
fs/xfs/xfs_log.c:843: lock: Locking "log->l_icloglock".
fs/xfs/xfs_log.c:844: def: Assigning: "tail_lsn" = data that might be protected by the lock.
fs/xfs/xfs_log.c:845: unlock: Unlocking "log->l_icloglock". "tail_lsn" might now be unreliable because other threads can now change the data that it depends on.
fs/xfs/xfs_log.c:848: lockagain: Locking "log->l_grant_lock" again.
fs/xfs/xfs_log.c:854: use: Using an unreliable value of "tail_lsn" inside the second locked section.  If the data that "tail_lsn" depends on was changed by another thread, this use might be incorrect.

Error: ATOMICITY:
fs/xfs/xfs_log.c:2262: lock: Locking "iclog->hic_fields.ic_callback_lock".
fs/xfs/xfs_log.c:2266: def: Assigning: "iclog->hic_fields.ic_callback" = data that might be protected by the lock.
fs/xfs/xfs_log.c:2267: unlock: Unlocking "iclog->hic_fields.ic_callback_lock". "iclog->hic_fields.ic_callback" might now be unreliable because other threads can now change the data that it depends on.
fs/xfs/xfs_log.c:2274: lockagain: Locking "iclog->hic_fields.ic_callback_lock" again.
fs/xfs/xfs_log.c:2275: use: Using an unreliable value of "iclog->hic_fields.ic_callback" inside the second locked section.  If the data that "iclog->hic_fields.ic_callback" depends on was changed by another thread, this use might be incorrect.

Error: ATOMICITY:
fs/xfs/xfs_log.c:2243: lock: Locking "log->l_grant_lock".
fs/xfs/xfs_log.c:2246: def: Assigning: "log->l_last_sync_lsn" = data that might be protected by the lock.
fs/xfs/xfs_log.c:2248: unlock: Unlocking "log->l_grant_lock". "log->l_last_sync_lsn" might now be unreliable because other threads can now change the data that it depends on.
fs/xfs/xfs_log.c:2267: unlock: Unlocking "iclog->hic_fields.ic_callback_lock". "log->l_last_sync_lsn" might now be unreliable because other threads can now change the data that it depends on.
fs/xfs/xfs_log.c:2283: unlock: Unlocking "iclog->hic_fields.ic_callback_lock". "log->l_last_sync_lsn" might now be unreliable because other threads can now change the data that it depends on.
fs/xfs/xfs_log.c:2237: unlock: Unlocking "log->l_icloglock". "log->l_last_sync_lsn" might now be unreliable because other threads can now change the data that it depends on.
fs/xfs/xfs_log.c:2243: lockagain: Locking "log->l_grant_lock" again.
fs/xfs/xfs_log.c:2244: use: Using an unreliable value of "log->l_last_sync_lsn" inside the second locked section.  If the data that "log->l_last_sync_lsn" depends on was changed by another thread, this use might be incorrect.

Error: ATOMICITY:
fs/fs-writeback.c:562: lock: Locking "sb_lock".
fs/fs-writeback.c:564: def: Assigning: "sb" = data that might be protected by the lock.
fs/fs-writeback.c:568: unlock: Unlocking "sb_lock". "sb" might now be unreliable because other threads can now change the data that it depends on.
fs/fs-writeback.c:579: lockagain: Locking "sb_lock" again.
fs/fs-writeback.c:580: use: Using an unreliable value of "sb" inside the second locked section.  If the data that "sb" depends on was changed by another thread, this use might be incorrect.

Error: ATOMICITY:
fs/fs-writeback.c:579: lock: Locking "sb_lock".
fs/fs-writeback.c:564: def: Assigning: "sb" = data that might be protected by the lock.
fs/fs-writeback.c:568: unlock: Unlocking "sb_lock". "sb" might now be unreliable because other threads can now change the data that it depends on.
fs/fs-writeback.c:579: lockagain: Locking "sb_lock" again.
fs/fs-writeback.c:580: use: Using an unreliable value of "sb" inside the second locked section.  If the data that "sb" depends on was changed by another thread, this use might be incorrect.

Error: ATOMICITY:
fs/ext4/mballoc.c:3290: lock: Locking "pa->pa_lock".
fs/ext4/mballoc.c:3294: def: Assigning: "cpa" = data that might be protected by the lock.
fs/ext4/mballoc.c:3297: unlock: Unlocking "pa->pa_lock". "cpa" might now be unreliable because other threads can now change the data that it depends on.
fs/ext4/mballoc.c:3290: lockagain: Locking "pa->pa_lock" again.
fs/ext4/mballoc.c:3294: use: Using an unreliable value of "cpa" inside the second locked section.  If the data that "cpa" depends on was changed by another thread, this use might be incorrect.

Error: ATOMICITY:
net/sched/sch_generic.c:144: lock: Locking "txq->_xmit_lock".
net/sched/sch_generic.c:147: def: Assigning: "ret" = data that might be protected by the lock.
net/sched/sch_generic.c:148: unlock: Unlocking "txq->_xmit_lock". "ret" might now be unreliable because other threads can now change the data that it depends on.
net/sched/sch_generic.c:150: lockagain: Locking "*root_lock" again.
net/sched/sch_generic.c:166: use: Using an unreliable value of "ret" inside the second locked section.  If the data that "ret" depends on was changed by another thread, this use might be incorrect.

Error: ATOMICITY:
fs/ocfs2/dlmglue.c:1216: lock: Locking "lockres->l_lock".
fs/ocfs2/dlmglue.c:1256: def: Assigning: "lockres->l_action" = data that might be protected by the lock.
fs/ocfs2/dlmglue.c:1266: unlock: Unlocking "lockres->l_lock". "lockres->l_action" might now be unreliable because other threads can now change the data that it depends on.
fs/ocfs2/dlmglue.c:1216: lockagain: Locking "lockres->l_lock" again.
fs/ocfs2/dlmglue.c:1252: use: Using an unreliable value of "lockres->l_action" inside the second locked section.  If the data that "lockres->l_action" depends on was changed by another thread, this use might be incorrect.

Error: ATOMICITY:
fs/jbd/checkpoint.c:368: lock: Locking "journal->j_list_lock".
fs/jbd/checkpoint.c:371: def: Assigning: "transaction" = data that might be protected by the lock.
fs/jbd/checkpoint.c:392: unlock: Unlocking "journal->j_list_lock". "transaction" might now be unreliable because other threads can now change the data that it depends on.
fs/jbd/checkpoint.c:409: unlock: Unlocking "journal->j_list_lock". "transaction" might now be unreliable because other threads can now change the data that it depends on.
fs/jbd/checkpoint.c:416: lockagain: Locking "journal->j_list_lock" again.
fs/jbd/checkpoint.c:423: use: Using an unreliable value of "transaction" inside the second locked section.  If the data that "transaction" depends on was changed by another thread, this use might be incorrect.

Error: ATOMICITY:
drivers/usb/core/hcd.c:678: lock: Locking "hcd_root_hub_lock".
drivers/usb/core/hcd.c:678: def: Assigning: "flags" = data that might be protected by the lock.
drivers/usb/core/hcd.c:693: unlock: Unlocking "hcd_root_hub_lock". "flags" might now be unreliable because other threads can now change the data that it depends on.
drivers/usb/core/hcd.c:695: lockagain: Locking "hcd_root_hub_lock" again.
drivers/usb/core/hcd.c:699: use: Using an unreliable value of "flags" inside the second locked section.  If the data that "flags" depends on was changed by another thread, this use might be incorrect.

Error: ATOMICITY:
fs/mbcache.c:518: lock: Locking "mb_cache_spinlock".
fs/mbcache.c:520: def: Assigning: "ce" = data that might be protected by the lock.
fs/mbcache.c:531: unlock: Unlocking "mb_cache_spinlock". "ce" might now be unreliable because other threads can now change the data that it depends on.
fs/mbcache.c:533: lockagain: Locking "mb_cache_spinlock" again.
fs/mbcache.c:539: use: Using an unreliable value of "ce" inside the second locked section.  If the data that "ce" depends on was changed by another thread, this use might be incorrect.

Error: ATOMICITY:
fs/xfs/xfs_iget.c:97: lock: Locking "pag->pag_ici_lock".
fs/xfs/xfs_iget.c:98: def: Assigning: "ip" = data that might be protected by the lock.
fs/xfs/xfs_iget.c:197: unlock: Unlocking "pag->pag_ici_lock". "ip" might now be unreliable because other threads can now change the data that it depends on.
fs/xfs/xfs_iget.c:248: lockagain: Locking "pag->pag_ici_lock" again.
fs/xfs/xfs_iget.c:252: use: Using an unreliable value of "ip" inside the second locked section.  If the data that "ip" depends on was changed by another thread, this use might be incorrect.

Error: ATOMICITY:
fs/jbd/transaction.c:115: lock: Locking "journal->j_state_lock".
fs/jbd/transaction.c:138: def: Assigning: "new_transaction" = data that might be protected by the lock.
fs/jbd/transaction.c:152: unlock: Unlocking "journal->j_state_lock". "new_transaction" might now be unreliable because other threads can now change the data that it depends on.
fs/jbd/transaction.c:115: lockagain: Locking "journal->j_state_lock" again.
fs/jbd/transaction.c:137: use: Using an unreliable value of "new_transaction" inside the second locked section.  If the data that "new_transaction" depends on was changed by another thread, this use might be incorrect.

Error: ATOMICITY:
fs/jbd/transaction.c:115: lock: Locking "journal->j_state_lock".
fs/jbd/transaction.c:138: def: Assigning: "new_transaction" = data that might be protected by the lock.
fs/jbd/transaction.c:175: unlock: Unlocking "transaction->t_handle_lock". "new_transaction" might now be unreliable because other threads can now change the data that it depends on.
fs/jbd/transaction.c:179: unlock: Unlocking "journal->j_state_lock". "new_transaction" might now be unreliable because other threads can now change the data that it depends on.
fs/jbd/transaction.c:115: lockagain: Locking "journal->j_state_lock" again.
fs/jbd/transaction.c:137: use: Using an unreliable value of "new_transaction" inside the second locked section.  If the data that "new_transaction" depends on was changed by another thread, this use might be incorrect.

Error: ATOMICITY:
mm/mmap.c:581: lock: Locking "anon_vma->lock".
mm/mmap.c:550: def: Assigning: "mapping" = data that might be protected by the lock.
mm/mmap.c:635: unlock: Unlocking "anon_vma->lock". "mapping" might now be unreliable because other threads can now change the data that it depends on.
mm/mmap.c:637: unlock: Unlocking "mapping->i_mmap_lock". "mapping" might now be unreliable because other threads can now change the data that it depends on.
mm/mmap.c:581: lockagain: Locking "anon_vma->lock" again.
mm/mmap.c:622: use: Using an unreliable value of "mapping" inside the second locked section.  If the data that "mapping" depends on was changed by another thread, this use might be incorrect.

Error: ATOMICITY:
mm/mmap.c:581: lock: Locking "anon_vma->lock".
mm/mmap.c:552: def: Assigning: "root" = data that might be protected by the lock.
mm/mmap.c:635: unlock: Unlocking "anon_vma->lock". "root" might now be unreliable because other threads can now change the data that it depends on.
mm/mmap.c:637: unlock: Unlocking "mapping->i_mmap_lock". "root" might now be unreliable because other threads can now change the data that it depends on.
mm/mmap.c:581: lockagain: Locking "anon_vma->lock" again.
mm/mmap.c:595: use: Using an unreliable value of "root" inside the second locked section.  If the data that "root" depends on was changed by another thread, this use might be incorrect.

Error: ATOMICITY:
mm/mmap.c:581: lock: Locking "anon_vma->lock".
mm/mmap.c:552: def: Assigning: "root" = data that might be protected by the lock.
mm/mmap.c:635: unlock: Unlocking "anon_vma->lock". "root" might now be unreliable because other threads can now change the data that it depends on.
mm/mmap.c:637: unlock: Unlocking "mapping->i_mmap_lock". "root" might now be unreliable because other threads can now change the data that it depends on.
mm/mmap.c:581: lockagain: Locking "anon_vma->lock" again.
mm/mmap.c:610: use: Using an unreliable value of "root" inside the second locked section.  If the data that "root" depends on was changed by another thread, this use might be incorrect.

Error: ATOMICITY:
mm/mmap.c:581: lock: Locking "anon_vma->lock".
mm/mmap.c:552: def: Assigning: "root" = data that might be protected by the lock.
mm/mmap.c:635: unlock: Unlocking "anon_vma->lock". "root" might now be unreliable because other threads can now change the data that it depends on.
mm/mmap.c:637: unlock: Unlocking "mapping->i_mmap_lock". "root" might now be unreliable because other threads can now change the data that it depends on.
mm/mmap.c:581: lockagain: Locking "anon_vma->lock" again.
mm/mmap.c:611: use: Using an unreliable value of "root" inside the second locked section.  If the data that "root" depends on was changed by another thread, this use might be incorrect.

Error: ATOMICITY:
mm/mmap.c:581: lock: Locking "anon_vma->lock".
mm/mmap.c:552: def: Assigning: "root" = data that might be protected by the lock.
mm/mmap.c:635: unlock: Unlocking "anon_vma->lock". "root" might now be unreliable because other threads can now change the data that it depends on.
mm/mmap.c:637: unlock: Unlocking "mapping->i_mmap_lock". "root" might now be unreliable because other threads can now change the data that it depends on.
mm/mmap.c:553: lockagain: Locking "mapping->i_mmap_lock" again.
mm/mmap.c:595: use: Using an unreliable value of "root" inside the second locked section.  If the data that "root" depends on was changed by another thread, this use might be incorrect.

Error: ATOMICITY:
fs/jffs2/readinode.c:974: lock: Locking "c->erase_completion_lock".
fs/jffs2/readinode.c:986: def: Assigning: "valid_ref" = data that might be protected by the lock.
fs/jffs2/readinode.c:987: unlock: Unlocking "c->erase_completion_lock". "valid_ref" might now be unreliable because other threads can now change the data that it depends on.
fs/jffs2/readinode.c:1097: lockagain: Locking "c->erase_completion_lock" again.
fs/jffs2/readinode.c:985: use: Using an unreliable value of "valid_ref" inside the second locked section.  If the data that "valid_ref" depends on was changed by another thread, this use might be incorrect.

Error: ATOMICITY:
security/keys/key.c:71: lock: Locking "key_user_lock".
security/keys/key.c:75: def: Assigning: "parent" = data that might be protected by the lock.
security/keys/key.c:90: unlock: Unlocking "key_user_lock". "parent" might now be unreliable because other threads can now change the data that it depends on.
security/keys/key.c:71: lockagain: Locking "key_user_lock" again.
security/keys/key.c:114: use: Using an unreliable value of "parent" inside the second locked section.  If the data that "parent" depends on was changed by another thread, this use might be incorrect.

Error: ATOMICITY:
sound/core/seq/seq_memory.c:236: lock: Locking "pool->lock".
sound/core/seq/seq_memory.c:236: def: Assigning: "flags" = data that might be protected by the lock.
sound/core/seq/seq_memory.c:246: unlock: Unlocking "pool->lock". "flags" might now be unreliable because other threads can now change the data that it depends on.
sound/core/seq/seq_memory.c:248: lockagain: Locking "pool->lock" again.
sound/core/seq/seq_memory.c:278: use: Using an unreliable value of "flags" inside the second locked section.  If the data that "flags" depends on was changed by another thread, this use might be incorrect.

Error: ATOMICITY:
fs/gfs2/glock.c:311: lock: Locking "gl->gl_spin".
fs/gfs2/glock.c:302: def: Assigning: "gh" = data that might be protected by the lock.
fs/gfs2/glock.c:308: unlock: Unlocking "gl->gl_spin". "gh" might now be unreliable because other threads can now change the data that it depends on.
fs/gfs2/glock.c:311: lockagain: Locking "gl->gl_spin" again.
fs/gfs2/glock.c:315: use: Using an unreliable value of "gh" inside the second locked section.  If the data that "gh" depends on was changed by another thread, this use might be incorrect.

Error: ATOMICITY:
fs/gfs2/glock.c:311: lock: Locking "gl->gl_spin".
fs/gfs2/glock.c:302: def: Assigning: "gh" = data that might be protected by the lock.
fs/gfs2/glock.c:308: unlock: Unlocking "gl->gl_spin". "gh" might now be unreliable because other threads can now change the data that it depends on.
fs/gfs2/glock.c:311: lockagain: Locking "gl->gl_spin" again.
fs/gfs2/glock.c:319: use: Using an unreliable value of "gh" inside the second locked section.  If the data that "gh" depends on was changed by another thread, this use might be incorrect.

Error: ATOMICITY:
drivers/mtd/ubi/wl.c:1160: lock: Locking "ubi->wl_lock".
drivers/mtd/ubi/wl.c:1161: def: Assigning: "e" = data that might be protected by the lock.
drivers/mtd/ubi/wl.c:1207: unlock: Unlocking "ubi->wl_lock". "e" might now be unreliable because other threads can now change the data that it depends on.
drivers/mtd/ubi/wl.c:1211: lockagain: Locking "ubi->wl_lock" again.
drivers/mtd/ubi/wl.c:1212: use: Using an unreliable value of "e" inside the second locked section.  If the data that "e" depends on was changed by another thread, this use might be incorrect.

Error: ATOMICITY:
fs/quota.c:197: lock: Locking "sb_lock".
fs/quota.c:199: def: Assigning: "sb" = data that might be protected by the lock.
fs/quota.c:214: unlock: Unlocking "sb_lock". "sb" might now be unreliable because other threads can now change the data that it depends on.
fs/quota.c:219: lockagain: Locking "sb_lock" again.
fs/quota.c:220: use: Using an unreliable value of "sb" inside the second locked section.  If the data that "sb" depends on was changed by another thread, this use might be incorrect.

Error: ATOMICITY:
net/core/sock.c:1388: lock: Locking "sk->sk_lock.slock".
net/core/sock.c:1368: def: Assigning: "sk->sk_backlog.head" = data that might be protected by the lock.
net/core/sock.c:1369: unlock: Unlocking "sk->sk_lock.slock". "sk->sk_backlog.head" might now be unreliable because other threads can now change the data that it depends on.
net/core/sock.c:1388: lockagain: Locking "sk->sk_lock.slock" again.
net/core/sock.c:1389: use: Using an unreliable value of "sk->sk_backlog.head" inside the second locked section.  If the data that "sk->sk_backlog.head" depends on was changed by another thread, this use might be incorrect.

Error: ATOMICITY:
fs/inotify.c:442: lock: Locking "inode_lock".
fs/inotify.c:412: def: Assigning: "need_iput" = data that might be protected by the lock.
fs/inotify.c:421: unlock: Unlocking "inode_lock". "need_iput" might now be unreliable because other threads can now change the data that it depends on.
fs/inotify.c:442: lockagain: Locking "inode_lock" again.
fs/inotify.c:399: use: Using an unreliable value of "need_iput" inside the second locked section.  If the data that "need_iput" depends on was changed by another thread, this use might be incorrect.

Error: ATOMICITY:
fs/inotify.c:442: lock: Locking "inode_lock".
fs/inotify.c:377: def: Assigning: "next_i" = data that might be protected by the lock.
fs/inotify.c:421: unlock: Unlocking "inode_lock". "next_i" might now be unreliable because other threads can now change the data that it depends on.
fs/inotify.c:442: lockagain: Locking "inode_lock" again.
fs/inotify.c:377: use: Using an unreliable value of "next_i" inside the second locked section.  If the data that "next_i" depends on was changed by another thread, this use might be incorrect.

Error: ATOMICITY:
drivers/infiniband/hw/mthca/mthca_cmd.c:382: lock: Locking "dev->cmd.context_lock".
drivers/infiniband/hw/mthca/mthca_cmd.c:386: def: Assigning: "dev->cmd.free_head" = data that might be protected by the lock.
drivers/infiniband/hw/mthca/mthca_cmd.c:387: unlock: Unlocking "dev->cmd.context_lock". "dev->cmd.free_head" might now be unreliable because other threads can now change the data that it depends on.
drivers/infiniband/hw/mthca/mthca_cmd.c:416: lockagain: Locking "dev->cmd.context_lock" again.
drivers/infiniband/hw/mthca/mthca_cmd.c:417: use: Using an unreliable value of "dev->cmd.free_head" inside the second locked section.  If the data that "dev->cmd.free_head" depends on was changed by another thread, this use might be incorrect.

Error: ATOMICITY:
fs/jffs2/nodemgmt.c:339: lock: Locking "c->erase_completion_lock".
fs/jffs2/nodemgmt.c:340: def: Assigning: "jeb" = data that might be protected by the lock.
fs/jffs2/nodemgmt.c:344: unlock: Unlocking "c->erase_completion_lock". "jeb" might now be unreliable because other threads can now change the data that it depends on.
fs/jffs2/nodemgmt.c:353: lockagain: Locking "c->erase_completion_lock" again.
fs/jffs2/nodemgmt.c:356: use: Using an unreliable value of "jeb" inside the second locked section.  If the data that "jeb" depends on was changed by another thread, this use might be incorrect.

Error: ATOMICITY:
fs/jffs2/nodemgmt.c:339: lock: Locking "c->erase_completion_lock".
fs/jffs2/nodemgmt.c:376: def: Assigning: "jeb" = data that might be protected by the lock.
fs/jffs2/nodemgmt.c:344: unlock: Unlocking "c->erase_completion_lock". "jeb" might now be unreliable because other threads can now change the data that it depends on.
fs/jffs2/nodemgmt.c:353: lockagain: Locking "c->erase_completion_lock" again.
fs/jffs2/nodemgmt.c:356: use: Using an unreliable value of "jeb" inside the second locked section.  If the data that "jeb" depends on was changed by another thread, this use might be incorrect.

Error: ATOMICITY:
kernel/futex.c:1181: lock: Locking "*q->lock_ptr".
kernel/futex.c:1144: def: Assigning: "uval" = data that might be protected by the lock.
kernel/futex.c:1177: unlock: Unlocking "*q->lock_ptr". "uval" might now be unreliable because other threads can now change the data that it depends on.
kernel/futex.c:1181: lockagain: Locking "*q->lock_ptr" again.
kernel/futex.c:1138: use: Using an unreliable value of "uval" inside the second locked section.  If the data that "uval" depends on was changed by another thread, this use might be incorrect.

Error: ATOMICITY:
fs/super.c:491: lock: Locking "sb_lock".
fs/super.c:493: def: Assigning: "sb" = data that might be protected by the lock.
fs/super.c:496: unlock: Unlocking "sb_lock". "sb" might now be unreliable because other threads can now change the data that it depends on.
fs/super.c:502: lockagain: Locking "sb_lock" again.
fs/super.c:503: use: Using an unreliable value of "sb" inside the second locked section.  If the data that "sb" depends on was changed by another thread, this use might be incorrect.

Error: ATOMICITY:
fs/super.c:502: lock: Locking "sb_lock".
fs/super.c:493: def: Assigning: "sb" = data that might be protected by the lock.
fs/super.c:496: unlock: Unlocking "sb_lock". "sb" might now be unreliable because other threads can now change the data that it depends on.
fs/super.c:502: lockagain: Locking "sb_lock" again.
fs/super.c:503: use: Using an unreliable value of "sb" inside the second locked section.  If the data that "sb" depends on was changed by another thread, this use might be incorrect.

Error: ATOMICITY:
kernel/futex.c:633: lock: Locking "pi_state->pi_mutex.wait_lock".
kernel/futex.c:643: def: Assigning: "new_owner" = data that might be protected by the lock.
kernel/futex.c:670: unlock: Unlocking "pi_state->owner->pi_lock". "new_owner" might now be unreliable because other threads can now change the data that it depends on.
kernel/futex.c:672: lockagain: Locking "new_owner->pi_lock" again.
kernel/futex.c:675: use: Using an unreliable value of "new_owner" inside the second locked section.  If the data that "new_owner" depends on was changed by another thread, this use might be incorrect.

Error: ATOMICITY:
drivers/ata/libata-core.c:1695: lock: Locking "*ap->lock".
drivers/ata/libata-core.c:1717: def: Assigning: "qc" = data that might be protected by the lock.
drivers/ata/libata-core.c:1756: unlock: Unlocking "*ap->lock". "qc" might now be unreliable because other threads can now change the data that it depends on.
drivers/ata/libata-core.c:1772: lockagain: Locking "*ap->lock" again.
drivers/ata/libata-core.c:1785: use: Using an unreliable value of "qc" inside the second locked section.  If the data that "qc" depends on was changed by another thread, this use might be incorrect.

Error: ATOMICITY:
drivers/ata/libata-core.c:1695: lock: Locking "*ap->lock".
drivers/ata/libata-core.c:1728: def: Assigning: "preempted_nr_active_links" = data that might be protected by the lock.
drivers/ata/libata-core.c:1756: unlock: Unlocking "*ap->lock". "preempted_nr_active_links" might now be unreliable because other threads can now change the data that it depends on.
drivers/ata/libata-core.c:1792: unlock: Unlocking "*ap->lock". "preempted_nr_active_links" might now be unreliable because other threads can now change the data that it depends on.
drivers/ata/libata-core.c:1812: lockagain: Locking "*ap->lock" again.
drivers/ata/libata-core.c:1821: use: Using an unreliable value of "preempted_nr_active_links" inside the second locked section.  If the data that "preempted_nr_active_links" depends on was changed by another thread, this use might be incorrect.

Error: ATOMICITY:
drivers/ata/libata-core.c:1695: lock: Locking "*ap->lock".
drivers/ata/libata-core.c:1727: def: Assigning: "preempted_qc_active" = data that might be protected by the lock.
drivers/ata/libata-core.c:1756: unlock: Unlocking "*ap->lock". "preempted_qc_active" might now be unreliable because other threads can now change the data that it depends on.
drivers/ata/libata-core.c:1792: unlock: Unlocking "*ap->lock". "preempted_qc_active" might now be unreliable because other threads can now change the data that it depends on.
drivers/ata/libata-core.c:1812: lockagain: Locking "*ap->lock" again.
drivers/ata/libata-core.c:1820: use: Using an unreliable value of "preempted_qc_active" inside the second locked section.  If the data that "preempted_qc_active" depends on was changed by another thread, this use might be incorrect.

Error: ATOMICITY:
drivers/ata/libata-core.c:1695: lock: Locking "*ap->lock".
drivers/ata/libata-core.c:1726: def: Assigning: "preempted_sactive" = data that might be protected by the lock.
drivers/ata/libata-core.c:1756: unlock: Unlocking "*ap->lock". "preempted_sactive" might now be unreliable because other threads can now change the data that it depends on.
drivers/ata/libata-core.c:1792: unlock: Unlocking "*ap->lock". "preempted_sactive" might now be unreliable because other threads can now change the data that it depends on.
drivers/ata/libata-core.c:1812: lockagain: Locking "*ap->lock" again.
drivers/ata/libata-core.c:1819: use: Using an unreliable value of "preempted_sactive" inside the second locked section.  If the data that "preempted_sactive" depends on was changed by another thread, this use might be incorrect.

Error: ATOMICITY:
drivers/ata/libata-core.c:1695: lock: Locking "*ap->lock".
drivers/ata/libata-core.c:1725: def: Assigning: "preempted_tag" = data that might be protected by the lock.
drivers/ata/libata-core.c:1756: unlock: Unlocking "*ap->lock". "preempted_tag" might now be unreliable because other threads can now change the data that it depends on.
drivers/ata/libata-core.c:1792: unlock: Unlocking "*ap->lock". "preempted_tag" might now be unreliable because other threads can now change the data that it depends on.
drivers/ata/libata-core.c:1812: lockagain: Locking "*ap->lock" again.
drivers/ata/libata-core.c:1818: use: Using an unreliable value of "preempted_tag" inside the second locked section.  If the data that "preempted_tag" depends on was changed by another thread, this use might be incorrect.

Error: ATOMICITY:
drivers/ata/libata-core.c:1695: lock: Locking "*ap->lock".
drivers/ata/libata-core.c:1717: def: Assigning: "qc" = data that might be protected by the lock.
drivers/ata/libata-core.c:1756: unlock: Unlocking "*ap->lock". "qc" might now be unreliable because other threads can now change the data that it depends on.
drivers/ata/libata-core.c:1792: unlock: Unlocking "*ap->lock". "qc" might now be unreliable because other threads can now change the data that it depends on.
drivers/ata/libata-core.c:1812: lockagain: Locking "*ap->lock" again.
drivers/ata/libata-core.c:1817: use: Using an unreliable value of "qc" inside the second locked section.  If the data that "qc" depends on was changed by another thread, this use might be incorrect.

Error: ATOMICITY:
fs/xfs/xfs_log.c:2708: lock: Locking "log->l_grant_lock".
fs/xfs/xfs_log.c:2712: def: Assigning: "need_bytes" = data that might be protected by the lock.
fs/xfs/xfs_log.c:2724: unlock: Unlocking "log->l_grant_lock". "need_bytes" might now be unreliable because other threads can now change the data that it depends on.
fs/xfs/xfs_log.c:2735: lockagain: Locking "log->l_grant_lock" again.
fs/xfs/xfs_log.c:2741: use: Using an unreliable value of "need_bytes" inside the second locked section.  If the data that "need_bytes" depends on was changed by another thread, this use might be incorrect.

Error: ATOMICITY:
fs/xfs/xfs_log.c:2566: lock: Locking "log->l_grant_lock".
fs/xfs/xfs_log.c:2569: def: Assigning: "need_bytes" = data that might be protected by the lock.
fs/xfs/xfs_log.c:2585: unlock: Unlocking "log->l_grant_lock". "need_bytes" might now be unreliable because other threads can now change the data that it depends on.
fs/xfs/xfs_log.c:2595: lockagain: Locking "log->l_grant_lock" again.
fs/xfs/xfs_log.c:2601: use: Using an unreliable value of "need_bytes" inside the second locked section.  If the data that "need_bytes" depends on was changed by another thread, this use might be incorrect.

Error: ATOMICITY:
fs/reiserfs/journal.c:853: lock: Locking "*lock".
fs/reiserfs/journal.c:856: def: Assigning: "bh" = data that might be protected by the lock.
fs/reiserfs/journal.c:863: unlock: Unlocking "*lock". "bh" might now be unreliable because other threads can now change the data that it depends on.
fs/reiserfs/journal.c:868: lockagain: Locking "*lock" again.
fs/reiserfs/journal.c:887: use: Using an unreliable value of "bh" inside the second locked section.  If the data that "bh" depends on was changed by another thread, this use might be incorrect.

Error: ATOMICITY:
fs/reiserfs/journal.c:868: lock: Locking "*lock".
fs/reiserfs/journal.c:856: def: Assigning: "bh" = data that might be protected by the lock.
fs/reiserfs/journal.c:863: unlock: Unlocking "*lock". "bh" might now be unreliable because other threads can now change the data that it depends on.
fs/reiserfs/journal.c:868: lockagain: Locking "*lock" again.
fs/reiserfs/journal.c:887: use: Using an unreliable value of "bh" inside the second locked section.  If the data that "bh" depends on was changed by another thread, this use might be incorrect.

Error: ATOMICITY:
fs/reiserfs/journal.c:893: lock: Locking "*lock".
fs/reiserfs/journal.c:897: def: Assigning: "bh" = data that might be protected by the lock.
fs/reiserfs/journal.c:902: unlock: Unlocking "*lock". "bh" might now be unreliable because other threads can now change the data that it depends on.
fs/reiserfs/journal.c:904: lockagain: Locking "*lock" again.
fs/reiserfs/journal.c:906: use: Using an unreliable value of "bh" inside the second locked section.  If the data that "bh" depends on was changed by another thread, this use might be incorrect.

Error: ATOMICITY:
fs/reiserfs/journal.c:904: lock: Locking "*lock".
fs/reiserfs/journal.c:897: def: Assigning: "bh" = data that might be protected by the lock.
fs/reiserfs/journal.c:918: unlock: Unlocking "*lock". "bh" might now be unreliable because other threads can now change the data that it depends on.
fs/reiserfs/journal.c:920: lockagain: Locking "*lock" again.
fs/reiserfs/journal.c:922: use: Using an unreliable value of "bh" inside the second locked section.  If the data that "bh" depends on was changed by another thread, this use might be incorrect.

Error: ATOMICITY:
fs/reiserfs/journal.c:920: lock: Locking "*lock".
fs/reiserfs/journal.c:897: def: Assigning: "bh" = data that might be protected by the lock.
fs/reiserfs/journal.c:902: unlock: Unlocking "*lock". "bh" might now be unreliable because other threads can now change the data that it depends on.
fs/reiserfs/journal.c:904: lockagain: Locking "*lock" again.
fs/reiserfs/journal.c:906: use: Using an unreliable value of "bh" inside the second locked section.  If the data that "bh" depends on was changed by another thread, this use might be incorrect.

Error: ATOMICITY:
drivers/net/mlx4/cmd.c:273: lock: Locking "cmd->context_lock".
drivers/net/mlx4/cmd.c:277: def: Assigning: "cmd->free_head" = data that might be protected by the lock.
drivers/net/mlx4/cmd.c:278: unlock: Unlocking "cmd->context_lock". "cmd->free_head" might now be unreliable because other threads can now change the data that it depends on.
drivers/net/mlx4/cmd.c:298: lockagain: Locking "cmd->context_lock" again.
drivers/net/mlx4/cmd.c:299: use: Using an unreliable value of "cmd->free_head" inside the second locked section.  If the data that "cmd->free_head" depends on was changed by another thread, this use might be incorrect.

Error: ATOMICITY:
fs/dcache.c:2010: lock: Locking "get_current()->fs->lock".
fs/dcache.c:2011: def: Assigning: "root" = data that might be protected by the lock.
fs/dcache.c:2013: unlock: Unlocking "get_current()->fs->lock". "root" might now be unreliable because other threads can now change the data that it depends on.
fs/dcache.c:2014: lockagain: Locking "dcache_lock" again.
fs/dcache.c:2015: use: Using an unreliable value of "root" inside the second locked section.  If the data that "root" depends on was changed by another thread, this use might be incorrect.

Error: ATOMICITY:
fs/nfs/write.c:505: lock: Locking "inode->i_lock".
fs/nfs/write.c:498: def: Assigning: "next" = data that might be protected by the lock.
fs/nfs/write.c:502: unlock: Unlocking "inode->i_lock". "next" might now be unreliable because other threads can now change the data that it depends on.
fs/nfs/write.c:505: lockagain: Locking "inode->i_lock" again.
fs/nfs/write.c:494: use: Using an unreliable value of "next" inside the second locked section.  If the data that "next" depends on was changed by another thread, this use might be incorrect.

Error: ATOMICITY:
kernel/panic.c:237: lock: Locking "pause_on_oops_lock".
kernel/panic.c:237: def: Assigning: "flags" = data that might be protected by the lock.
kernel/panic.c:247: unlock: Unlocking "pause_on_oops_lock". "flags" might now be unreliable because other threads can now change the data that it depends on.
kernel/panic.c:249: lockagain: Locking "pause_on_oops_lock" again.
kernel/panic.c:261: use: Using an unreliable value of "flags" inside the second locked section.  If the data that "flags" depends on was changed by another thread, this use might be incorrect.

Error: ATOMICITY:
kernel/panic.c:237: lock: Locking "pause_on_oops_lock".
kernel/panic.c:237: def: Assigning: "flags" = data that might be protected by the lock.
kernel/panic.c:255: unlock: Unlocking "pause_on_oops_lock". "flags" might now be unreliable because other threads can now change the data that it depends on.
kernel/panic.c:257: lockagain: Locking "pause_on_oops_lock" again.
kernel/panic.c:261: use: Using an unreliable value of "flags" inside the second locked section.  If the data that "flags" depends on was changed by another thread, this use might be incorrect.

Error: ATOMICITY:
fs/jbd2/checkpoint.c:375: lock: Locking "journal->j_list_lock".
fs/jbd2/checkpoint.c:378: def: Assigning: "transaction" = data that might be protected by the lock.
fs/jbd2/checkpoint.c:401: unlock: Unlocking "journal->j_list_lock". "transaction" might now be unreliable because other threads can now change the data that it depends on.
fs/jbd2/checkpoint.c:419: unlock: Unlocking "journal->j_list_lock". "transaction" might now be unreliable because other threads can now change the data that it depends on.
fs/jbd2/checkpoint.c:426: lockagain: Locking "journal->j_list_lock" again.
fs/jbd2/checkpoint.c:405: use: Using an unreliable value of "transaction" inside the second locked section.  If the data that "transaction" depends on was changed by another thread, this use might be incorrect.

Error: ATOMICITY:
fs/jbd2/checkpoint.c:375: lock: Locking "journal->j_list_lock".
fs/jbd2/checkpoint.c:378: def: Assigning: "transaction" = data that might be protected by the lock.
fs/jbd2/checkpoint.c:401: unlock: Unlocking "journal->j_list_lock". "transaction" might now be unreliable because other threads can now change the data that it depends on.
fs/jbd2/checkpoint.c:419: unlock: Unlocking "journal->j_list_lock". "transaction" might now be unreliable because other threads can now change the data that it depends on.
fs/jbd2/checkpoint.c:426: lockagain: Locking "journal->j_list_lock" again.
fs/jbd2/checkpoint.c:433: use: Using an unreliable value of "transaction" inside the second locked section.  If the data that "transaction" depends on was changed by another thread, this use might be incorrect.

Error: ATOMICITY:
kernel/sched.c:4870: lock: Locking "q->lock".
kernel/sched.c:4870: def: Assigning: "flags" = data that might be protected by the lock.
kernel/sched.c:4872: unlock: Unlocking "q->lock". "flags" might now be unreliable because other threads can now change the data that it depends on.
kernel/sched.c:4874: lockagain: Locking "q->lock" again.
kernel/sched.c:4876: use: Using an unreliable value of "flags" inside the second locked section.  If the data that "flags" depends on was changed by another thread, this use might be incorrect.

Error: ATOMICITY:
drivers/ide/ide-iops.c:1088: lock: Locking "ide_lock".
drivers/ide/ide-iops.c:1089: def: Assigning: "hwif" = data that might be protected by the lock.
drivers/ide/ide-iops.c:1132: unlock: Unlocking "ide_lock". "hwif" might now be unreliable because other threads can now change the data that it depends on.
drivers/ide/ide-iops.c:1134: lockagain: Locking "ide_lock" again.
drivers/ide/ide-iops.c:1162: use: Using an unreliable value of "hwif" inside the second locked section.  If the data that "hwif" depends on was changed by another thread, this use might be incorrect.

Error: ATOMICITY:
drivers/scsi/lpfc/lpfc_sli.c:3394: lock: Locking "phba->hbalock".
drivers/scsi/lpfc/lpfc_sli.c:3427: def: Assigning: "mb" = data that might be protected by the lock.
drivers/scsi/lpfc/lpfc_sli.c:3627: unlock: Unlocking "phba->hbalock". "mb" might now be unreliable because other threads can now change the data that it depends on.
drivers/scsi/lpfc/lpfc_sli.c:3630: lockagain: Locking "phba->hbalock" again.
drivers/scsi/lpfc/lpfc_sli.c:3660: use: Using an unreliable value of "mb" inside the second locked section.  If the data that "mb" depends on was changed by another thread, this use might be incorrect.

Error: ATOMICITY:
drivers/scsi/lpfc/lpfc_sli.c:3394: lock: Locking "phba->hbalock".
drivers/scsi/lpfc/lpfc_sli.c:3427: def: Assigning: "mb" = data that might be protected by the lock.
drivers/scsi/lpfc/lpfc_sli.c:3627: unlock: Unlocking "phba->hbalock". "mb" might now be unreliable because other threads can now change the data that it depends on.
drivers/scsi/lpfc/lpfc_sli.c:3630: lockagain: Locking "phba->hbalock" again.
drivers/scsi/lpfc/lpfc_sli.c:3663: use: Using an unreliable value of "mb" inside the second locked section.  If the data that "mb" depends on was changed by another thread, this use might be incorrect.

Error: ATOMICITY:
drivers/scsi/lpfc/lpfc_sli.c:3394: lock: Locking "phba->hbalock".
drivers/scsi/lpfc/lpfc_sli.c:3427: def: Assigning: "mb" = data that might be protected by the lock.
drivers/scsi/lpfc/lpfc_sli.c:3627: unlock: Unlocking "phba->hbalock". "mb" might now be unreliable because other threads can now change the data that it depends on.
drivers/scsi/lpfc/lpfc_sli.c:3627: unlock: Unlocking "phba->hbalock". "mb" might now be unreliable because other threads can now change the data that it depends on.
drivers/scsi/lpfc/lpfc_sli.c:3630: lockagain: Locking "phba->hbalock" again.
drivers/scsi/lpfc/lpfc_sli.c:3660: use: Using an unreliable value of "mb" inside the second locked section.  If the data that "mb" depends on was changed by another thread, this use might be incorrect.

Error: ATOMICITY:
drivers/scsi/lpfc/lpfc_sli.c:3394: lock: Locking "phba->hbalock".
drivers/scsi/lpfc/lpfc_sli.c:3427: def: Assigning: "mb" = data that might be protected by the lock.
drivers/scsi/lpfc/lpfc_sli.c:3627: unlock: Unlocking "phba->hbalock". "mb" might now be unreliable because other threads can now change the data that it depends on.
drivers/scsi/lpfc/lpfc_sli.c:3627: unlock: Unlocking "phba->hbalock". "mb" might now be unreliable because other threads can now change the data that it depends on.
drivers/scsi/lpfc/lpfc_sli.c:3630: lockagain: Locking "phba->hbalock" again.
drivers/scsi/lpfc/lpfc_sli.c:3663: use: Using an unreliable value of "mb" inside the second locked section.  If the data that "mb" depends on was changed by another thread, this use might be incorrect.

Error: ATOMICITY:
kernel/exit.c:606: lock: Locking "tasklist_lock".
kernel/exit.c:610: def: Assigning: "c" = data that might be protected by the lock.
kernel/exit.c:648: unlock: Unlocking "tasklist_lock". "c" might now be unreliable because other threads can now change the data that it depends on.
kernel/exit.c:654: lockagain: Locking "c->alloc_lock" again.
kernel/exit.c:656: use: Using an unreliable value of "c" inside the second locked section.  If the data that "c" depends on was changed by another thread, this use might be incorrect.

Error: ATOMICITY:
kernel/exit.c:606: lock: Locking "tasklist_lock".
kernel/exit.c:610: def: Assigning: "c" = data that might be protected by the lock.
kernel/exit.c:648: unlock: Unlocking "tasklist_lock". "c" might now be unreliable because other threads can now change the data that it depends on.
kernel/exit.c:654: lockagain: Locking "c->alloc_lock" again.
kernel/exit.c:661: use: Using an unreliable value of "c" inside the second locked section.  If the data that "c" depends on was changed by another thread, this use might be incorrect.

Error: ATOMICITY:
kernel/exit.c:606: lock: Locking "tasklist_lock".
kernel/exit.c:618: def: Assigning: "c" = data that might be protected by the lock.
kernel/exit.c:648: unlock: Unlocking "tasklist_lock". "c" might now be unreliable because other threads can now change the data that it depends on.
kernel/exit.c:654: lockagain: Locking "c->alloc_lock" again.
kernel/exit.c:656: use: Using an unreliable value of "c" inside the second locked section.  If the data that "c" depends on was changed by another thread, this use might be incorrect.

Error: ATOMICITY:
kernel/exit.c:606: lock: Locking "tasklist_lock".
kernel/exit.c:618: def: Assigning: "c" = data that might be protected by the lock.
kernel/exit.c:648: unlock: Unlocking "tasklist_lock". "c" might now be unreliable because other threads can now change the data that it depends on.
kernel/exit.c:654: lockagain: Locking "c->alloc_lock" again.
kernel/exit.c:661: use: Using an unreliable value of "c" inside the second locked section.  If the data that "c" depends on was changed by another thread, this use might be incorrect.

Error: ATOMICITY:
kernel/exit.c:606: lock: Locking "tasklist_lock".
kernel/exit.c:627: def: Assigning: "c" = data that might be protected by the lock.
kernel/exit.c:648: unlock: Unlocking "tasklist_lock". "c" might now be unreliable because other threads can now change the data that it depends on.
kernel/exit.c:654: lockagain: Locking "c->alloc_lock" again.
kernel/exit.c:656: use: Using an unreliable value of "c" inside the second locked section.  If the data that "c" depends on was changed by another thread, this use might be incorrect.

Error: ATOMICITY:
kernel/exit.c:606: lock: Locking "tasklist_lock".
kernel/exit.c:627: def: Assigning: "c" = data that might be protected by the lock.
kernel/exit.c:648: unlock: Unlocking "tasklist_lock". "c" might now be unreliable because other threads can now change the data that it depends on.
kernel/exit.c:654: lockagain: Locking "c->alloc_lock" again.
kernel/exit.c:661: use: Using an unreliable value of "c" inside the second locked section.  If the data that "c" depends on was changed by another thread, this use might be incorrect.

Error: ATOMICITY:
kernel/rtmutex.c:198: lock: Locking "task->pi_lock".
kernel/rtmutex.c:233: def: Assigning: "lock" = data that might be protected by the lock.
kernel/rtmutex.c:256: unlock: Unlocking "task->pi_lock". "lock" might now be unreliable because other threads can now change the data that it depends on.
kernel/rtmutex.c:262: lockagain: Locking "task->pi_lock" again.
kernel/rtmutex.c:264: use: Using an unreliable value of "lock" inside the second locked section.  If the data that "lock" depends on was changed by another thread, this use might be incorrect.

Error: ATOMICITY:
kernel/rtmutex.c:198: lock: Locking "task->pi_lock".
kernel/rtmutex.c:252: def: Assigning: "waiter->list_entry.prio" = data that might be protected by the lock.
kernel/rtmutex.c:256: unlock: Unlocking "task->pi_lock". "waiter->list_entry.prio" might now be unreliable because other threads can now change the data that it depends on.
kernel/rtmutex.c:262: lockagain: Locking "task->pi_lock" again.
kernel/rtmutex.c:267: use: Using an unreliable value of "waiter->list_entry.prio" inside the second locked section.  If the data that "waiter->list_entry.prio" depends on was changed by another thread, this use might be incorrect.

Error: ATOMICITY:
fs/jfs/jfs_txnmgr.c:604: lock: Locking "jfsTxnLock".
fs/jfs/jfs_txnmgr.c:613: def: Assigning: "lid" = data that might be protected by the lock.
fs/jfs/jfs_txnmgr.c:846: unlock: Unlocking "jfsTxnLock". "lid" might now be unreliable because other threads can now change the data that it depends on.
fs/jfs/jfs_txnmgr.c:848: lockagain: Locking "jfsTxnLock" again.
fs/jfs/jfs_txnmgr.c:851: use: Using an unreliable value of "lid" inside the second locked section.  If the data that "lid" depends on was changed by another thread, this use might be incorrect.

Error: ATOMICITY:
fs/jfs/jfs_txnmgr.c:604: lock: Locking "jfsTxnLock".
fs/jfs/jfs_txnmgr.c:613: def: Assigning: "lid" = data that might be protected by the lock.
fs/jfs/jfs_txnmgr.c:846: unlock: Unlocking "jfsTxnLock". "lid" might now be unreliable because other threads can now change the data that it depends on.
fs/jfs/jfs_txnmgr.c:848: lockagain: Locking "jfsTxnLock" again.
fs/jfs/jfs_txnmgr.c:859: use: Using an unreliable value of "lid" inside the second locked section.  If the data that "lid" depends on was changed by another thread, this use might be incorrect.

Error: ATOMICITY:
drivers/char/tty_buffer.c:413: lock: Locking "tty->buf.lock".
drivers/char/tty_buffer.c:425: def: Assigning: "head" = data that might be protected by the lock.
drivers/char/tty_buffer.c:443: unlock: Unlocking "tty->buf.lock". "head" might now be unreliable because other threads can now change the data that it depends on.
drivers/char/tty_buffer.c:446: lockagain: Locking "tty->buf.lock" again.
drivers/char/tty_buffer.c:424: use: Using an unreliable value of "head" inside the second locked section.  If the data that "head" depends on was changed by another thread, this use might be incorrect.

Error: ATOMICITY:
drivers/char/tty_buffer.c:413: lock: Locking "tty->buf.lock".
drivers/char/tty_buffer.c:425: def: Assigning: "head" = data that might be protected by the lock.
drivers/char/tty_buffer.c:443: unlock: Unlocking "tty->buf.lock". "head" might now be unreliable because other threads can now change the data that it depends on.
drivers/char/tty_buffer.c:446: lockagain: Locking "tty->buf.lock" again.
drivers/char/tty_buffer.c:449: use: Using an unreliable value of "head" inside the second locked section.  If the data that "head" depends on was changed by another thread, this use might be incorrect.

Error: ATOMICITY:
drivers/pci/dmar.c:584: lock: Locking "qi->q_lock".
drivers/pci/dmar.c:584: def: Assigning: "flags" = data that might be protected by the lock.
drivers/pci/dmar.c:611: unlock: Unlocking "iommu->register_lock". "flags" might now be unreliable because other threads can now change the data that it depends on.
drivers/pci/dmar.c:621: unlock: Unlocking "qi->q_lock". "flags" might now be unreliable because other threads can now change the data that it depends on.
drivers/pci/dmar.c:623: lockagain: Locking "qi->q_lock" again.
drivers/pci/dmar.c:629: use: Using an unreliable value of "flags" inside the second locked section.  If the data that "flags" depends on was changed by another thread, this use might be incorrect.

Error: ATOMICITY:
sound/oss/sequencer.c:879: lock: Locking "lock".
sound/oss/sequencer.c:880: def: Assigning: "qhead" = data that might be protected by the lock.
sound/oss/sequencer.c:882: unlock: Unlocking "lock". "qhead" might now be unreliable because other threads can now change the data that it depends on.
sound/oss/sequencer.c:879: lockagain: Locking "lock" again.
sound/oss/sequencer.c:880: use: Using an unreliable value of "qhead" inside the second locked section.  If the data that "qhead" depends on was changed by another thread, this use might be incorrect.

Error: ATOMICITY:
fs/gfs2/quota.c:136: lock: Locking "sdp->sd_quota_spin".
fs/gfs2/quota.c:153: def: Assigning: "new_qd" = data that might be protected by the lock.
fs/gfs2/quota.c:156: unlock: Unlocking "sdp->sd_quota_spin". "new_qd" might now be unreliable because other threads can now change the data that it depends on.
fs/gfs2/quota.c:136: lockagain: Locking "sdp->sd_quota_spin" again.
fs/gfs2/quota.c:150: use: Using an unreliable value of "new_qd" inside the second locked section.  If the data that "new_qd" depends on was changed by another thread, this use might be incorrect.

Error: ATOMICITY:
drivers/scsi/qla4xxx/ql4_mbx.c:66: lock: Locking "ha->hardware_lock".
drivers/scsi/qla4xxx/ql4_mbx.c:77: def: Assigning: "ha->mbox_status[i]" = data that might be protected by the lock.
drivers/scsi/qla4xxx/ql4_mbx.c:88: unlock: Unlocking "ha->hardware_lock". "ha->mbox_status[i]" might now be unreliable because other threads can now change the data that it depends on.
drivers/scsi/qla4xxx/ql4_mbx.c:138: lockagain: Locking "ha->hardware_lock" again.
drivers/scsi/qla4xxx/ql4_mbx.c:140: use: Using an unreliable value of "ha->mbox_status[i]" inside the second locked section.  If the data that "ha->mbox_status[i]" depends on was changed by another thread, this use might be incorrect.

Error: ATOMICITY:
drivers/usb/core/message.c:589: lock: Locking "io->lock".
drivers/usb/core/message.c:589: def: Assigning: "flags" = data that might be protected by the lock.
drivers/usb/core/message.c:596: unlock: Unlocking "io->lock". "flags" might now be unreliable because other threads can now change the data that it depends on.
drivers/usb/core/message.c:607: lockagain: Locking "io->lock" again.
drivers/usb/core/message.c:609: use: Using an unreliable value of "flags" inside the second locked section.  If the data that "flags" depends on was changed by another thread, this use might be incorrect.

Error: ATOMICITY:
fs/jbd2/transaction.c:119: lock: Locking "journal->j_state_lock".
fs/jbd2/transaction.c:142: def: Assigning: "new_transaction" = data that might be protected by the lock.
fs/jbd2/transaction.c:156: unlock: Unlocking "journal->j_state_lock". "new_transaction" might now be unreliable because other threads can now change the data that it depends on.
fs/jbd2/transaction.c:119: lockagain: Locking "journal->j_state_lock" again.
fs/jbd2/transaction.c:141: use: Using an unreliable value of "new_transaction" inside the second locked section.  If the data that "new_transaction" depends on was changed by another thread, this use might be incorrect.

Error: ATOMICITY:
fs/jbd2/transaction.c:119: lock: Locking "journal->j_state_lock".
fs/jbd2/transaction.c:142: def: Assigning: "new_transaction" = data that might be protected by the lock.
fs/jbd2/transaction.c:179: unlock: Unlocking "transaction->t_handle_lock". "new_transaction" might now be unreliable because other threads can now change the data that it depends on.
fs/jbd2/transaction.c:183: unlock: Unlocking "journal->j_state_lock". "new_transaction" might now be unreliable because other threads can now change the data that it depends on.
fs/jbd2/transaction.c:119: lockagain: Locking "journal->j_state_lock" again.
fs/jbd2/transaction.c:141: use: Using an unreliable value of "new_transaction" inside the second locked section.  If the data that "new_transaction" depends on was changed by another thread, this use might be incorrect.

Error: ATOMICITY:
kernel/sched.c:5221: lock: Locking "p->pi_lock".
kernel/sched.c:5229: def: Assigning: "policy" = data that might be protected by the lock.
kernel/sched.c:5230: unlock: Unlocking "rq->lock". "policy" might now be unreliable because other threads can now change the data that it depends on.
kernel/sched.c:5231: unlock: Unlocking "p->pi_lock". "policy" might now be unreliable because other threads can now change the data that it depends on.
kernel/sched.c:5221: lockagain: Locking "p->pi_lock" again.
kernel/sched.c:5243: use: Using an unreliable value of "policy" inside the second locked section.  If the data that "policy" depends on was changed by another thread, this use might be incorrect.

Error: ATOMICITY:
kernel/irq/autoprobe.c:169: lock: Locking "desc->lock".
kernel/irq/autoprobe.c:178: def: Assigning: "desc->status" = data that might be protected by the lock.
kernel/irq/autoprobe.c:181: unlock: Unlocking "desc->lock". "desc->status" might now be unreliable because other threads can now change the data that it depends on.
kernel/irq/autoprobe.c:169: lockagain: Locking "desc->lock" again.
kernel/irq/autoprobe.c:170: use: Using an unreliable value of "desc->status" inside the second locked section.  If the data that "desc->status" depends on was changed by another thread, this use might be incorrect.

Error: ATOMICITY:
fs/jffs2/compr.c:140: lock: Locking "jffs2_compressor_list_lock".
fs/jffs2/compr.c:125: def: Assigning: "this" = data that might be protected by the lock.
fs/jffs2/compr.c:151: unlock: Unlocking "jffs2_compressor_list_lock". "this" might now be unreliable because other threads can now change the data that it depends on.
fs/jffs2/compr.c:155: lockagain: Locking "jffs2_compressor_list_lock" again.
fs/jffs2/compr.c:158: use: Using an unreliable value of "this" inside the second locked section.  If the data that "this" depends on was changed by another thread, this use might be incorrect.

Error: ATOMICITY:
fs/jffs2/compr.c:140: lock: Locking "jffs2_compressor_list_lock".
fs/jffs2/compr.c:125: def: Assigning: "this" = data that might be protected by the lock.
fs/jffs2/compr.c:151: unlock: Unlocking "jffs2_compressor_list_lock". "this" might now be unreliable because other threads can now change the data that it depends on.
fs/jffs2/compr.c:155: lockagain: Locking "jffs2_compressor_list_lock" again.
fs/jffs2/compr.c:162: use: Using an unreliable value of "this" inside the second locked section.  If the data that "this" depends on was changed by another thread, this use might be incorrect.

Error: ATOMICITY:
fs/jffs2/compr.c:155: lock: Locking "jffs2_compressor_list_lock".
fs/jffs2/compr.c:160: def: Assigning: "best_dlen" = data that might be protected by the lock.
fs/jffs2/compr.c:131: unlock: Unlocking "jffs2_compressor_list_lock". "best_dlen" might now be unreliable because other threads can now change the data that it depends on.
fs/jffs2/compr.c:138: unlock: Unlocking "jffs2_compressor_list_lock". "best_dlen" might now be unreliable because other threads can now change the data that it depends on.
fs/jffs2/compr.c:140: lockagain: Locking "jffs2_compressor_list_lock" again.
fs/jffs2/compr.c:167: use: Using an unreliable value of "best_dlen" inside the second locked section.  If the data that "best_dlen" depends on was changed by another thread, this use might be incorrect.

Error: ATOMICITY:
fs/jffs2/compr.c:155: lock: Locking "jffs2_compressor_list_lock".
fs/jffs2/compr.c:161: def: Assigning: "best_slen" = data that might be protected by the lock.
fs/jffs2/compr.c:131: unlock: Unlocking "jffs2_compressor_list_lock". "best_slen" might now be unreliable because other threads can now change the data that it depends on.
fs/jffs2/compr.c:138: unlock: Unlocking "jffs2_compressor_list_lock". "best_slen" might now be unreliable because other threads can now change the data that it depends on.
fs/jffs2/compr.c:140: lockagain: Locking "jffs2_compressor_list_lock" again.
fs/jffs2/compr.c:168: use: Using an unreliable value of "best_slen" inside the second locked section.  If the data that "best_slen" depends on was changed by another thread, this use might be incorrect.

Error: ATOMICITY:
fs/jffs2/compr.c:155: lock: Locking "jffs2_compressor_list_lock".
fs/jffs2/compr.c:162: def: Assigning: "best" = data that might be protected by the lock.
fs/jffs2/compr.c:131: unlock: Unlocking "jffs2_compressor_list_lock". "best" might now be unreliable because other threads can now change the data that it depends on.
fs/jffs2/compr.c:138: unlock: Unlocking "jffs2_compressor_list_lock". "best" might now be unreliable because other threads can now change the data that it depends on.
fs/jffs2/compr.c:151: unlock: Unlocking "jffs2_compressor_list_lock". "best" might now be unreliable because other threads can now change the data that it depends on.
fs/jffs2/compr.c:155: lockagain: Locking "jffs2_compressor_list_lock" again.
fs/jffs2/compr.c:158: use: Using an unreliable value of "best" inside the second locked section.  If the data that "best" depends on was changed by another thread, this use might be incorrect.

Error: ATOMICITY:
fs/jffs2/compr.c:155: lock: Locking "jffs2_compressor_list_lock".
fs/jffs2/compr.c:160: def: Assigning: "best_dlen" = data that might be protected by the lock.
fs/jffs2/compr.c:131: unlock: Unlocking "jffs2_compressor_list_lock". "best_dlen" might now be unreliable because other threads can now change the data that it depends on.
fs/jffs2/compr.c:138: unlock: Unlocking "jffs2_compressor_list_lock". "best_dlen" might now be unreliable because other threads can now change the data that it depends on.
fs/jffs2/compr.c:151: unlock: Unlocking "jffs2_compressor_list_lock". "best_dlen" might now be unreliable because other threads can now change the data that it depends on.
fs/jffs2/compr.c:155: lockagain: Locking "jffs2_compressor_list_lock" again.
fs/jffs2/compr.c:158: use: Using an unreliable value of "best_dlen" inside the second locked section.  If the data that "best_dlen" depends on was changed by another thread, this use might be incorrect.

Error: ATOMICITY:
fs/jffs2/compr.c:155: lock: Locking "jffs2_compressor_list_lock".
fs/jffs2/compr.c:125: def: Assigning: "this" = data that might be protected by the lock.
fs/jffs2/compr.c:131: unlock: Unlocking "jffs2_compressor_list_lock". "this" might now be unreliable because other threads can now change the data that it depends on.
fs/jffs2/compr.c:138: unlock: Unlocking "jffs2_compressor_list_lock". "this" might now be unreliable because other threads can now change the data that it depends on.
fs/jffs2/compr.c:151: unlock: Unlocking "jffs2_compressor_list_lock". "this" might now be unreliable because other threads can now change the data that it depends on.
fs/jffs2/compr.c:155: lockagain: Locking "jffs2_compressor_list_lock" again.
fs/jffs2/compr.c:158: use: Using an unreliable value of "this" inside the second locked section.  If the data that "this" depends on was changed by another thread, this use might be incorrect.

Error: ATOMICITY:
fs/jffs2/compr.c:155: lock: Locking "jffs2_compressor_list_lock".
fs/jffs2/compr.c:125: def: Assigning: "this" = data that might be protected by the lock.
fs/jffs2/compr.c:131: unlock: Unlocking "jffs2_compressor_list_lock". "this" might now be unreliable because other threads can now change the data that it depends on.
fs/jffs2/compr.c:138: unlock: Unlocking "jffs2_compressor_list_lock". "this" might now be unreliable because other threads can now change the data that it depends on.
fs/jffs2/compr.c:151: unlock: Unlocking "jffs2_compressor_list_lock". "this" might now be unreliable because other threads can now change the data that it depends on.
fs/jffs2/compr.c:155: lockagain: Locking "jffs2_compressor_list_lock" again.
fs/jffs2/compr.c:162: use: Using an unreliable value of "this" inside the second locked section.  If the data that "this" depends on was changed by another thread, this use might be incorrect.

Error: ATOMICITY:
kernel/irq/autoprobe.c:89: lock: Locking "desc->lock".
kernel/irq/autoprobe.c:95: def: Assigning: "desc->status" = data that might be protected by the lock.
kernel/irq/autoprobe.c:101: unlock: Unlocking "desc->lock". "desc->status" might now be unreliable because other threads can now change the data that it depends on.
kernel/irq/autoprobe.c:89: lockagain: Locking "desc->lock" again.
kernel/irq/autoprobe.c:90: use: Using an unreliable value of "desc->status" inside the second locked section.  If the data that "desc->status" depends on was changed by another thread, this use might be incorrect.

Error: ATOMICITY:
drivers/usb/core/message.c:558: lock: Locking "io->lock".
drivers/usb/core/message.c:523: def: Assigning: "retval" = data that might be protected by the lock.
drivers/usb/core/message.c:528: unlock: Unlocking "io->lock". "retval" might now be unreliable because other threads can now change the data that it depends on.
drivers/usb/core/message.c:558: lockagain: Locking "io->lock" again.
drivers/usb/core/message.c:560: use: Using an unreliable value of "retval" inside the second locked section.  If the data that "retval" depends on was changed by another thread, this use might be incorrect.

Error: ATOMICITY:
drivers/ide/ide-io.c:306: lock: Locking "ide_lock".
drivers/ide/ide-io.c:307: def: Assigning: "rq" = data that might be protected by the lock.
drivers/ide/ide-io.c:308: unlock: Unlocking "ide_lock". "rq" might now be unreliable because other threads can now change the data that it depends on.
drivers/ide/ide-io.c:336: lockagain: Locking "ide_lock" again.
drivers/ide/ide-io.c:339: use: Using an unreliable value of "rq" inside the second locked section.  If the data that "rq" depends on was changed by another thread, this use might be incorrect.

Error: ATOMICITY:
drivers/infiniband/hw/nes/nes_cm.c:934: lock: Locking "cm_core->ht_lock".
drivers/infiniband/hw/nes/nes_cm.c:935: def: Assigning: "list_temp" = data that might be protected by the lock.
drivers/infiniband/hw/nes/nes_cm.c:942: unlock: Unlocking "cm_core->ht_lock". "list_temp" might now be unreliable because other threads can now change the data that it depends on.
drivers/infiniband/hw/nes/nes_cm.c:945: lockagain: Locking "cm_core->ht_lock" again.
drivers/infiniband/hw/nes/nes_cm.c:935: use: Using an unreliable value of "list_temp" inside the second locked section.  If the data that "list_temp" depends on was changed by another thread, this use might be incorrect.

Error: ATOMICITY:
fs/direct-io.c:457: lock: Locking "dio->bio_lock".
fs/direct-io.c:459: def: Assigning: "dio->bio_list" = data that might be protected by the lock.
fs/direct-io.c:460: unlock: Unlocking "dio->bio_lock". "dio->bio_list" might now be unreliable because other threads can now change the data that it depends on.
fs/direct-io.c:457: lockagain: Locking "dio->bio_lock" again.
fs/direct-io.c:458: use: Using an unreliable value of "dio->bio_list" inside the second locked section.  If the data that "dio->bio_list" depends on was changed by another thread, this use might be incorrect.

Error: ATOMICITY:
fs/ncpfs/sock.c:755: lock: Locking "get_current()->sighand->siglock".
fs/ncpfs/sock.c:756: def: Assigning: "old_set" = data that might be protected by the lock.
fs/ncpfs/sock.c:774: unlock: Unlocking "get_current()->sighand->siglock". "old_set" might now be unreliable because other threads can now change the data that it depends on.
fs/ncpfs/sock.c:778: lockagain: Locking "get_current()->sighand->siglock" again.
fs/ncpfs/sock.c:779: use: Using an unreliable value of "old_set" inside the second locked section.  If the data that "old_set" depends on was changed by another thread, this use might be incorrect.

Error: ATOMICITY:
fs/exportfs/expfs.c:49: lock: Locking "dcache_lock".
fs/exportfs/expfs.c:50: def: Assigning: "dentry" = data that might be protected by the lock.
fs/exportfs/expfs.c:52: unlock: Unlocking "dcache_lock". "dentry" might now be unreliable because other threads can now change the data that it depends on.
fs/exportfs/expfs.c:59: lockagain: Locking "dcache_lock" again.
fs/exportfs/expfs.c:60: use: Using an unreliable value of "dentry" inside the second locked section.  If the data that "dentry" depends on was changed by another thread, this use might be incorrect.

Error: ATOMICITY:
fs/exportfs/expfs.c:59: lock: Locking "dcache_lock".
fs/exportfs/expfs.c:50: def: Assigning: "dentry" = data that might be protected by the lock.
fs/exportfs/expfs.c:52: unlock: Unlocking "dcache_lock". "dentry" might now be unreliable because other threads can now change the data that it depends on.
fs/exportfs/expfs.c:59: lockagain: Locking "dcache_lock" again.
fs/exportfs/expfs.c:60: use: Using an unreliable value of "dentry" inside the second locked section.  If the data that "dentry" depends on was changed by another thread, this use might be incorrect.

Error: ATOMICITY:
net/ipv6/addrconf.c:606: lock: Locking "addrconf_hash_lock".
net/ipv6/addrconf.c:615: def: Assigning: "ifa" = data that might be protected by the lock.
net/ipv6/addrconf.c:662: unlock: Unlocking "addrconf_hash_lock". "ifa" might now be unreliable because other threads can now change the data that it depends on.
net/ipv6/addrconf.c:664: lockagain: Locking "idev->lock" again.
net/ipv6/addrconf.c:666: use: Using an unreliable value of "ifa" inside the second locked section.  If the data that "ifa" depends on was changed by another thread, this use might be incorrect.

Error: ATOMICITY:
drivers/scsi/scsi_lib.c:512: lock: Locking "*shost->host_lock".
drivers/scsi/scsi_lib.c:515: def: Assigning: "sdev" = data that might be protected by the lock.
drivers/scsi/scsi_lib.c:522: unlock: Unlocking "*shost->host_lock". "sdev" might now be unreliable because other threads can now change the data that it depends on.
drivers/scsi/scsi_lib.c:524: lockagain: Locking "*shost->host_lock" again.
drivers/scsi/scsi_lib.c:526: use: Using an unreliable value of "sdev" inside the second locked section.  If the data that "sdev" depends on was changed by another thread, this use might be incorrect.

Error: ATOMICITY:
drivers/scsi/scsi_lib.c:512: lock: Locking "*shost->host_lock".
drivers/scsi/scsi_lib.c:515: def: Assigning: "tmp" = data that might be protected by the lock.
drivers/scsi/scsi_lib.c:522: unlock: Unlocking "*shost->host_lock". "tmp" might now be unreliable because other threads can now change the data that it depends on.
drivers/scsi/scsi_lib.c:524: lockagain: Locking "*shost->host_lock" again.
drivers/scsi/scsi_lib.c:515: use: Using an unreliable value of "tmp" inside the second locked section.  If the data that "tmp" depends on was changed by another thread, this use might be incorrect.

Error: ATOMICITY:
drivers/infiniband/hw/nes/nes_cm.c:1191: lock: Locking "cm_node->recv_list_lock".
drivers/infiniband/hw/nes/nes_cm.c:1196: def: Assigning: "cm_id" = data that might be protected by the lock.
drivers/infiniband/hw/nes/nes_cm.c:1197: unlock: Unlocking "cm_node->recv_list_lock". "cm_id" might now be unreliable because other threads can now change the data that it depends on.
drivers/infiniband/hw/nes/nes_cm.c:1199: lockagain: Locking "nesqp->lock" again.
drivers/infiniband/hw/nes/nes_cm.c:1201: use: Using an unreliable value of "cm_id" inside the second locked section.  If the data that "cm_id" depends on was changed by another thread, this use might be incorrect.

Error: ATOMICITY:
drivers/infiniband/hw/nes/nes_cm.c:1218: lock: Locking "cm_node->recv_list_lock".
drivers/infiniband/hw/nes/nes_cm.c:1196: def: Assigning: "cm_id" = data that might be protected by the lock.
drivers/infiniband/hw/nes/nes_cm.c:1197: unlock: Unlocking "cm_node->recv_list_lock". "cm_id" might now be unreliable because other threads can now change the data that it depends on.
drivers/infiniband/hw/nes/nes_cm.c:1199: lockagain: Locking "nesqp->lock" again.
drivers/infiniband/hw/nes/nes_cm.c:1201: use: Using an unreliable value of "cm_id" inside the second locked section.  If the data that "cm_id" depends on was changed by another thread, this use might be incorrect.

Error: ATOMICITY:
drivers/infiniband/hw/nes/nes_cm.c:1191: lock: Locking "cm_node->recv_list_lock".
drivers/infiniband/hw/nes/nes_cm.c:1192: def: Assigning: "list_node_temp" = data that might be protected by the lock.
drivers/infiniband/hw/nes/nes_cm.c:1197: unlock: Unlocking "cm_node->recv_list_lock". "list_node_temp" might now be unreliable because other threads can now change the data that it depends on.
drivers/infiniband/hw/nes/nes_cm.c:1207: unlock: Unlocking "nesqp->lock". "list_node_temp" might now be unreliable because other threads can now change the data that it depends on.
drivers/infiniband/hw/nes/nes_cm.c:1218: lockagain: Locking "cm_node->recv_list_lock" again.
drivers/infiniband/hw/nes/nes_cm.c:1192: use: Using an unreliable value of "list_node_temp" inside the second locked section.  If the data that "list_node_temp" depends on was changed by another thread, this use might be incorrect.

Error: ATOMICITY:
drivers/infiniband/hw/nes/nes_cm.c:1218: lock: Locking "cm_node->recv_list_lock".
drivers/infiniband/hw/nes/nes_cm.c:1192: def: Assigning: "list_node_temp" = data that might be protected by the lock.
drivers/infiniband/hw/nes/nes_cm.c:1197: unlock: Unlocking "cm_node->recv_list_lock". "list_node_temp" might now be unreliable because other threads can now change the data that it depends on.
drivers/infiniband/hw/nes/nes_cm.c:1207: unlock: Unlocking "nesqp->lock". "list_node_temp" might now be unreliable because other threads can now change the data that it depends on.
drivers/infiniband/hw/nes/nes_cm.c:1218: lockagain: Locking "cm_node->recv_list_lock" again.
drivers/infiniband/hw/nes/nes_cm.c:1192: use: Using an unreliable value of "list_node_temp" inside the second locked section.  If the data that "list_node_temp" depends on was changed by another thread, this use might be incorrect.

Error: ATOMICITY:
mm/vmscan.c:2449: lock: Locking "zone->lru_lock".
mm/vmscan.c:2436: def: Assigning: "page" = data that might be protected by the lock.
mm/vmscan.c:2447: unlock: Unlocking "zone->lru_lock". "page" might now be unreliable because other threads can now change the data that it depends on.
mm/vmscan.c:2449: lockagain: Locking "zone->lru_lock" again.
mm/vmscan.c:2452: use: Using an unreliable value of "page" inside the second locked section.  If the data that "page" depends on was changed by another thread, this use might be incorrect.

Error: ATOMICITY:
drivers/scsi/scsi_lib.c:578: lock: Locking "*shost->host_lock".
drivers/scsi/scsi_lib.c:578: def: Assigning: "flags" = data that might be protected by the lock.
drivers/scsi/scsi_lib.c:606: unlock: Unlocking "*shost->host_lock". "flags" might now be unreliable because other threads can now change the data that it depends on.
drivers/scsi/scsi_lib.c:617: unlock: Unlocking "*sdev->request_queue->queue_lock". "flags" might now be unreliable because other threads can now change the data that it depends on.
drivers/scsi/scsi_lib.c:619: lockagain: Locking "*shost->host_lock" again.
drivers/scsi/scsi_lib.c:623: use: Using an unreliable value of "flags" inside the second locked section.  If the data that "flags" depends on was changed by another thread, this use might be incorrect.

Error: ATOMICITY:
fs/fs-writeback.c:652: lock: Locking "sb_lock".
fs/fs-writeback.c:654: def: Assigning: "sb" = data that might be protected by the lock.
fs/fs-writeback.c:659: unlock: Unlocking "sb_lock". "sb" might now be unreliable because other threads can now change the data that it depends on.
fs/fs-writeback.c:666: lockagain: Locking "sb_lock" again.
fs/fs-writeback.c:667: use: Using an unreliable value of "sb" inside the second locked section.  If the data that "sb" depends on was changed by another thread, this use might be incorrect.

Error: ATOMICITY:
drivers/scsi/dpt_i2o.c:1299: lock: Locking "adpt_post_wait_lock".
drivers/scsi/dpt_i2o.c:1303: def: Assigning: "adpt_post_wait_queue" = data that might be protected by the lock.
drivers/scsi/dpt_i2o.c:1307: unlock: Unlocking "adpt_post_wait_lock". "adpt_post_wait_queue" might now be unreliable because other threads can now change the data that it depends on.
drivers/scsi/dpt_i2o.c:1319: unlock: Unlocking "*pHba->host->host_lock". "adpt_post_wait_queue" might now be unreliable because other threads can now change the data that it depends on.
drivers/scsi/dpt_i2o.c:1344: lockagain: Locking "adpt_post_wait_lock" again.
drivers/scsi/dpt_i2o.c:1345: use: Using an unreliable value of "adpt_post_wait_queue" inside the second locked section.  If the data that "adpt_post_wait_queue" depends on was changed by another thread, this use might be incorrect.

Error: ATOMICITY:
drivers/infiniband/core/cm.c:387: lock: Locking "cm.lock".
drivers/infiniband/core/cm.c:391: def: Assigning: "next_id" = data that might be protected by the lock.
drivers/infiniband/core/cm.c:392: unlock: Unlocking "cm.lock". "next_id" might now be unreliable because other threads can now change the data that it depends on.
drivers/infiniband/core/cm.c:387: lockagain: Locking "cm.lock" again.
drivers/infiniband/core/cm.c:388: use: Using an unreliable value of "next_id" inside the second locked section.  If the data that "next_id" depends on was changed by another thread, this use might be incorrect.

Error: ATOMICITY:
fs/super.c:445: lock: Locking "sb_lock".
fs/super.c:455: def: Assigning: "sb" = data that might be protected by the lock.
fs/super.c:462: unlock: Unlocking "sb_lock". "sb" might now be unreliable because other threads can now change the data that it depends on.
fs/super.c:468: lockagain: Locking "sb_lock" again.
fs/super.c:469: use: Using an unreliable value of "sb" inside the second locked section.  If the data that "sb" depends on was changed by another thread, this use might be incorrect.

Error: ATOMICITY:
net/irda/irttp.c:726: lock: Locking "self->lock".
net/irda/irttp.c:733: def: Assigning: "self->avail_credit" = data that might be protected by the lock.
net/irda/irttp.c:739: unlock: Unlocking "self->lock". "self->avail_credit" might now be unreliable because other threads can now change the data that it depends on.
net/irda/irttp.c:726: lockagain: Locking "self->lock" again.
net/irda/irttp.c:728: use: Using an unreliable value of "self->avail_credit" inside the second locked section.  If the data that "self->avail_credit" depends on was changed by another thread, this use might be incorrect.

Error: ATOMICITY:
fs/super.c:406: lock: Locking "sb_lock".
fs/super.c:408: def: Assigning: "sb" = data that might be protected by the lock.
fs/super.c:411: unlock: Unlocking "sb_lock". "sb" might now be unreliable because other threads can now change the data that it depends on.
fs/super.c:415: lockagain: Locking "sb_lock" again.
fs/super.c:416: use: Using an unreliable value of "sb" inside the second locked section.  If the data that "sb" depends on was changed by another thread, this use might be incorrect.

Error: ATOMICITY:
fs/super.c:415: lock: Locking "sb_lock".
fs/super.c:408: def: Assigning: "sb" = data that might be protected by the lock.
fs/super.c:411: unlock: Unlocking "sb_lock". "sb" might now be unreliable because other threads can now change the data that it depends on.
fs/super.c:415: lockagain: Locking "sb_lock" again.
fs/super.c:416: use: Using an unreliable value of "sb" inside the second locked section.  If the data that "sb" depends on was changed by another thread, this use might be incorrect.

Error: ATOMICITY:
drivers/md/md.c:474: lock: Locking "mddev->write_lock".
drivers/md/md.c:476: def: Assigning: "mddev->biolist" = data that might be protected by the lock.
drivers/md/md.c:478: unlock: Unlocking "mddev->write_lock". "mddev->biolist" might now be unreliable because other threads can now change the data that it depends on.
drivers/md/md.c:474: lockagain: Locking "mddev->write_lock" again.
drivers/md/md.c:475: use: Using an unreliable value of "mddev->biolist" inside the second locked section.  If the data that "mddev->biolist" depends on was changed by another thread, this use might be incorrect.

Error: ATOMICITY:
fs/jbd/commit.c:208: lock: Locking "journal->j_list_lock".
fs/jbd/commit.c:212: def: Assigning: "bh" = data that might be protected by the lock.
fs/jbd/commit.c:226: unlock: Unlocking "journal->j_list_lock". "bh" might now be unreliable because other threads can now change the data that it depends on.
fs/jbd/commit.c:231: lockagain: Locking "journal->j_list_lock" again.
fs/jbd/commit.c:236: use: Using an unreliable value of "bh" inside the second locked section.  If the data that "bh" depends on was changed by another thread, this use might be incorrect.

Error: ATOMICITY:
fs/jbd/commit.c:238: lock: Locking "journal->j_list_lock".
fs/jbd/commit.c:212: def: Assigning: "bh" = data that might be protected by the lock.
fs/jbd/commit.c:236: unlock: Unlocking "journal->j_list_lock". "bh" might now be unreliable because other threads can now change the data that it depends on.
fs/jbd/commit.c:238: lockagain: Locking "journal->j_list_lock" again.
fs/jbd/commit.c:241: use: Using an unreliable value of "bh" inside the second locked section.  If the data that "bh" depends on was changed by another thread, this use might be incorrect.

Error: ATOMICITY:
fs/jbd/commit.c:208: lock: Locking "journal->j_list_lock".
fs/jbd/commit.c:211: def: Assigning: "jh" = data that might be protected by the lock.
fs/jbd/commit.c:226: unlock: Unlocking "journal->j_list_lock". "jh" might now be unreliable because other threads can now change the data that it depends on.
fs/jbd/commit.c:236: unlock: Unlocking "journal->j_list_lock". "jh" might now be unreliable because other threads can now change the data that it depends on.
fs/jbd/commit.c:238: lockagain: Locking "journal->j_list_lock" again.
fs/jbd/commit.c:254: use: Using an unreliable value of "jh" inside the second locked section.  If the data that "jh" depends on was changed by another thread, this use might be incorrect.

Error: ATOMICITY:
fs/jbd/commit.c:208: lock: Locking "journal->j_list_lock".
fs/jbd/commit.c:211: def: Assigning: "jh" = data that might be protected by the lock.
fs/jbd/commit.c:226: unlock: Unlocking "journal->j_list_lock". "jh" might now be unreliable because other threads can now change the data that it depends on.
fs/jbd/commit.c:236: unlock: Unlocking "journal->j_list_lock". "jh" might now be unreliable because other threads can now change the data that it depends on.
fs/jbd/commit.c:238: lockagain: Locking "journal->j_list_lock" again.
fs/jbd/commit.c:264: use: Using an unreliable value of "jh" inside the second locked section.  If the data that "jh" depends on was changed by another thread, this use might be incorrect.

Error: ATOMICITY:
fs/jbd/commit.c:208: lock: Locking "journal->j_list_lock".
fs/jbd/commit.c:211: def: Assigning: "jh" = data that might be protected by the lock.
fs/jbd/commit.c:226: unlock: Unlocking "journal->j_list_lock". "jh" might now be unreliable because other threads can now change the data that it depends on.
fs/jbd/commit.c:236: unlock: Unlocking "journal->j_list_lock". "jh" might now be unreliable because other threads can now change the data that it depends on.
fs/jbd/commit.c:238: lockagain: Locking "journal->j_list_lock" again.
fs/jbd/commit.c:272: use: Using an unreliable value of "jh" inside the second locked section.  If the data that "jh" depends on was changed by another thread, this use might be incorrect.

Error: ATOMICITY:
sound/core/timer.c:659: lock: Locking "timer->lock".
sound/core/timer.c:659: def: Assigning: "flags" = data that might be protected by the lock.
sound/core/timer.c:734: unlock: Unlocking "timer->lock". "flags" might now be unreliable because other threads can now change the data that it depends on.
sound/core/timer.c:737: lockagain: Locking "timer->lock" again.
sound/core/timer.c:743: use: Using an unreliable value of "flags" inside the second locked section.  If the data that "flags" depends on was changed by another thread, this use might be incorrect.

Error: ATOMICITY:
drivers/isdn/i4l/isdn_ttyfax.c:373: lock: Locking "dev->lock".
drivers/isdn/i4l/isdn_ttyfax.c:382: def: Assigning: "info->isdn_channel" = data that might be protected by the lock.
drivers/isdn/i4l/isdn_ttyfax.c:385: unlock: Unlocking "dev->lock". "info->isdn_channel" might now be unreliable because other threads can now change the data that it depends on.
drivers/isdn/i4l/isdn_ttyfax.c:389: lockagain: Locking "dev->lock" again.
drivers/isdn/i4l/isdn_ttyfax.c:390: use: Using an unreliable value of "info->isdn_channel" inside the second locked section.  If the data that "info->isdn_channel" depends on was changed by another thread, this use might be incorrect.

Error: ATOMICITY:
drivers/isdn/i4l/isdn_ttyfax.c:373: lock: Locking "dev->lock".
drivers/isdn/i4l/isdn_ttyfax.c:381: def: Assigning: "info->isdn_driver" = data that might be protected by the lock.
drivers/isdn/i4l/isdn_ttyfax.c:385: unlock: Unlocking "dev->lock". "info->isdn_driver" might now be unreliable because other threads can now change the data that it depends on.
drivers/isdn/i4l/isdn_ttyfax.c:389: lockagain: Locking "dev->lock" again.
drivers/isdn/i4l/isdn_ttyfax.c:390: use: Using an unreliable value of "info->isdn_driver" inside the second locked section.  If the data that "info->isdn_driver" depends on was changed by another thread, this use might be incorrect.

Error: ATOMICITY:
net/ipv4/inet_fragment.c:168: lock: Locking "f->lock".
net/ipv4/inet_fragment.c:174: def: Assigning: "q" = data that might be protected by the lock.
net/ipv4/inet_fragment.c:177: unlock: Unlocking "f->lock". "q" might now be unreliable because other threads can now change the data that it depends on.
net/ipv4/inet_fragment.c:179: lockagain: Locking "q->lock" again.
net/ipv4/inet_fragment.c:181: use: Using an unreliable value of "q" inside the second locked section.  If the data that "q" depends on was changed by another thread, this use might be incorrect.

Error: ATOMICITY:
fs/ocfs2/dlm/dlmmaster.c:2472: lock: Locking "dlm->spinlock".
fs/ocfs2/dlm/dlmmaster.c:2476: def: Assigning: "target" = data that might be protected by the lock.
fs/ocfs2/dlm/dlmmaster.c:2487: unlock: Unlocking "dlm->spinlock". "target" might now be unreliable because other threads can now change the data that it depends on.
fs/ocfs2/dlm/dlmmaster.c:2559: unlock: Unlocking "dlm->master_lock". "target" might now be unreliable because other threads can now change the data that it depends on.
fs/ocfs2/dlm/dlmmaster.c:2560: unlock: Unlocking "dlm->spinlock". "target" might now be unreliable because other threads can now change the data that it depends on.
fs/ocfs2/dlm/dlmmaster.c:2631: lockagain: Locking "res->spinlock" again.
fs/ocfs2/dlm/dlmmaster.c:2632: use: Using an unreliable value of "target" inside the second locked section.  If the data that "target" depends on was changed by another thread, this use might be incorrect.

Error: ATOMICITY:
fs/ocfs2/dlm/dlmmaster.c:2472: lock: Locking "dlm->spinlock".
fs/ocfs2/dlm/dlmmaster.c:2476: def: Assigning: "target" = data that might be protected by the lock.
fs/ocfs2/dlm/dlmmaster.c:2500: unlock: Unlocking "dlm->master_lock". "target" might now be unreliable because other threads can now change the data that it depends on.
fs/ocfs2/dlm/dlmmaster.c:2501: unlock: Unlocking "dlm->spinlock". "target" might now be unreliable because other threads can now change the data that it depends on.
fs/ocfs2/dlm/dlmmaster.c:2559: unlock: Unlocking "dlm->master_lock". "target" might now be unreliable because other threads can now change the data that it depends on.
fs/ocfs2/dlm/dlmmaster.c:2560: unlock: Unlocking "dlm->spinlock". "target" might now be unreliable because other threads can now change the data that it depends on.
fs/ocfs2/dlm/dlmmaster.c:2631: lockagain: Locking "res->spinlock" again.
fs/ocfs2/dlm/dlmmaster.c:2632: use: Using an unreliable value of "target" inside the second locked section.  If the data that "target" depends on was changed by another thread, this use might be incorrect.

Error: ATOMICITY:
fs/ocfs2/dlm/dlmmaster.c:2472: lock: Locking "dlm->spinlock".
fs/ocfs2/dlm/dlmmaster.c:2476: def: Assigning: "target" = data that might be protected by the lock.
fs/ocfs2/dlm/dlmmaster.c:2500: unlock: Unlocking "dlm->master_lock". "target" might now be unreliable because other threads can now change the data that it depends on.
fs/ocfs2/dlm/dlmmaster.c:2501: unlock: Unlocking "dlm->spinlock". "target" might now be unreliable because other threads can now change the data that it depends on.
fs/ocfs2/dlm/dlmmaster.c:2520: unlock: Unlocking "res->spinlock". "target" might now be unreliable because other threads can now change the data that it depends on.
fs/ocfs2/dlm/dlmmaster.c:2559: unlock: Unlocking "dlm->master_lock". "target" might now be unreliable because other threads can now change the data that it depends on.
fs/ocfs2/dlm/dlmmaster.c:2560: unlock: Unlocking "dlm->spinlock". "target" might now be unreliable because other threads can now change the data that it depends on.
fs/ocfs2/dlm/dlmmaster.c:2631: lockagain: Locking "res->spinlock" again.
fs/ocfs2/dlm/dlmmaster.c:2632: use: Using an unreliable value of "target" inside the second locked section.  If the data that "target" depends on was changed by another thread, this use might be incorrect.

Error: ATOMICITY:
fs/ocfs2/dlm/dlmmaster.c:1013: lock: Locking "mle->spinlock".
fs/ocfs2/dlm/dlmmaster.c:1014: def: Assigning: "m" = data that might be protected by the lock.
fs/ocfs2/dlm/dlmmaster.c:1074: unlock: Unlocking "mle->spinlock". "m" might now be unreliable because other threads can now change the data that it depends on.
fs/ocfs2/dlm/dlmmaster.c:1120: lockagain: Locking "res->spinlock" again.
fs/ocfs2/dlm/dlmmaster.c:1123: use: Using an unreliable value of "m" inside the second locked section.  If the data that "m" depends on was changed by another thread, this use might be incorrect.

Error: ATOMICITY:
fs/ocfs2/dlm/dlmmaster.c:1013: lock: Locking "mle->spinlock".
fs/ocfs2/dlm/dlmmaster.c:1031: def: Assigning: "*blocked" = data that might be protected by the lock.
fs/ocfs2/dlm/dlmmaster.c:1033: unlock: Unlocking "mle->spinlock". "*blocked" might now be unreliable because other threads can now change the data that it depends on.
fs/ocfs2/dlm/dlmmaster.c:1011: unlock: Unlocking "res->spinlock". "*blocked" might now be unreliable because other threads can now change the data that it depends on.
fs/ocfs2/dlm/dlmmaster.c:1013: lockagain: Locking "mle->spinlock" again.
fs/ocfs2/dlm/dlmmaster.c:1025: use: Using an unreliable value of "*blocked" inside the second locked section.  If the data that "*blocked" depends on was changed by another thread, this use might be incorrect.

Error: ATOMICITY:
fs/ocfs2/dlm/dlmmaster.c:1013: lock: Locking "mle->spinlock".
fs/ocfs2/dlm/dlmmaster.c:1063: def: Assigning: "mle->master" = data that might be protected by the lock.
fs/ocfs2/dlm/dlmmaster.c:1074: unlock: Unlocking "mle->spinlock". "mle->master" might now be unreliable because other threads can now change the data that it depends on.
fs/ocfs2/dlm/dlmmaster.c:1011: unlock: Unlocking "res->spinlock". "mle->master" might now be unreliable because other threads can now change the data that it depends on.
fs/ocfs2/dlm/dlmmaster.c:1013: lockagain: Locking "mle->spinlock" again.
fs/ocfs2/dlm/dlmmaster.c:1014: use: Using an unreliable value of "mle->master" inside the second locked section.  If the data that "mle->master" depends on was changed by another thread, this use might be incorrect.

Error: ATOMICITY:
fs/ocfs2/dlm/dlmmaster.c:1013: lock: Locking "mle->spinlock".
fs/ocfs2/dlm/dlmmaster.c:1031: def: Assigning: "*blocked" = data that might be protected by the lock.
fs/ocfs2/dlm/dlmmaster.c:1033: unlock: Unlocking "mle->spinlock". "*blocked" might now be unreliable because other threads can now change the data that it depends on.
fs/ocfs2/dlm/dlmmaster.c:1011: unlock: Unlocking "res->spinlock". "*blocked" might now be unreliable because other threads can now change the data that it depends on.
fs/ocfs2/dlm/dlmmaster.c:1074: unlock: Unlocking "mle->spinlock". "*blocked" might now be unreliable because other threads can now change the data that it depends on.
fs/ocfs2/dlm/dlmmaster.c:1011: unlock: Unlocking "res->spinlock". "*blocked" might now be unreliable because other threads can now change the data that it depends on.
fs/ocfs2/dlm/dlmmaster.c:1013: lockagain: Locking "mle->spinlock" again.
fs/ocfs2/dlm/dlmmaster.c:1025: use: Using an unreliable value of "*blocked" inside the second locked section.  If the data that "*blocked" depends on was changed by another thread, this use might be incorrect.

Error: ATOMICITY:
fs/ocfs2/dlm/dlmmaster.c:1013: lock: Locking "mle->spinlock".
fs/ocfs2/dlm/dlmmaster.c:1031: def: Assigning: "*blocked" = data that might be protected by the lock.
fs/ocfs2/dlm/dlmmaster.c:1033: unlock: Unlocking "mle->spinlock". "*blocked" might now be unreliable because other threads can now change the data that it depends on.
fs/ocfs2/dlm/dlmmaster.c:1011: unlock: Unlocking "res->spinlock". "*blocked" might now be unreliable because other threads can now change the data that it depends on.
fs/ocfs2/dlm/dlmmaster.c:1074: unlock: Unlocking "mle->spinlock". "*blocked" might now be unreliable because other threads can now change the data that it depends on.
fs/ocfs2/dlm/dlmmaster.c:1011: unlock: Unlocking "res->spinlock". "*blocked" might now be unreliable because other threads can now change the data that it depends on.
fs/ocfs2/dlm/dlmmaster.c:1074: unlock: Unlocking "mle->spinlock". "*blocked" might now be unreliable because other threads can now change the data that it depends on.
fs/ocfs2/dlm/dlmmaster.c:1011: unlock: Unlocking "res->spinlock". "*blocked" might now be unreliable because other threads can now change the data that it depends on.
fs/ocfs2/dlm/dlmmaster.c:1013: lockagain: Locking "mle->spinlock" again.
fs/ocfs2/dlm/dlmmaster.c:1025: use: Using an unreliable value of "*blocked" inside the second locked section.  If the data that "*blocked" depends on was changed by another thread, this use might be incorrect.

Error: ATOMICITY:
fs/ocfs2/dlm/dlmmaster.c:1013: lock: Locking "mle->spinlock".
fs/ocfs2/dlm/dlmmaster.c:1031: def: Assigning: "*blocked" = data that might be protected by the lock.
fs/ocfs2/dlm/dlmmaster.c:1033: unlock: Unlocking "mle->spinlock". "*blocked" might now be unreliable because other threads can now change the data that it depends on.
fs/ocfs2/dlm/dlmmaster.c:1011: unlock: Unlocking "res->spinlock". "*blocked" might now be unreliable because other threads can now change the data that it depends on.
fs/ocfs2/dlm/dlmmaster.c:1074: unlock: Unlocking "mle->spinlock". "*blocked" might now be unreliable because other threads can now change the data that it depends on.
fs/ocfs2/dlm/dlmmaster.c:1011: unlock: Unlocking "res->spinlock". "*blocked" might now be unreliable because other threads can now change the data that it depends on.
fs/ocfs2/dlm/dlmmaster.c:1074: unlock: Unlocking "mle->spinlock". "*blocked" might now be unreliable because other threads can now change the data that it depends on.
fs/ocfs2/dlm/dlmmaster.c:1011: unlock: Unlocking "res->spinlock". "*blocked" might now be unreliable because other threads can now change the data that it depends on.
fs/ocfs2/dlm/dlmmaster.c:1074: unlock: Unlocking "mle->spinlock". "*blocked" might now be unreliable because other threads can now change the data that it depends on.
fs/ocfs2/dlm/dlmmaster.c:1011: unlock: Unlocking "res->spinlock". "*blocked" might now be unreliable because other threads can now change the data that it depends on.
fs/ocfs2/dlm/dlmmaster.c:1013: lockagain: Locking "mle->spinlock" again.
fs/ocfs2/dlm/dlmmaster.c:1025: use: Using an unreliable value of "*blocked" inside the second locked section.  If the data that "*blocked" depends on was changed by another thread, this use might be incorrect.

Error: ATOMICITY:
fs/ocfs2/dlm/dlmmaster.c:1013: lock: Locking "mle->spinlock".
fs/ocfs2/dlm/dlmmaster.c:1031: def: Assigning: "*blocked" = data that might be protected by the lock.
fs/ocfs2/dlm/dlmmaster.c:1033: unlock: Unlocking "mle->spinlock". "*blocked" might now be unreliable because other threads can now change the data that it depends on.
fs/ocfs2/dlm/dlmmaster.c:1011: unlock: Unlocking "res->spinlock". "*blocked" might now be unreliable because other threads can now change the data that it depends on.
fs/ocfs2/dlm/dlmmaster.c:1074: unlock: Unlocking "mle->spinlock". "*blocked" might now be unreliable because other threads can now change the data that it depends on.
fs/ocfs2/dlm/dlmmaster.c:1011: unlock: Unlocking "res->spinlock". "*blocked" might now be unreliable because other threads can now change the data that it depends on.
fs/ocfs2/dlm/dlmmaster.c:1074: unlock: Unlocking "mle->spinlock". "*blocked" might now be unreliable because other threads can now change the data that it depends on.
fs/ocfs2/dlm/dlmmaster.c:1011: unlock: Unlocking "res->spinlock". "*blocked" might now be unreliable because other threads can now change the data that it depends on.
fs/ocfs2/dlm/dlmmaster.c:1074: unlock: Unlocking "mle->spinlock". "*blocked" might now be unreliable because other threads can now change the data that it depends on.
fs/ocfs2/dlm/dlmmaster.c:1011: unlock: Unlocking "res->spinlock". "*blocked" might now be unreliable because other threads can now change the data that it depends on.
fs/ocfs2/dlm/dlmmaster.c:1074: unlock: Unlocking "mle->spinlock". "*blocked" might now be unreliable because other threads can now change the data that it depends on.
fs/ocfs2/dlm/dlmmaster.c:1011: unlock: Unlocking "res->spinlock". "*blocked" might now be unreliable because other threads can now change the data that it depends on.
fs/ocfs2/dlm/dlmmaster.c:1013: lockagain: Locking "mle->spinlock" again.
fs/ocfs2/dlm/dlmmaster.c:1025: use: Using an unreliable value of "*blocked" inside the second locked section.  If the data that "*blocked" depends on was changed by another thread, this use might be incorrect.

Error: ATOMICITY:
fs/jbd2/commit.c:826: lock: Locking "journal->j_list_lock".
fs/jbd2/commit.c:831: def: Assigning: "jh" = data that might be protected by the lock.
fs/jbd2/commit.c:832: unlock: Unlocking "journal->j_list_lock". "jh" might now be unreliable because other threads can now change the data that it depends on.
fs/jbd2/commit.c:860: lockagain: Locking "journal->j_list_lock" again.
fs/jbd2/commit.c:865: use: Using an unreliable value of "jh" inside the second locked section.  If the data that "jh" depends on was changed by another thread, this use might be incorrect.

Error: ATOMICITY:
fs/jbd2/commit.c:860: lock: Locking "journal->j_list_lock".
fs/jbd2/commit.c:831: def: Assigning: "jh" = data that might be protected by the lock.
fs/jbd2/commit.c:832: unlock: Unlocking "journal->j_list_lock". "jh" might now be unreliable because other threads can now change the data that it depends on.
fs/jbd2/commit.c:860: lockagain: Locking "journal->j_list_lock" again.
fs/jbd2/commit.c:865: use: Using an unreliable value of "jh" inside the second locked section.  If the data that "jh" depends on was changed by another thread, this use might be incorrect.

Error: ATOMICITY:
fs/jbd2/commit.c:860: lock: Locking "journal->j_list_lock".
fs/jbd2/commit.c:831: def: Assigning: "jh" = data that might be protected by the lock.
fs/jbd2/commit.c:832: unlock: Unlocking "journal->j_list_lock". "jh" might now be unreliable because other threads can now change the data that it depends on.
fs/jbd2/commit.c:860: lockagain: Locking "journal->j_list_lock" again.
fs/jbd2/commit.c:889: use: Using an unreliable value of "jh" inside the second locked section.  If the data that "jh" depends on was changed by another thread, this use might be incorrect.

Error: ATOMICITY:
fs/jbd2/commit.c:860: lock: Locking "journal->j_list_lock".
fs/jbd2/commit.c:831: def: Assigning: "jh" = data that might be protected by the lock.
fs/jbd2/commit.c:832: unlock: Unlocking "journal->j_list_lock". "jh" might now be unreliable because other threads can now change the data that it depends on.
fs/jbd2/commit.c:860: lockagain: Locking "journal->j_list_lock" again.
fs/jbd2/commit.c:905: use: Using an unreliable value of "jh" inside the second locked section.  If the data that "jh" depends on was changed by another thread, this use might be incorrect.

Error: ATOMICITY:
fs/jbd/commit.c:436: lock: Locking "journal->j_list_lock".
fs/jbd/commit.c:441: def: Assigning: "bh" = data that might be protected by the lock.
fs/jbd/commit.c:444: unlock: Unlocking "journal->j_list_lock". "bh" might now be unreliable because other threads can now change the data that it depends on.
fs/jbd/commit.c:446: lockagain: Locking "journal->j_list_lock" again.
fs/jbd/commit.c:448: use: Using an unreliable value of "bh" inside the second locked section.  If the data that "bh" depends on was changed by another thread, this use might be incorrect.

Error: ATOMICITY:
fs/jbd/commit.c:463: lock: Locking "journal->j_list_lock".
fs/jbd/commit.c:441: def: Assigning: "bh" = data that might be protected by the lock.
fs/jbd/commit.c:444: unlock: Unlocking "journal->j_list_lock". "bh" might now be unreliable because other threads can now change the data that it depends on.
fs/jbd/commit.c:446: lockagain: Locking "journal->j_list_lock" again.
fs/jbd/commit.c:448: use: Using an unreliable value of "bh" inside the second locked section.  If the data that "bh" depends on was changed by another thread, this use might be incorrect.

Error: ATOMICITY:
fs/jbd/commit.c:463: lock: Locking "journal->j_list_lock".
fs/jbd/commit.c:441: def: Assigning: "bh" = data that might be protected by the lock.
fs/jbd/commit.c:450: unlock: Unlocking "journal->j_list_lock". "bh" might now be unreliable because other threads can now change the data that it depends on.
fs/jbd/commit.c:452: lockagain: Locking "journal->j_list_lock" again.
fs/jbd/commit.c:461: use: Using an unreliable value of "bh" inside the second locked section.  If the data that "bh" depends on was changed by another thread, this use might be incorrect.

Error: ATOMICITY:
fs/jbd/commit.c:798: lock: Locking "journal->j_list_lock".
fs/jbd/commit.c:803: def: Assigning: "jh" = data that might be protected by the lock.
fs/jbd/commit.c:804: unlock: Unlocking "journal->j_list_lock". "jh" might now be unreliable because other threads can now change the data that it depends on.
fs/jbd/commit.c:832: lockagain: Locking "journal->j_list_lock" again.
fs/jbd/commit.c:836: use: Using an unreliable value of "jh" inside the second locked section.  If the data that "jh" depends on was changed by another thread, this use might be incorrect.

Error: ATOMICITY:
fs/jbd/commit.c:832: lock: Locking "journal->j_list_lock".
fs/jbd/commit.c:803: def: Assigning: "jh" = data that might be protected by the lock.
fs/jbd/commit.c:804: unlock: Unlocking "journal->j_list_lock". "jh" might now be unreliable because other threads can now change the data that it depends on.
fs/jbd/commit.c:832: lockagain: Locking "journal->j_list_lock" again.
fs/jbd/commit.c:836: use: Using an unreliable value of "jh" inside the second locked section.  If the data that "jh" depends on was changed by another thread, this use might be incorrect.

Error: ATOMICITY:
fs/jbd/commit.c:832: lock: Locking "journal->j_list_lock".
fs/jbd/commit.c:803: def: Assigning: "jh" = data that might be protected by the lock.
fs/jbd/commit.c:804: unlock: Unlocking "journal->j_list_lock". "jh" might now be unreliable because other threads can now change the data that it depends on.
fs/jbd/commit.c:832: lockagain: Locking "journal->j_list_lock" again.
fs/jbd/commit.c:860: use: Using an unreliable value of "jh" inside the second locked section.  If the data that "jh" depends on was changed by another thread, this use might be incorrect.

Error: ATOMICITY:
fs/jbd/commit.c:832: lock: Locking "journal->j_list_lock".
fs/jbd/commit.c:803: def: Assigning: "jh" = data that might be protected by the lock.
fs/jbd/commit.c:804: unlock: Unlocking "journal->j_list_lock". "jh" might now be unreliable because other threads can now change the data that it depends on.
fs/jbd/commit.c:832: lockagain: Locking "journal->j_list_lock" again.
fs/jbd/commit.c:876: use: Using an unreliable value of "jh" inside the second locked section.  If the data that "jh" depends on was changed by another thread, this use might be incorrect.

Error: ATOMICITY:
drivers/scsi/scsi_lib.c:474: lock: Locking "*shost->host_lock".
drivers/scsi/scsi_lib.c:474: def: Assigning: "flags" = data that might be protected by the lock.
drivers/scsi/scsi_lib.c:480: unlock: Unlocking "*shost->host_lock". "flags" might now be unreliable because other threads can now change the data that it depends on.
drivers/scsi/scsi_lib.c:481: lockagain: Locking "*sdev->request_queue->queue_lock" again.
drivers/scsi/scsi_lib.c:483: use: Using an unreliable value of "flags" inside the second locked section.  If the data that "flags" depends on was changed by another thread, this use might be incorrect.

Error: ATOMICITY:
drivers/usb/core/hcd.c:591: lock: Locking "hcd_root_hub_lock".
drivers/usb/core/hcd.c:591: def: Assigning: "flags" = data that might be protected by the lock.
drivers/usb/core/hcd.c:600: unlock: Unlocking "hcd_root_hub_lock". "flags" might now be unreliable because other threads can now change the data that it depends on.
drivers/usb/core/hcd.c:602: lockagain: Locking "hcd_root_hub_lock" again.
drivers/usb/core/hcd.c:607: use: Using an unreliable value of "flags" inside the second locked section.  If the data that "flags" depends on was changed by another thread, this use might be incorrect.

Error: ATOMICITY:
fs/xfs/xfs_log_recover.c:3094: lock: Locking "mp->m_ail_lock".
fs/xfs/xfs_log_recover.c:3111: def: Assigning: "lip" = data that might be protected by the lock.
fs/xfs/xfs_log_recover.c:3115: unlock: Unlocking "mp->m_ail_lock". "lip" might now be unreliable because other threads can now change the data that it depends on.
fs/xfs/xfs_log_recover.c:3119: lockagain: Locking "mp->m_ail_lock" again.
fs/xfs/xfs_log_recover.c:3120: use: Using an unreliable value of "lip" inside the second locked section.  If the data that "lip" depends on was changed by another thread, this use might be incorrect.

Error: ATOMICITY:
drivers/infiniband/core/iwcm.c:550: lock: Locking "cm_id_priv->lock".
drivers/infiniband/core/iwcm.c:560: def: Assigning: "qp" = data that might be protected by the lock.
drivers/infiniband/core/iwcm.c:568: unlock: Unlocking "cm_id_priv->lock". "qp" might now be unreliable because other threads can now change the data that it depends on.
drivers/infiniband/core/iwcm.c:572: lockagain: Locking "cm_id_priv->lock" again.
drivers/infiniband/core/iwcm.c:574: use: Using an unreliable value of "qp" inside the second locked section.  If the data that "qp" depends on was changed by another thread, this use might be incorrect.

Error: ATOMICITY:
fs/aio.c:488: lock: Locking "fput_lock".
fs/aio.c:491: def: Assigning: "ctx" = data that might be protected by the lock.
fs/aio.c:494: unlock: Unlocking "fput_lock". "ctx" might now be unreliable because other threads can now change the data that it depends on.
fs/aio.c:500: lockagain: Locking "ctx->ctx_lock" again.
fs/aio.c:501: use: Using an unreliable value of "ctx" inside the second locked section.  If the data that "ctx" depends on was changed by another thread, this use might be incorrect.

Error: ATOMICITY:
fs/aio.c:488: lock: Locking "fput_lock".
fs/aio.c:490: def: Assigning: "req" = data that might be protected by the lock.
fs/aio.c:494: unlock: Unlocking "fput_lock". "req" might now be unreliable because other threads can now change the data that it depends on.
fs/aio.c:500: lockagain: Locking "ctx->ctx_lock" again.
fs/aio.c:501: use: Using an unreliable value of "req" inside the second locked section.  If the data that "req" depends on was changed by another thread, this use might be incorrect.

Error: ATOMICITY:
fs/ocfs2/dlm/dlmmaster.c:720: lock: Locking "dlm->spinlock".
fs/ocfs2/dlm/dlmmaster.c:721: def: Assigning: "tmpres" = data that might be protected by the lock.
fs/ocfs2/dlm/dlmmaster.c:731: unlock: Unlocking "tmpres->spinlock". "tmpres" might now be unreliable because other threads can now change the data that it depends on.
fs/ocfs2/dlm/dlmmaster.c:732: unlock: Unlocking "dlm->spinlock". "tmpres" might now be unreliable because other threads can now change the data that it depends on.
fs/ocfs2/dlm/dlmmaster.c:737: lockagain: Locking "tmpres->spinlock" again.
fs/ocfs2/dlm/dlmmaster.c:738: use: Using an unreliable value of "tmpres" inside the second locked section.  If the data that "tmpres" depends on was changed by another thread, this use might be incorrect.

Error: ATOMICITY:
fs/ntfs/file.c:130: lock: Locking "ni->size_lock".
fs/ntfs/file.c:131: def: Assigning: "old_init_size" = data that might be protected by the lock.
fs/ntfs/file.c:134: unlock: Unlocking "ni->size_lock". "old_init_size" might now be unreliable because other threads can now change the data that it depends on.
fs/ntfs/file.c:323: lockagain: Locking "ni->size_lock" again.
fs/ntfs/file.c:324: use: Using an unreliable value of "old_init_size" inside the second locked section.  If the data that "old_init_size" depends on was changed by another thread, this use might be incorrect.

Error: ATOMICITY:
fs/ntfs/file.c:130: lock: Locking "ni->size_lock".
fs/ntfs/file.c:131: def: Assigning: "old_init_size" = data that might be protected by the lock.
fs/ntfs/file.c:134: unlock: Unlocking "ni->size_lock". "old_init_size" might now be unreliable because other threads can now change the data that it depends on.
fs/ntfs/file.c:252: unlock: Unlocking "ni->size_lock". "old_init_size" might now be unreliable because other threads can now change the data that it depends on.
fs/ntfs/file.c:323: lockagain: Locking "ni->size_lock" again.
fs/ntfs/file.c:324: use: Using an unreliable value of "old_init_size" inside the second locked section.  If the data that "old_init_size" depends on was changed by another thread, this use might be incorrect.

Error: ATOMICITY:
drivers/block/cciss_scsi.c:1046: lock: Locking "hba[c->ctlr]->lock".
drivers/block/cciss_scsi.c:1047: def: Assigning: "cp" = data that might be protected by the lock.
drivers/block/cciss_scsi.c:1048: unlock: Unlocking "hba[c->ctlr]->lock". "cp" might now be unreliable because other threads can now change the data that it depends on.
drivers/block/cciss_scsi.c:1073: lockagain: Locking "hba[c->ctlr]->lock" again.
drivers/block/cciss_scsi.c:1074: use: Using an unreliable value of "cp" inside the second locked section.  If the data that "cp" depends on was changed by another thread, this use might be incorrect.

Error: ATOMICITY:
drivers/md/raid5.c:1835: lock: Locking "conf->device_lock".
drivers/md/raid5.c:1892: def: Assigning: "*return_bi" = data that might be protected by the lock.
drivers/md/raid5.c:1897: unlock: Unlocking "conf->device_lock". "*return_bi" might now be unreliable because other threads can now change the data that it depends on.
drivers/md/raid5.c:1835: lockagain: Locking "conf->device_lock" again.
drivers/md/raid5.c:1853: use: Using an unreliable value of "*return_bi" inside the second locked section.  If the data that "*return_bi" depends on was changed by another thread, this use might be incorrect.

Error: ATOMICITY:
drivers/md/raid5.c:1835: lock: Locking "conf->device_lock".
drivers/md/raid5.c:1892: def: Assigning: "*return_bi" = data that might be protected by the lock.
drivers/md/raid5.c:1897: unlock: Unlocking "conf->device_lock". "*return_bi" might now be unreliable because other threads can now change the data that it depends on.
drivers/md/raid5.c:1835: lockagain: Locking "conf->device_lock" again.
drivers/md/raid5.c:1868: use: Using an unreliable value of "*return_bi" inside the second locked section.  If the data that "*return_bi" depends on was changed by another thread, this use might be incorrect.

Error: ATOMICITY:
drivers/md/raid5.c:1835: lock: Locking "conf->device_lock".
drivers/md/raid5.c:1892: def: Assigning: "*return_bi" = data that might be protected by the lock.
drivers/md/raid5.c:1897: unlock: Unlocking "conf->device_lock". "*return_bi" might now be unreliable because other threads can now change the data that it depends on.
drivers/md/raid5.c:1835: lockagain: Locking "conf->device_lock" again.
drivers/md/raid5.c:1891: use: Using an unreliable value of "*return_bi" inside the second locked section.  If the data that "*return_bi" depends on was changed by another thread, this use might be incorrect.

Error: ATOMICITY:
drivers/md/raid5.c:1835: lock: Locking "conf->device_lock".
drivers/md/raid5.c:1881: def: Assigning: "sh->dev[i].toread" = data that might be protected by the lock.
drivers/md/raid5.c:1897: unlock: Unlocking "conf->device_lock". "sh->dev[i].toread" might now be unreliable because other threads can now change the data that it depends on.
drivers/md/raid5.c:1835: lockagain: Locking "conf->device_lock" again.
drivers/md/raid5.c:1880: use: Using an unreliable value of "sh->dev[i].toread" inside the second locked section.  If the data that "sh->dev[i].toread" depends on was changed by another thread, this use might be incorrect.

Error: ATOMICITY:
drivers/md/raid5.c:1835: lock: Locking "conf->device_lock".
drivers/md/raid5.c:1838: def: Assigning: "sh->dev[i].towrite" = data that might be protected by the lock.
drivers/md/raid5.c:1897: unlock: Unlocking "conf->device_lock". "sh->dev[i].towrite" might now be unreliable because other threads can now change the data that it depends on.
drivers/md/raid5.c:1835: lockagain: Locking "conf->device_lock" again.
drivers/md/raid5.c:1837: use: Using an unreliable value of "sh->dev[i].towrite" inside the second locked section.  If the data that "sh->dev[i].towrite" depends on was changed by another thread, this use might be incorrect.

Error: ATOMICITY:
drivers/md/raid5.c:1835: lock: Locking "conf->device_lock".
drivers/md/raid5.c:1860: def: Assigning: "sh->dev[i].written" = data that might be protected by the lock.
drivers/md/raid5.c:1897: unlock: Unlocking "conf->device_lock". "sh->dev[i].written" might now be unreliable because other threads can now change the data that it depends on.
drivers/md/raid5.c:1835: lockagain: Locking "conf->device_lock" again.
drivers/md/raid5.c:1859: use: Using an unreliable value of "sh->dev[i].written" inside the second locked section.  If the data that "sh->dev[i].written" depends on was changed by another thread, this use might be incorrect.

Error: ATOMICITY:
drivers/md/raid5.c:2059: lock: Locking "conf->device_lock".
drivers/md/raid5.c:2068: def: Assigning: "*return_bi" = data that might be protected by the lock.
drivers/md/raid5.c:2074: unlock: Unlocking "conf->device_lock". "*return_bi" might now be unreliable because other threads can now change the data that it depends on.
drivers/md/raid5.c:2059: lockagain: Locking "conf->device_lock" again.
drivers/md/raid5.c:2067: use: Using an unreliable value of "*return_bi" inside the second locked section.  If the data that "*return_bi" depends on was changed by another thread, this use might be incorrect.

Error: ATOMICITY:
fs/jbd2/journal.c:1749: lock: Locking "journal->j_state_lock".
fs/jbd2/journal.c:1750: def: Assigning: "old_tail" = data that might be protected by the lock.
fs/jbd2/journal.c:1752: unlock: Unlocking "journal->j_state_lock". "old_tail" might now be unreliable because other threads can now change the data that it depends on.
fs/jbd2/journal.c:1754: lockagain: Locking "journal->j_state_lock" again.
fs/jbd2/journal.c:1755: use: Using an unreliable value of "old_tail" inside the second locked section.  If the data that "old_tail" depends on was changed by another thread, this use might be incorrect.

Error: ATOMICITY:
drivers/md/md.c:1710: lock: Locking "mddev->write_lock".
drivers/md/md.c:1733: def: Assigning: "nospares" = data that might be protected by the lock.
drivers/md/md.c:1786: unlock: Unlocking "mddev->write_lock". "nospares" might now be unreliable because other threads can now change the data that it depends on.
drivers/md/md.c:1824: unlock: Unlocking "mddev->write_lock". "nospares" might now be unreliable because other threads can now change the data that it depends on.
drivers/md/md.c:1710: lockagain: Locking "mddev->write_lock" again.
drivers/md/md.c:1785: use: Using an unreliable value of "nospares" inside the second locked section.  If the data that "nospares" depends on was changed by another thread, this use might be incorrect.

Error: ATOMICITY:
fs/jbd/journal.c:1389: lock: Locking "journal->j_state_lock".
fs/jbd/journal.c:1390: def: Assigning: "old_tail" = data that might be protected by the lock.
fs/jbd/journal.c:1392: unlock: Unlocking "journal->j_state_lock". "old_tail" might now be unreliable because other threads can now change the data that it depends on.
fs/jbd/journal.c:1394: lockagain: Locking "journal->j_state_lock" again.
fs/jbd/journal.c:1395: use: Using an unreliable value of "old_tail" inside the second locked section.  If the data that "old_tail" depends on was changed by another thread, this use might be incorrect.

Error: ATOMICITY:
fs/ocfs2/dlmglue.c:3138: lock: Locking "lockres->l_lock".
fs/ocfs2/dlmglue.c:3201: def: Assigning: "new_level" = data that might be protected by the lock.
fs/ocfs2/dlmglue.c:3218: unlock: Unlocking "lockres->l_lock". "new_level" might now be unreliable because other threads can now change the data that it depends on.
fs/ocfs2/dlmglue.c:3225: lockagain: Locking "lockres->l_lock" again.
fs/ocfs2/dlmglue.c:3249: use: Using an unreliable value of "new_level" inside the second locked section.  If the data that "new_level" depends on was changed by another thread, this use might be incorrect.

Error: ATOMICITY:
drivers/acpi/sleep/wakeup.c:33: lock: Locking "acpi_device_lock".
drivers/acpi/sleep/wakeup.c:34: def: Assigning: "next" = data that might be protected by the lock.
drivers/acpi/sleep/wakeup.c:44: unlock: Unlocking "acpi_device_lock". "next" might now be unreliable because other threads can now change the data that it depends on.
drivers/acpi/sleep/wakeup.c:46: lockagain: Locking "acpi_device_lock" again.
drivers/acpi/sleep/wakeup.c:34: use: Using an unreliable value of "next" inside the second locked section.  If the data that "next" depends on was changed by another thread, this use might be incorrect.

Error: ATOMICITY:
drivers/mtd/chips/cfi_cmdset_0001.c:1192: lock: Locking "*chip->mutex".
drivers/mtd/chips/cfi_cmdset_0001.c:1197: def: Assigning: "reset_timeo" = data that might be protected by the lock.
drivers/mtd/chips/cfi_cmdset_0001.c:1212: unlock: Unlocking "*chip->mutex". "reset_timeo" might now be unreliable because other threads can now change the data that it depends on.
drivers/mtd/chips/cfi_cmdset_0001.c:1234: unlock: Unlocking "*chip->mutex". "reset_timeo" might now be unreliable because other threads can now change the data that it depends on.
drivers/mtd/chips/cfi_cmdset_0001.c:1237: lockagain: Locking "*chip->mutex" again.
drivers/mtd/chips/cfi_cmdset_0001.c:1241: use: Using an unreliable value of "reset_timeo" inside the second locked section.  If the data that "reset_timeo" depends on was changed by another thread, this use might be incorrect.

Error: ATOMICITY:
drivers/block/cciss_scsi.c:1109: lock: Locking "hba[c->ctlr]->lock".
drivers/block/cciss_scsi.c:1110: def: Assigning: "cp" = data that might be protected by the lock.
drivers/block/cciss_scsi.c:1111: unlock: Unlocking "hba[c->ctlr]->lock". "cp" might now be unreliable because other threads can now change the data that it depends on.
drivers/block/cciss_scsi.c:1144: lockagain: Locking "hba[c->ctlr]->lock" again.
drivers/block/cciss_scsi.c:1145: use: Using an unreliable value of "cp" inside the second locked section.  If the data that "cp" depends on was changed by another thread, this use might be incorrect.

Error: ATOMICITY:
drivers/isdn/hardware/mISDN/hfcmulti.c:4407: lock: Locking "hc->lock".
drivers/isdn/hardware/mISDN/hfcmulti.c:4428: def: Assigning: "hc->chan[i].bch" = data that might be protected by the lock.
drivers/isdn/hardware/mISDN/hfcmulti.c:4429: unlock: Unlocking "hc->lock". "hc->chan[i].bch" might now be unreliable because other threads can now change the data that it depends on.
drivers/isdn/hardware/mISDN/hfcmulti.c:4433: lockagain: Locking "hc->lock" again.
drivers/isdn/hardware/mISDN/hfcmulti.c:4427: use: Using an unreliable value of "hc->chan[i].bch" inside the second locked section.  If the data that "hc->chan[i].bch" depends on was changed by another thread, this use might be incorrect.

Error: ATOMICITY:
drivers/isdn/hardware/mISDN/hfcmulti.c:4407: lock: Locking "hc->lock".
drivers/isdn/hardware/mISDN/hfcmulti.c:4421: def: Assigning: "i" = data that might be protected by the lock.
drivers/isdn/hardware/mISDN/hfcmulti.c:4429: unlock: Unlocking "hc->lock". "i" might now be unreliable because other threads can now change the data that it depends on.
drivers/isdn/hardware/mISDN/hfcmulti.c:4433: lockagain: Locking "hc->lock" again.
drivers/isdn/hardware/mISDN/hfcmulti.c:4424: use: Using an unreliable value of "i" inside the second locked section.  If the data that "i" depends on was changed by another thread, this use might be incorrect.

Error: ATOMICITY:
fs/eventpoll.c:936: lock: Locking "ep->lock".
fs/eventpoll.c:939: def: Assigning: "ep->ovflist" = data that might be protected by the lock.
fs/eventpoll.c:940: unlock: Unlocking "ep->lock". "ep->ovflist" might now be unreliable because other threads can now change the data that it depends on.
fs/eventpoll.c:989: lockagain: Locking "ep->lock" again.
fs/eventpoll.c:995: use: Using an unreliable value of "ep->ovflist" inside the second locked section.  If the data that "ep->ovflist" depends on was changed by another thread, this use might be incorrect.

Error: ATOMICITY:
fs/xfs/xfs_fsops.c:528: lock: Locking "mp->m_sb_lock".
fs/xfs/xfs_fsops.c:542: def: Assigning: "mp->m_resblks" = data that might be protected by the lock.
fs/xfs/xfs_fsops.c:568: unlock: Unlocking "mp->m_sb_lock". "mp->m_resblks" might now be unreliable because other threads can now change the data that it depends on.
fs/xfs/xfs_fsops.c:528: lockagain: Locking "mp->m_sb_lock" again.
fs/xfs/xfs_fsops.c:565: use: Using an unreliable value of "mp->m_resblks" inside the second locked section.  If the data that "mp->m_resblks" depends on was changed by another thread, this use might be incorrect.

Error: ATOMICITY:
drivers/infiniband/ulp/ipoib/ipoib_main.c:380: lock: Locking "priv->lock".
drivers/infiniband/ulp/ipoib/ipoib_main.c:387: def: Assigning: "tp" = data that might be protected by the lock.
drivers/infiniband/ulp/ipoib/ipoib_main.c:390: unlock: Unlocking "priv->lock". "tp" might now be unreliable because other threads can now change the data that it depends on.
drivers/infiniband/ulp/ipoib/ipoib_main.c:391: unlock: Unlocking "dev->tx_global_lock". "tp" might now be unreliable because other threads can now change the data that it depends on.
drivers/infiniband/ulp/ipoib/ipoib_main.c:395: lockagain: Locking "priv->lock" again.
drivers/infiniband/ulp/ipoib/ipoib_main.c:387: use: Using an unreliable value of "tp" inside the second locked section.  If the data that "tp" depends on was changed by another thread, this use might be incorrect.

Error: ATOMICITY:
drivers/infiniband/ulp/ipoib/ipoib_main.c:395: lock: Locking "priv->lock".
drivers/infiniband/ulp/ipoib/ipoib_main.c:387: def: Assigning: "tp" = data that might be protected by the lock.
drivers/infiniband/ulp/ipoib/ipoib_main.c:390: unlock: Unlocking "priv->lock". "tp" might now be unreliable because other threads can now change the data that it depends on.
drivers/infiniband/ulp/ipoib/ipoib_main.c:391: unlock: Unlocking "dev->tx_global_lock". "tp" might now be unreliable because other threads can now change the data that it depends on.
drivers/infiniband/ulp/ipoib/ipoib_main.c:395: lockagain: Locking "priv->lock" again.
drivers/infiniband/ulp/ipoib/ipoib_main.c:387: use: Using an unreliable value of "tp" inside the second locked section.  If the data that "tp" depends on was changed by another thread, this use might be incorrect.

Error: ATOMICITY:
kernel/irq/autoprobe.c:127: lock: Locking "desc->lock".
kernel/irq/autoprobe.c:134: def: Assigning: "desc->status" = data that might be protected by the lock.
kernel/irq/autoprobe.c:137: unlock: Unlocking "desc->lock". "desc->status" might now be unreliable because other threads can now change the data that it depends on.
kernel/irq/autoprobe.c:127: lockagain: Locking "desc->lock" again.
kernel/irq/autoprobe.c:128: use: Using an unreliable value of "desc->status" inside the second locked section.  If the data that "desc->status" depends on was changed by another thread, this use might be incorrect.

Error: ATOMICITY:
fs/autofs4/expire.c:160: lock: Locking "dcache_lock".
fs/autofs4/expire.c:169: def: Assigning: "p" = data that might be protected by the lock.
fs/autofs4/expire.c:170: unlock: Unlocking "dcache_lock". "p" might now be unreliable because other threads can now change the data that it depends on.
fs/autofs4/expire.c:207: lockagain: Locking "dcache_lock" again.
fs/autofs4/expire.c:161: use: Using an unreliable value of "p" inside the second locked section.  If the data that "p" depends on was changed by another thread, this use might be incorrect.

Error: ATOMICITY:
fs/autofs4/expire.c:228: lock: Locking "dcache_lock".
fs/autofs4/expire.c:237: def: Assigning: "p" = data that might be protected by the lock.
fs/autofs4/expire.c:238: unlock: Unlocking "dcache_lock". "p" might now be unreliable because other threads can now change the data that it depends on.
fs/autofs4/expire.c:251: lockagain: Locking "dcache_lock" again.
fs/autofs4/expire.c:229: use: Using an unreliable value of "p" inside the second locked section.  If the data that "p" depends on was changed by another thread, this use might be incorrect.

Error: ATOMICITY:
drivers/isdn/i4l/isdn_net.h:79: lock: Locking "nd->queue_lock".
drivers/isdn/i4l/isdn_net.h:79: def: Assigning: "flags" = data that might be protected by the lock.
drivers/isdn/i4l/isdn_net.h:83: unlock: Unlocking "nd->queue->xmit_lock". "flags" might now be unreliable because other threads can now change the data that it depends on.
drivers/isdn/i4l/isdn_net.h:89: lockagain: Locking "nd->queue->xmit_lock" again.
drivers/isdn/i4l/isdn_net.h:95: use: Using an unreliable value of "flags" inside the second locked section.  If the data that "flags" depends on was changed by another thread, this use might be incorrect.

Error: ATOMICITY:
fs/ocfs2/dlm/dlmdomain.c:582: lock: Locking "dlm->spinlock".
fs/ocfs2/dlm/dlmdomain.c:585: def: Assigning: "node" = data that might be protected by the lock.
fs/ocfs2/dlm/dlmdomain.c:593: unlock: Unlocking "dlm->spinlock". "node" might now be unreliable because other threads can now change the data that it depends on.
fs/ocfs2/dlm/dlmdomain.c:611: lockagain: Locking "dlm->spinlock" again.
fs/ocfs2/dlm/dlmdomain.c:615: use: Using an unreliable value of "node" inside the second locked section.  If the data that "node" depends on was changed by another thread, this use might be incorrect.

Error: ATOMICITY:
fs/ocfs2/dlm/dlmmaster.c:3169: lock: Locking "dlm->master_lock".
fs/ocfs2/dlm/dlmmaster.c:3170: def: Assigning: "mle" = data that might be protected by the lock.
fs/ocfs2/dlm/dlmmaster.c:3237: unlock: Unlocking "mle->spinlock". "mle" might now be unreliable because other threads can now change the data that it depends on.
fs/ocfs2/dlm/dlmmaster.c:3254: unlock: Unlocking "dlm->master_lock". "mle" might now be unreliable because other threads can now change the data that it depends on.
fs/ocfs2/dlm/dlmmaster.c:3261: unlock: Unlocking "res->spinlock". "mle" might now be unreliable because other threads can now change the data that it depends on.
fs/ocfs2/dlm/dlmmaster.c:3268: lockagain: Locking "dlm->master_lock" again.
fs/ocfs2/dlm/dlmmaster.c:3269: use: Using an unreliable value of "mle" inside the second locked section.  If the data that "mle" depends on was changed by another thread, this use might be incorrect.

Error: ATOMICITY:
drivers/mtd/ubi/vmt.c:536: lock: Locking "ubi->volumes_lock".
drivers/mtd/ubi/vmt.c:549: def: Assigning: "vol->eba_tbl" = data that might be protected by the lock.
drivers/mtd/ubi/vmt.c:550: unlock: Unlocking "ubi->volumes_lock". "vol->eba_tbl" might now be unreliable because other threads can now change the data that it depends on.
drivers/mtd/ubi/vmt.c:566: lockagain: Locking "ubi->volumes_lock" again.
drivers/mtd/ubi/vmt.c:580: use: Using an unreliable value of "vol->eba_tbl" inside the second locked section.  If the data that "vol->eba_tbl" depends on was changed by another thread, this use might be incorrect.

Error: ATOMICITY:
drivers/md/bitmap.c:1101: lock: Locking "bitmap->lock".
drivers/md/bitmap.c:1108: def: Assigning: "page" = data that might be protected by the lock.
drivers/md/bitmap.c:1130: unlock: Unlocking "bitmap->lock". "page" might now be unreliable because other threads can now change the data that it depends on.
drivers/md/bitmap.c:1152: lockagain: Locking "bitmap->lock" again.
drivers/md/bitmap.c:1153: use: Using an unreliable value of "page" inside the second locked section.  If the data that "page" depends on was changed by another thread, this use might be incorrect.

Error: ATOMICITY:
drivers/md/raid5.c:2836: lock: Locking "conf->device_lock".
drivers/md/raid5.c:2837: def: Assigning: "rbi" = data that might be protected by the lock.
drivers/md/raid5.c:2841: unlock: Unlocking "conf->device_lock". "rbi" might now be unreliable because other threads can now change the data that it depends on.
drivers/md/raid5.c:2845: lockagain: Locking "conf->device_lock" again.
drivers/md/raid5.c:2846: use: Using an unreliable value of "rbi" inside the second locked section.  If the data that "rbi" depends on was changed by another thread, this use might be incorrect.

Error: ATOMICITY:
drivers/md/raid5.c:2845: lock: Locking "conf->device_lock".
drivers/md/raid5.c:2848: def: Assigning: "return_bi" = data that might be protected by the lock.
drivers/md/raid5.c:2850: unlock: Unlocking "conf->device_lock". "return_bi" might now be unreliable because other threads can now change the data that it depends on.
drivers/md/raid5.c:2845: lockagain: Locking "conf->device_lock" again.
drivers/md/raid5.c:2847: use: Using an unreliable value of "return_bi" inside the second locked section.  If the data that "return_bi" depends on was changed by another thread, this use might be incorrect.

Error: ATOMICITY:
drivers/mtd/chips/cfi_cmdset_0001.c:860: lock: Locking "shared->lock".
drivers/mtd/chips/cfi_cmdset_0001.c:861: def: Assigning: "contender" = data that might be protected by the lock.
drivers/mtd/chips/cfi_cmdset_0001.c:873: unlock: Unlocking "shared->lock". "contender" might now be unreliable because other threads can now change the data that it depends on.
drivers/mtd/chips/cfi_cmdset_0001.c:876: unlock: Unlocking "*chip->mutex". "contender" might now be unreliable because other threads can now change the data that it depends on.
drivers/mtd/chips/cfi_cmdset_0001.c:888: lockagain: Locking "shared->lock" again.
drivers/mtd/chips/cfi_cmdset_0001.c:893: use: Using an unreliable value of "contender" inside the second locked section.  If the data that "contender" depends on was changed by another thread, this use might be incorrect.

Error: ATOMICITY:
drivers/ata/libata-pmp.c:769: lock: Locking "*ap->lock".
drivers/ata/libata-pmp.c:771: def: Assigning: "link" = data that might be protected by the lock.
drivers/ata/libata-pmp.c:775: unlock: Unlocking "*ap->lock". "link" might now be unreliable because other threads can now change the data that it depends on.
drivers/ata/libata-pmp.c:792: lockagain: Locking "*ap->lock" again.
drivers/ata/libata-pmp.c:771: use: Using an unreliable value of "link" inside the second locked section.  If the data that "link" depends on was changed by another thread, this use might be incorrect.

Error: ATOMICITY:
drivers/char/rio/riocmd.c:666: lock: Locking "UnixRupP->RupLock".
drivers/char/rio/riocmd.c:728: def: Assigning: "CmdBlkP" = data that might be protected by the lock.
drivers/char/rio/riocmd.c:746: unlock: Unlocking "UnixRupP->RupLock". "CmdBlkP" might now be unreliable because other threads can now change the data that it depends on.
drivers/char/rio/riocmd.c:748: lockagain: Locking "UnixRupP->RupLock" again.
drivers/char/rio/riocmd.c:759: use: Using an unreliable value of "CmdBlkP" inside the second locked section.  If the data that "CmdBlkP" depends on was changed by another thread, this use might be incorrect.

Error: ATOMICITY:
drivers/char/rio/riocmd.c:666: lock: Locking "UnixRupP->RupLock".
drivers/char/rio/riocmd.c:674: def: Assigning: "PacketP" = data that might be protected by the lock.
drivers/char/rio/riocmd.c:679: unlock: Unlocking "UnixRupP->RupLock". "PacketP" might now be unreliable because other threads can now change the data that it depends on.
drivers/char/rio/riocmd.c:681: lockagain: Locking "UnixRupP->RupLock" again.
drivers/char/rio/riocmd.c:713: use: Using an unreliable value of "PacketP" inside the second locked section.  If the data that "PacketP" depends on was changed by another thread, this use might be incorrect.

Error: ATOMICITY:
drivers/char/rio/riocmd.c:666: lock: Locking "UnixRupP->RupLock".
drivers/char/rio/riocmd.c:674: def: Assigning: "PacketP" = data that might be protected by the lock.
drivers/char/rio/riocmd.c:690: unlock: Unlocking "UnixRupP->RupLock". "PacketP" might now be unreliable because other threads can now change the data that it depends on.
drivers/char/rio/riocmd.c:696: lockagain: Locking "UnixRupP->RupLock" again.
drivers/char/rio/riocmd.c:713: use: Using an unreliable value of "PacketP" inside the second locked section.  If the data that "PacketP" depends on was changed by another thread, this use might be incorrect.

Error: ATOMICITY:
drivers/char/rio/riocmd.c:666: lock: Locking "UnixRupP->RupLock".
drivers/char/rio/riocmd.c:674: def: Assigning: "PacketP" = data that might be protected by the lock.
drivers/char/rio/riocmd.c:700: unlock: Unlocking "UnixRupP->RupLock". "PacketP" might now be unreliable because other threads can now change the data that it depends on.
drivers/char/rio/riocmd.c:702: lockagain: Locking "UnixRupP->RupLock" again.
drivers/char/rio/riocmd.c:713: use: Using an unreliable value of "PacketP" inside the second locked section.  If the data that "PacketP" depends on was changed by another thread, this use might be incorrect.

Error: ATOMICITY:
drivers/char/rio/riocmd.c:681: lock: Locking "UnixRupP->RupLock".
drivers/char/rio/riocmd.c:728: def: Assigning: "CmdBlkP" = data that might be protected by the lock.
drivers/char/rio/riocmd.c:746: unlock: Unlocking "UnixRupP->RupLock". "CmdBlkP" might now be unreliable because other threads can now change the data that it depends on.
drivers/char/rio/riocmd.c:748: lockagain: Locking "UnixRupP->RupLock" again.
drivers/char/rio/riocmd.c:759: use: Using an unreliable value of "CmdBlkP" inside the second locked section.  If the data that "CmdBlkP" depends on was changed by another thread, this use might be incorrect.

Error: ATOMICITY:
mm/shmem.c:843: lock: Locking "info->lock".
mm/shmem.c:861: def: Assigning: "idx" = data that might be protected by the lock.
mm/shmem.c:907: unlock: Unlocking "info->lock". "idx" might now be unreliable because other threads can now change the data that it depends on.
mm/shmem.c:934: lockagain: Locking "info->lock" again.
mm/shmem.c:935: use: Using an unreliable value of "idx" inside the second locked section.  If the data that "idx" depends on was changed by another thread, this use might be incorrect.

Error: ATOMICITY:
drivers/usb/wusbcore/wa-xfer.c:849: lock: Locking "rpipe->seg_lock".
drivers/usb/wusbcore/wa-xfer.c:855: def: Assigning: "xfer" = data that might be protected by the lock.
drivers/usb/wusbcore/wa-xfer.c:862: unlock: Unlocking "rpipe->seg_lock". "xfer" might now be unreliable because other threads can now change the data that it depends on.
drivers/usb/wusbcore/wa-xfer.c:863: lockagain: Locking "xfer->lock" again.
drivers/usb/wusbcore/wa-xfer.c:864: use: Using an unreliable value of "xfer" inside the second locked section.  If the data that "xfer" depends on was changed by another thread, this use might be incorrect.

Error: ATOMICITY:
drivers/infiniband/core/iwcm.c:493: lock: Locking "cm_id_priv->lock".
drivers/infiniband/core/iwcm.c:501: def: Assigning: "qp" = data that might be protected by the lock.
drivers/infiniband/core/iwcm.c:508: unlock: Unlocking "cm_id_priv->lock". "qp" might now be unreliable because other threads can now change the data that it depends on.
drivers/infiniband/core/iwcm.c:515: lockagain: Locking "cm_id_priv->lock" again.
drivers/infiniband/core/iwcm.c:517: use: Using an unreliable value of "qp" inside the second locked section.  If the data that "qp" depends on was changed by another thread, this use might be incorrect.

Error: ATOMICITY:
fs/ocfs2/dlm/dlmthread.c:163: lock: Locking "res->spinlock".
fs/ocfs2/dlm/dlmthread.c:170: def: Assigning: "master" = data that might be protected by the lock.
fs/ocfs2/dlm/dlmthread.c:173: unlock: Unlocking "res->spinlock". "master" might now be unreliable because other threads can now change the data that it depends on.
fs/ocfs2/dlm/dlmthread.c:180: unlock: Unlocking "dlm->spinlock". "master" might now be unreliable because other threads can now change the data that it depends on.
fs/ocfs2/dlm/dlmthread.c:185: unlock: Unlocking "res->spinlock". "master" might now be unreliable because other threads can now change the data that it depends on.
fs/ocfs2/dlm/dlmthread.c:196: lockagain: Locking "dlm->spinlock" again.
fs/ocfs2/dlm/dlmthread.c:200: use: Using an unreliable value of "master" inside the second locked section.  If the data that "master" depends on was changed by another thread, this use might be incorrect.

Error: ATOMICITY:
drivers/infiniband/hw/nes/nes_verbs.c:2889: lock: Locking "nesqp->lock".
drivers/infiniband/hw/nes/nes_verbs.c:3067: def: Assigning: "original_last_aeq" = data that might be protected by the lock.
drivers/infiniband/hw/nes/nes_verbs.c:3068: unlock: Unlocking "nesqp->lock". "original_last_aeq" might now be unreliable because other threads can now change the data that it depends on.
drivers/infiniband/hw/nes/nes_verbs.c:3110: lockagain: Locking "nesqp->lock" again.
drivers/infiniband/hw/nes/nes_verbs.c:3115: use: Using an unreliable value of "original_last_aeq" inside the second locked section.  If the data that "original_last_aeq" depends on was changed by another thread, this use might be incorrect.

Error: ATOMICITY:
drivers/block/sx8.c:558: lock: Locking "host->lock".
drivers/block/sx8.c:559: def: Assigning: "crq" = data that might be protected by the lock.
drivers/block/sx8.c:560: unlock: Unlocking "host->lock". "crq" might now be unreliable because other threads can now change the data that it depends on.
drivers/block/sx8.c:572: lockagain: Locking "host->lock" again.
drivers/block/sx8.c:573: use: Using an unreliable value of "crq" inside the second locked section.  If the data that "crq" depends on was changed by another thread, this use might be incorrect.

Error: ATOMICITY:
drivers/char/rio/riotable.c:472: lock: Locking "HostP->HostLock".
drivers/char/rio/riotable.c:502: def: Assigning: "port" = data that might be protected by the lock.
drivers/char/rio/riotable.c:554: unlock: Unlocking "PortP->portSem". "port" might now be unreliable because other threads can now change the data that it depends on.
drivers/char/rio/riotable.c:506: lockagain: Locking "PortP->portSem" again.
drivers/char/rio/riotable.c:551: use: Using an unreliable value of "port" inside the second locked section.  If the data that "port" depends on was changed by another thread, this use might be incorrect.

Error: ATOMICITY:
fs/autofs4/expire.c:317: lock: Locking "dcache_lock".
fs/autofs4/expire.c:331: def: Assigning: "dentry" = data that might be protected by the lock.
fs/autofs4/expire.c:332: unlock: Unlocking "dcache_lock". "dentry" might now be unreliable because other threads can now change the data that it depends on.
fs/autofs4/expire.c:334: lockagain: Locking "sbi->fs_lock" again.
fs/autofs4/expire.c:335: use: Using an unreliable value of "dentry" inside the second locked section.  If the data that "dentry" depends on was changed by another thread, this use might be incorrect.

Error: ATOMICITY:
fs/autofs4/expire.c:397: lock: Locking "dcache_lock".
fs/autofs4/expire.c:331: def: Assigning: "dentry" = data that might be protected by the lock.
fs/autofs4/expire.c:332: unlock: Unlocking "dcache_lock". "dentry" might now be unreliable because other threads can now change the data that it depends on.
fs/autofs4/expire.c:334: lockagain: Locking "sbi->fs_lock" again.
fs/autofs4/expire.c:335: use: Using an unreliable value of "dentry" inside the second locked section.  If the data that "dentry" depends on was changed by another thread, this use might be incorrect.

Error: ATOMICITY:
drivers/gpio/gpiolib.c:770: lock: Locking "gpio_lock".
drivers/gpio/gpiolib.c:774: def: Assigning: "desc" = data that might be protected by the lock.
drivers/gpio/gpiolib.c:796: unlock: Unlocking "gpio_lock". "desc" might now be unreliable because other threads can now change the data that it depends on.
drivers/gpio/gpiolib.c:798: lockagain: Locking "gpio_lock" again.
drivers/gpio/gpiolib.c:801: use: Using an unreliable value of "desc" inside the second locked section.  If the data that "desc" depends on was changed by another thread, this use might be incorrect.

Error: ATOMICITY:
drivers/char/synclinkmp.c:3114: lock: Locking "info->lock".
drivers/char/synclinkmp.c:3141: def: Assigning: "info->ie1_value" = data that might be protected by the lock.
drivers/char/synclinkmp.c:3149: unlock: Unlocking "info->lock". "info->ie1_value" might now be unreliable because other threads can now change the data that it depends on.
drivers/char/synclinkmp.c:3203: lockagain: Locking "info->lock" again.
drivers/char/synclinkmp.c:3207: use: Using an unreliable value of "info->ie1_value" inside the second locked section.  If the data that "info->ie1_value" depends on was changed by another thread, this use might be incorrect.

Error: ATOMICITY:
drivers/char/synclinkmp.c:3114: lock: Locking "info->lock".
drivers/char/synclinkmp.c:3141: def: Assigning: "info->ie1_value" = data that might be protected by the lock.
drivers/char/synclinkmp.c:3149: unlock: Unlocking "info->lock". "info->ie1_value" might now be unreliable because other threads can now change the data that it depends on.
drivers/char/synclinkmp.c:3163: unlock: Unlocking "info->lock". "info->ie1_value" might now be unreliable because other threads can now change the data that it depends on.
drivers/char/synclinkmp.c:3203: lockagain: Locking "info->lock" again.
drivers/char/synclinkmp.c:3207: use: Using an unreliable value of "info->ie1_value" inside the second locked section.  If the data that "info->ie1_value" depends on was changed by another thread, this use might be incorrect.

Error: ATOMICITY:
drivers/usb/serial/digi_acceleport.c:710: lock: Locking "priv->dp_port_lock".
drivers/usb/serial/digi_acceleport.c:738: def: Assigning: "priv->dp_out_buf_len" = data that might be protected by the lock.
drivers/usb/serial/digi_acceleport.c:705: unlock: Unlocking "priv->dp_port_lock". "priv->dp_out_buf_len" might now be unreliable because other threads can now change the data that it depends on.
drivers/usb/serial/digi_acceleport.c:710: lockagain: Locking "priv->dp_port_lock" again.
drivers/usb/serial/digi_acceleport.c:723: use: Using an unreliable value of "priv->dp_out_buf_len" inside the second locked section.  If the data that "priv->dp_out_buf_len" depends on was changed by another thread, this use might be incorrect.

Error: ATOMICITY:
drivers/scsi/aacraid/commsup.c:1247: lock: Locking "dev->list_lock".
drivers/scsi/aacraid/commsup.c:1251: def: Assigning: "command_list" = data that might be protected by the lock.
drivers/scsi/aacraid/commsup.c:1253: unlock: Unlocking "dev->list_lock". "command_list" might now be unreliable because other threads can now change the data that it depends on.
drivers/scsi/aacraid/commsup.c:1247: lockagain: Locking "dev->list_lock" again.
drivers/scsi/aacraid/commsup.c:1250: use: Using an unreliable value of "(struct scatterlist *)command_list" inside the second locked section.  If the data that "(struct scatterlist *)command_list" depends on was changed by another thread, this use might be incorrect.

Error: ATOMICITY:
drivers/usb/host/ehci-sched.c:1172: lock: Locking "ehci->lock".
drivers/usb/host/ehci-sched.c:1184: def: Assigning: "itd_dma" = data that might be protected by the lock.
drivers/usb/host/ehci-sched.c:1186: unlock: Unlocking "ehci->lock". "itd_dma" might now be unreliable because other threads can now change the data that it depends on.
drivers/usb/host/ehci-sched.c:1189: lockagain: Locking "ehci->lock" again.
drivers/usb/host/ehci-sched.c:1198: use: Using an unreliable value of "itd_dma" inside the second locked section.  If the data that "itd_dma" depends on was changed by another thread, this use might be incorrect.

Error: ATOMICITY:
drivers/usb/host/ehci-sched.c:1807: lock: Locking "ehci->lock".
drivers/usb/host/ehci-sched.c:1824: def: Assigning: "sitd_dma" = data that might be protected by the lock.
drivers/usb/host/ehci-sched.c:1826: unlock: Unlocking "ehci->lock". "sitd_dma" might now be unreliable because other threads can now change the data that it depends on.
drivers/usb/host/ehci-sched.c:1829: lockagain: Locking "ehci->lock" again.
drivers/usb/host/ehci-sched.c:1838: use: Using an unreliable value of "sitd_dma" inside the second locked section.  If the data that "sitd_dma" depends on was changed by another thread, this use might be incorrect.

Error: ATOMICITY:
kernel/signal.c:1741: lock: Locking "sighand->siglock".
kernel/signal.c:1748: def: Assigning: "why" = data that might be protected by the lock.
kernel/signal.c:1751: unlock: Unlocking "sighand->siglock". "why" might now be unreliable because other threads can now change the data that it depends on.
kernel/signal.c:1756: lockagain: Locking "tasklist_lock" again.
kernel/signal.c:1757: use: Using an unreliable value of "why" inside the second locked section.  If the data that "why" depends on was changed by another thread, this use might be incorrect.

Error: ATOMICITY:
drivers/char/specialix.c:979: lock: Locking "bp->lock".
drivers/char/specialix.c:985: def: Assigning: "port->MSVR" = data that might be protected by the lock.
drivers/char/specialix.c:988: unlock: Unlocking "bp->lock". "port->MSVR" might now be unreliable because other threads can now change the data that it depends on.
drivers/char/specialix.c:1004: lockagain: Locking "bp->lock" again.
drivers/char/specialix.c:1005: use: Using an unreliable value of "port->MSVR" inside the second locked section.  If the data that "port->MSVR" depends on was changed by another thread, this use might be incorrect.

Error: ATOMICITY:
drivers/char/specialix.c:979: lock: Locking "bp->lock".
drivers/char/specialix.c:985: def: Assigning: "port->MSVR" = data that might be protected by the lock.
drivers/char/specialix.c:988: unlock: Unlocking "bp->lock". "port->MSVR" might now be unreliable because other threads can now change the data that it depends on.
drivers/char/specialix.c:1050: unlock: Unlocking "bp->lock". "port->MSVR" might now be unreliable because other threads can now change the data that it depends on.
drivers/char/specialix.c:1066: unlock: Unlocking "bp->lock". "port->MSVR" might now be unreliable because other threads can now change the data that it depends on.
drivers/char/specialix.c:1133: unlock: Unlocking "bp->lock". "port->MSVR" might now be unreliable because other threads can now change the data that it depends on.
drivers/char/specialix.c:1153: unlock: Unlocking "bp->lock". "port->MSVR" might now be unreliable because other threads can now change the data that it depends on.
drivers/char/specialix.c:1163: unlock: Unlocking "bp->lock". "port->MSVR" might now be unreliable because other threads can now change the data that it depends on.
drivers/char/specialix.c:1166: lockagain: Locking "bp->lock" again.
drivers/char/specialix.c:1171: use: Using an unreliable value of "port->MSVR" inside the second locked section.  If the data that "port->MSVR" depends on was changed by another thread, this use might be incorrect.

Error: ATOMICITY:
drivers/gpio/gpiolib.c:831: lock: Locking "gpio_lock".
drivers/gpio/gpiolib.c:833: def: Assigning: "desc" = data that might be protected by the lock.
drivers/gpio/gpiolib.c:837: unlock: Unlocking "gpio_lock". "desc" might now be unreliable because other threads can now change the data that it depends on.
drivers/gpio/gpiolib.c:840: lockagain: Locking "gpio_lock" again.
drivers/gpio/gpiolib.c:842: use: Using an unreliable value of "desc" inside the second locked section.  If the data that "desc" depends on was changed by another thread, this use might be incorrect.

Error: ATOMICITY:
sound/oss/sscape.c:420: lock: Locking "devc->lock".
sound/oss/sscape.c:421: def: Assigning: "codec_dma_bits" = data that might be protected by the lock.
sound/oss/sscape.c:426: unlock: Unlocking "devc->lock". "codec_dma_bits" might now be unreliable because other threads can now change the data that it depends on.
sound/oss/sscape.c:473: unlock: Unlocking "devc->lock". "codec_dma_bits" might now be unreliable because other threads can now change the data that it depends on.
sound/oss/sscape.c:492: lockagain: Locking "devc->lock" again.
sound/oss/sscape.c:507: use: Using an unreliable value of "codec_dma_bits" inside the second locked section.  If the data that "codec_dma_bits" depends on was changed by another thread, this use might be incorrect.

Error: ATOMICITY:
drivers/char/ip2/i2lib.c:1047: lock: Locking "pCh->Obuf_spinlock".
drivers/char/ip2/i2lib.c:1048: def: Assigning: "amountToMove" = data that might be protected by the lock.
drivers/char/ip2/i2lib.c:1049: unlock: Unlocking "pCh->Obuf_spinlock". "amountToMove" might now be unreliable because other threads can now change the data that it depends on.
drivers/char/ip2/i2lib.c:1077: lockagain: Locking "pCh->Obuf_spinlock" again.
drivers/char/ip2/i2lib.c:1089: use: Using an unreliable value of "amountToMove" inside the second locked section.  If the data that "amountToMove" depends on was changed by another thread, this use might be incorrect.

Error: ATOMICITY:
drivers/char/ip2/i2lib.c:1077: lock: Locking "pCh->Obuf_spinlock".
drivers/char/ip2/i2lib.c:1102: def: Assigning: "pCh->Obuf_stuff" = data that might be protected by the lock.
drivers/char/ip2/i2lib.c:1104: unlock: Unlocking "pCh->Obuf_spinlock". "pCh->Obuf_stuff" might now be unreliable because other threads can now change the data that it depends on.
drivers/char/ip2/i2lib.c:1049: unlock: Unlocking "pCh->Obuf_spinlock". "pCh->Obuf_stuff" might now be unreliable because other threads can now change the data that it depends on.
drivers/char/ip2/i2lib.c:1077: lockagain: Locking "pCh->Obuf_spinlock" again.
drivers/char/ip2/i2lib.c:1078: use: Using an unreliable value of "pCh->Obuf_stuff" inside the second locked section.  If the data that "pCh->Obuf_stuff" depends on was changed by another thread, this use might be incorrect.

Error: ATOMICITY:
fs/super.c:517: lock: Locking "sb_lock".
fs/super.c:519: def: Assigning: "sb" = data that might be protected by the lock.
fs/super.c:522: unlock: Unlocking "sb_lock". "sb" might now be unreliable because other threads can now change the data that it depends on.
fs/super.c:528: lockagain: Locking "sb_lock" again.
fs/super.c:529: use: Using an unreliable value of "sb" inside the second locked section.  If the data that "sb" depends on was changed by another thread, this use might be incorrect.

Error: ATOMICITY:
fs/super.c:528: lock: Locking "sb_lock".
fs/super.c:519: def: Assigning: "sb" = data that might be protected by the lock.
fs/super.c:522: unlock: Unlocking "sb_lock". "sb" might now be unreliable because other threads can now change the data that it depends on.
fs/super.c:528: lockagain: Locking "sb_lock" again.
fs/super.c:529: use: Using an unreliable value of "sb" inside the second locked section.  If the data that "sb" depends on was changed by another thread, this use might be incorrect.

Error: ATOMICITY:
drivers/infiniband/hw/cxgb3/iwch_qp.c:931: lock: Locking "qhp->lock".
drivers/infiniband/hw/cxgb3/iwch_qp.c:983: def: Assigning: "qhp->ep" = data that might be protected by the lock.
drivers/infiniband/hw/cxgb3/iwch_qp.c:993: unlock: Unlocking "qhp->lock". "qhp->ep" might now be unreliable because other threads can now change the data that it depends on.
drivers/infiniband/hw/cxgb3/iwch_qp.c:995: lockagain: Locking "qhp->lock" again.
drivers/infiniband/hw/cxgb3/iwch_qp.c:1093: use: Using an unreliable value of "qhp->ep" inside the second locked section.  If the data that "qhp->ep" depends on was changed by another thread, this use might be incorrect.

Error: ATOMICITY:
drivers/infiniband/hw/cxgb3/iwch_qp.c:931: lock: Locking "qhp->lock".
drivers/infiniband/hw/cxgb3/iwch_qp.c:983: def: Assigning: "qhp->ep" = data that might be protected by the lock.
drivers/infiniband/hw/cxgb3/iwch_qp.c:993: unlock: Unlocking "qhp->lock". "qhp->ep" might now be unreliable because other threads can now change the data that it depends on.
drivers/infiniband/hw/cxgb3/iwch_qp.c:995: lockagain: Locking "qhp->lock" again.
drivers/infiniband/hw/cxgb3/iwch_qp.c:1098: use: Using an unreliable value of "qhp->ep" inside the second locked section.  If the data that "qhp->ep" depends on was changed by another thread, this use might be incorrect.

Error: ATOMICITY:
drivers/scsi/lpfc/lpfc_sli.c:468: lock: Locking "phba->hbalock".
drivers/scsi/lpfc/lpfc_sli.c:469: def: Assigning: "iotag" = data that might be protected by the lock.
drivers/scsi/lpfc/lpfc_sli.c:479: unlock: Unlocking "phba->hbalock". "iotag" might now be unreliable because other threads can now change the data that it depends on.
drivers/scsi/lpfc/lpfc_sli.c:483: lockagain: Locking "phba->hbalock" again.
drivers/scsi/lpfc/lpfc_sli.c:505: use: Using an unreliable value of "iotag" inside the second locked section.  If the data that "iotag" depends on was changed by another thread, this use might be incorrect.

Error: ATOMICITY:
drivers/scsi/lpfc/lpfc_sli.c:468: lock: Locking "phba->hbalock".
drivers/scsi/lpfc/lpfc_sli.c:478: def: Assigning: "new_len" = data that might be protected by the lock.
drivers/scsi/lpfc/lpfc_sli.c:479: unlock: Unlocking "phba->hbalock". "new_len" might now be unreliable because other threads can now change the data that it depends on.
drivers/scsi/lpfc/lpfc_sli.c:483: lockagain: Locking "phba->hbalock" again.
drivers/scsi/lpfc/lpfc_sli.c:504: use: Using an unreliable value of "new_len" inside the second locked section.  If the data that "new_len" depends on was changed by another thread, this use might be incorrect.

Error: ATOMICITY:
fs/fuse/dev.c:141: lock: Locking "fc->lock".
fs/fuse/dev.c:144: def: Assigning: "ff->reserved_req" = data that might be protected by the lock.
fs/fuse/dev.c:148: unlock: Unlocking "fc->lock". "ff->reserved_req" might now be unreliable because other threads can now change the data that it depends on.
fs/fuse/dev.c:141: lockagain: Locking "fc->lock" again.
fs/fuse/dev.c:143: use: Using an unreliable value of "ff->reserved_req" inside the second locked section.  If the data that "ff->reserved_req" depends on was changed by another thread, this use might be incorrect.

Error: ATOMICITY:
fs/autofs4/waitq.c:442: lock: Locking "get_current()->sighand->siglock".
fs/autofs4/waitq.c:443: def: Assigning: "oldset" = data that might be protected by the lock.
fs/autofs4/waitq.c:446: unlock: Unlocking "get_current()->sighand->siglock". "oldset" might now be unreliable because other threads can now change the data that it depends on.
fs/autofs4/waitq.c:450: lockagain: Locking "get_current()->sighand->siglock" again.
fs/autofs4/waitq.c:451: use: Using an unreliable value of "oldset" inside the second locked section.  If the data that "oldset" depends on was changed by another thread, this use might be incorrect.

Error: ATOMICITY:
fs/xfs/quota/xfs_qm_syscalls.c:840: lock: Locking "mp->m_sb_lock".
fs/xfs/quota/xfs_qm_syscalls.c:841: def: Assigning: "oldsbqflag" = data that might be protected by the lock.
fs/xfs/quota/xfs_qm_syscalls.c:843: unlock: Unlocking "mp->m_sb_lock". "oldsbqflag" might now be unreliable because other threads can now change the data that it depends on.
fs/xfs/quota/xfs_qm_syscalls.c:862: lockagain: Locking "mp->m_sb_lock" again.
fs/xfs/quota/xfs_qm_syscalls.c:863: use: Using an unreliable value of "oldsbqflag" inside the second locked section.  If the data that "oldsbqflag" depends on was changed by another thread, this use might be incorrect.

Error: ATOMICITY:
kernel/hrtimer.c:1197: lock: Locking "cpu_base->lock".
kernel/hrtimer.c:1205: def: Assigning: "timer" = data that might be protected by the lock.
kernel/hrtimer.c:1222: unlock: Unlocking "cpu_base->lock". "timer" might now be unreliable because other threads can now change the data that it depends on.
kernel/hrtimer.c:1231: lockagain: Locking "cpu_base->lock" again.
kernel/hrtimer.c:1235: use: Using an unreliable value of "timer" inside the second locked section.  If the data that "timer" depends on was changed by another thread, this use might be incorrect.

Error: ATOMICITY:
kernel/hrtimer.c:1197: lock: Locking "cpu_base->lock".
kernel/hrtimer.c:1205: def: Assigning: "timer" = data that might be protected by the lock.
kernel/hrtimer.c:1222: unlock: Unlocking "cpu_base->lock". "timer" might now be unreliable because other threads can now change the data that it depends on.
kernel/hrtimer.c:1231: lockagain: Locking "cpu_base->lock" again.
kernel/hrtimer.c:1241: use: Using an unreliable value of "timer" inside the second locked section.  If the data that "timer" depends on was changed by another thread, this use might be incorrect.

Error: ATOMICITY:
kernel/hrtimer.c:1231: lock: Locking "cpu_base->lock".
kernel/hrtimer.c:1205: def: Assigning: "timer" = data that might be protected by the lock.
kernel/hrtimer.c:1222: unlock: Unlocking "cpu_base->lock". "timer" might now be unreliable because other threads can now change the data that it depends on.
kernel/hrtimer.c:1231: lockagain: Locking "cpu_base->lock" again.
kernel/hrtimer.c:1235: use: Using an unreliable value of "timer" inside the second locked section.  If the data that "timer" depends on was changed by another thread, this use might be incorrect.

Error: ATOMICITY:
kernel/hrtimer.c:1231: lock: Locking "cpu_base->lock".
kernel/hrtimer.c:1205: def: Assigning: "timer" = data that might be protected by the lock.
kernel/hrtimer.c:1222: unlock: Unlocking "cpu_base->lock". "timer" might now be unreliable because other threads can now change the data that it depends on.
kernel/hrtimer.c:1231: lockagain: Locking "cpu_base->lock" again.
kernel/hrtimer.c:1241: use: Using an unreliable value of "timer" inside the second locked section.  If the data that "timer" depends on was changed by another thread, this use might be incorrect.

Error: ATOMICITY:
mm/shmem.c:543: lock: Locking "info->lock".
mm/shmem.c:549: def: Assigning: "needs_lock" = data that might be protected by the lock.
mm/shmem.c:570: unlock: Unlocking "info->lock". "needs_lock" might now be unreliable because other threads can now change the data that it depends on.
mm/shmem.c:622: lockagain: Locking "*needs_lock" again.
mm/shmem.c:624: use: Using an unreliable value of "needs_lock" inside the second locked section.  If the data that "needs_lock" depends on was changed by another thread, this use might be incorrect.

Error: ATOMICITY:
mm/shmem.c:543: lock: Locking "info->lock".
mm/shmem.c:549: def: Assigning: "needs_lock" = data that might be protected by the lock.
mm/shmem.c:570: unlock: Unlocking "info->lock". "needs_lock" might now be unreliable because other threads can now change the data that it depends on.
mm/shmem.c:657: lockagain: Locking "*needs_lock" again.
mm/shmem.c:659: use: Using an unreliable value of "needs_lock" inside the second locked section.  If the data that "needs_lock" depends on was changed by another thread, this use might be incorrect.

Error: ATOMICITY:
mm/shmem.c:543: lock: Locking "info->lock".
mm/shmem.c:549: def: Assigning: "needs_lock" = data that might be protected by the lock.
mm/shmem.c:570: unlock: Unlocking "info->lock". "needs_lock" might now be unreliable because other threads can now change the data that it depends on.
mm/shmem.c:675: lockagain: Locking "*needs_lock" again.
mm/shmem.c:677: use: Using an unreliable value of "needs_lock" inside the second locked section.  If the data that "needs_lock" depends on was changed by another thread, this use might be incorrect.

Error: ATOMICITY:
net/ipv6/udp.c:397: lock: Locking "udp_hash_lock".
net/ipv6/udp.c:400: def: Assigning: "sk" = data that might be protected by the lock.
net/ipv6/udp.c:416: unlock: Unlocking "sk2->sk_lock.slock". "sk" might now be unreliable because other threads can now change the data that it depends on.
net/ipv6/udp.c:419: lockagain: Locking "sk->sk_lock.slock" again.
net/ipv6/udp.c:421: use: Using an unreliable value of "sk" inside the second locked section.  If the data that "sk" depends on was changed by another thread, this use might be incorrect.

Error: ATOMICITY:
net/ipv6/udp.c:397: lock: Locking "udp_hash_lock".
net/ipv6/udp.c:400: def: Assigning: "sk" = data that might be protected by the lock.
net/ipv6/udp.c:416: unlock: Unlocking "sk2->sk_lock.slock". "sk" might now be unreliable because other threads can now change the data that it depends on.
net/ipv6/udp.c:419: lockagain: Locking "sk->sk_lock.slock" again.
net/ipv6/udp.c:423: use: Using an unreliable value of "sk" inside the second locked section.  If the data that "sk" depends on was changed by another thread, this use might be incorrect.

Error: ATOMICITY:
arch/x86/kernel/irq_64.c:101: lock: Locking "desc->lock".
arch/x86/kernel/irq_64.c:112: def: Assigning: "mask" = data that might be protected by the lock.
arch/x86/kernel/irq_64.c:126: unlock: Unlocking "desc->lock". "mask" might now be unreliable because other threads can now change the data that it depends on.
arch/x86/kernel/irq_64.c:101: lockagain: Locking "desc->lock" again.
arch/x86/kernel/irq_64.c:119: use: Using an unreliable value of "mask" inside the second locked section.  If the data that "mask" depends on was changed by another thread, this use might be incorrect.

Error: ATOMICITY:
drivers/scsi/ips.c:2629: lock: Locking "*host->host_lock".
drivers/scsi/ips.c:2650: def: Assigning: "scb" = data that might be protected by the lock.
drivers/scsi/ips.c:2656: unlock: Unlocking "*host->host_lock". "scb" might now be unreliable because other threads can now change the data that it depends on.
drivers/scsi/ips.c:2663: lockagain: Locking "*host->host_lock" again.
drivers/scsi/ips.c:2671: use: Using an unreliable value of "scb" inside the second locked section.  If the data that "scb" depends on was changed by another thread, this use might be incorrect.

Error: ATOMICITY:
drivers/scsi/ips.c:2790: lock: Locking "*host->host_lock".
drivers/scsi/ips.c:2719: def: Assigning: "scb" = data that might be protected by the lock.
drivers/scsi/ips.c:2733: unlock: Unlocking "*host->host_lock". "scb" might now be unreliable because other threads can now change the data that it depends on.
drivers/scsi/ips.c:2790: lockagain: Locking "*host->host_lock" again.
drivers/scsi/ips.c:2792: use: Using an unreliable value of "scb" inside the second locked section.  If the data that "scb" depends on was changed by another thread, this use might be incorrect.

Error: ATOMICITY:
ipc/msg.c:876: lock: Locking "msq->q_perm.lock".
ipc/msg.c:794: def: Assigning: "msgtyp" = data that might be protected by the lock.
ipc/msg.c:837: unlock: Unlocking "msq->q_perm.lock". "msgtyp" might now be unreliable because other threads can now change the data that it depends on.
ipc/msg.c:876: lockagain: Locking "msq->q_perm.lock" again.
ipc/msg.c:786: use: Using an unreliable value of "msgtyp" inside the second locked section.  If the data that "msgtyp" depends on was changed by another thread, this use might be incorrect.

Error: ATOMICITY:
ipc/msg.c:876: lock: Locking "msq->q_perm.lock".
ipc/msg.c:794: def: Assigning: "msgtyp" = data that might be protected by the lock.
ipc/msg.c:837: unlock: Unlocking "msq->q_perm.lock". "msgtyp" might now be unreliable because other threads can now change the data that it depends on.
ipc/msg.c:876: lockagain: Locking "msq->q_perm.lock" again.
ipc/msg.c:829: use: Using an unreliable value of "msgtyp" inside the second locked section.  If the data that "msgtyp" depends on was changed by another thread, this use might be incorrect.

Error: ATOMICITY:
ipc/msg.c:876: lock: Locking "msq->q_perm.lock".
ipc/msg.c:835: def: Assigning: "msr_d.r_msg" = data that might be protected by the lock.
ipc/msg.c:837: unlock: Unlocking "msq->q_perm.lock". "msr_d.r_msg" might now be unreliable because other threads can now change the data that it depends on.
ipc/msg.c:876: lockagain: Locking "msq->q_perm.lock" again.
ipc/msg.c:882: use: Using an unreliable value of "(struct msg_msg *)msr_d.r_msg" inside the second locked section.  If the data that "(struct msg_msg *)msr_d.r_msg" depends on was changed by another thread, this use might be incorrect.

Error: ATOMICITY:
drivers/infiniband/hw/ipath/ipath_ruc.c:277: lock: Locking "sqp->s_lock".
drivers/infiniband/hw/ipath/ipath_ruc.c:289: def: Assigning: "wqe" = data that might be protected by the lock.
drivers/infiniband/hw/ipath/ipath_ruc.c:309: unlock: Unlocking "sqp->s_lock". "wqe" might now be unreliable because other threads can now change the data that it depends on.
drivers/infiniband/hw/ipath/ipath_ruc.c:448: lockagain: Locking "sqp->s_lock" again.
drivers/infiniband/hw/ipath/ipath_ruc.c:451: use: Using an unreliable value of "wqe" inside the second locked section.  If the data that "wqe" depends on was changed by another thread, this use might be incorrect.

Error: ATOMICITY:
drivers/infiniband/hw/ipath/ipath_ruc.c:277: lock: Locking "sqp->s_lock".
drivers/infiniband/hw/ipath/ipath_ruc.c:289: def: Assigning: "wqe" = data that might be protected by the lock.
drivers/infiniband/hw/ipath/ipath_ruc.c:309: unlock: Unlocking "sqp->s_lock". "wqe" might now be unreliable because other threads can now change the data that it depends on.
drivers/infiniband/hw/ipath/ipath_ruc.c:490: lockagain: Locking "sqp->s_lock" again.
drivers/infiniband/hw/ipath/ipath_ruc.c:491: use: Using an unreliable value of "wqe" inside the second locked section.  If the data that "wqe" depends on was changed by another thread, this use might be incorrect.

Error: ATOMICITY:
fs/proc/generic.c:455: lock: Locking "proc_subdir_lock".
fs/proc/generic.c:456: def: Assigning: "de" = data that might be protected by the lock.
fs/proc/generic.c:475: unlock: Unlocking "proc_subdir_lock". "de" might now be unreliable because other threads can now change the data that it depends on.
fs/proc/generic.c:481: lockagain: Locking "proc_subdir_lock" again.
fs/proc/generic.c:484: use: Using an unreliable value of "de" inside the second locked section.  If the data that "de" depends on was changed by another thread, this use might be incorrect.

Error: ATOMICITY:
fs/proc/generic.c:481: lock: Locking "proc_subdir_lock".
fs/proc/generic.c:485: def: Assigning: "de" = data that might be protected by the lock.
fs/proc/generic.c:475: unlock: Unlocking "proc_subdir_lock". "de" might now be unreliable because other threads can now change the data that it depends on.
fs/proc/generic.c:481: lockagain: Locking "proc_subdir_lock" again.
fs/proc/generic.c:484: use: Using an unreliable value of "de" inside the second locked section.  If the data that "de" depends on was changed by another thread, this use might be incorrect.

Error: ATOMICITY:
fs/exec.c:1214: lock: Locking "binfmt_lock".
fs/exec.c:1215: def: Assigning: "fmt" = data that might be protected by the lock.
fs/exec.c:1221: unlock: Unlocking "binfmt_lock". "fmt" might now be unreliable because other threads can now change the data that it depends on.
fs/exec.c:1241: lockagain: Locking "binfmt_lock" again.
fs/exec.c:1242: use: Using an unreliable value of "fmt" inside the second locked section.  If the data that "fmt" depends on was changed by another thread, this use might be incorrect.

Error: ATOMICITY:
drivers/scsi/lpfc/lpfc_sli.c:2134: lock: Locking "phba->hbalock".
drivers/scsi/lpfc/lpfc_sli.c:2213: def: Assigning: "saveq" = data that might be protected by the lock.
drivers/scsi/lpfc/lpfc_sli.c:2227: unlock: Unlocking "phba->hbalock". "saveq" might now be unreliable because other threads can now change the data that it depends on.
drivers/scsi/lpfc/lpfc_sli.c:2229: lockagain: Locking "phba->hbalock" again.
drivers/scsi/lpfc/lpfc_sli.c:2281: use: Using an unreliable value of "saveq" inside the second locked section.  If the data that "saveq" depends on was changed by another thread, this use might be incorrect.

Error: ATOMICITY:
drivers/scsi/lpfc/lpfc_sli.c:2272: lock: Locking "phba->hbalock".
drivers/scsi/lpfc/lpfc_sli.c:2215: def: Assigning: "irsp" = data that might be protected by the lock.
drivers/scsi/lpfc/lpfc_sli.c:2227: unlock: Unlocking "phba->hbalock". "irsp" might now be unreliable because other threads can now change the data that it depends on.
drivers/scsi/lpfc/lpfc_sli.c:2229: lockagain: Locking "phba->hbalock" again.
drivers/scsi/lpfc/lpfc_sli.c:2307: use: Using an unreliable value of "irsp" inside the second locked section.  If the data that "irsp" depends on was changed by another thread, this use might be incorrect.

Error: ATOMICITY:
drivers/scsi/lpfc/lpfc_sli.c:2272: lock: Locking "phba->hbalock".
drivers/scsi/lpfc/lpfc_sli.c:2213: def: Assigning: "saveq" = data that might be protected by the lock.
drivers/scsi/lpfc/lpfc_sli.c:2227: unlock: Unlocking "phba->hbalock". "saveq" might now be unreliable because other threads can now change the data that it depends on.
drivers/scsi/lpfc/lpfc_sli.c:2229: lockagain: Locking "phba->hbalock" again.
drivers/scsi/lpfc/lpfc_sli.c:2281: use: Using an unreliable value of "saveq" inside the second locked section.  If the data that "saveq" depends on was changed by another thread, this use might be incorrect.

Error: ATOMICITY:
drivers/scsi/lpfc/lpfc_sli.c:2272: lock: Locking "phba->hbalock".
drivers/scsi/lpfc/lpfc_sli.c:2213: def: Assigning: "saveq" = data that might be protected by the lock.
drivers/scsi/lpfc/lpfc_sli.c:2274: unlock: Unlocking "phba->hbalock". "saveq" might now be unreliable because other threads can now change the data that it depends on.
drivers/scsi/lpfc/lpfc_sli.c:2277: lockagain: Locking "phba->hbalock" again.
drivers/scsi/lpfc/lpfc_sli.c:2332: use: Using an unreliable value of "saveq" inside the second locked section.  If the data that "saveq" depends on was changed by another thread, this use might be incorrect.

Error: ATOMICITY:
drivers/scsi/lpfc/lpfc_sli.c:2277: lock: Locking "phba->hbalock".
drivers/scsi/lpfc/lpfc_sli.c:2213: def: Assigning: "saveq" = data that might be protected by the lock.
drivers/scsi/lpfc/lpfc_sli.c:2288: unlock: Unlocking "phba->hbalock". "saveq" might now be unreliable because other threads can now change the data that it depends on.
drivers/scsi/lpfc/lpfc_sli.c:2293: lockagain: Locking "phba->hbalock" again.
drivers/scsi/lpfc/lpfc_sli.c:2332: use: Using an unreliable value of "saveq" inside the second locked section.  If the data that "saveq" depends on was changed by another thread, this use might be incorrect.

Error: ATOMICITY:
drivers/scsi/lpfc/lpfc_sli.c:2293: lock: Locking "phba->hbalock".
drivers/scsi/lpfc/lpfc_sli.c:2213: def: Assigning: "saveq" = data that might be protected by the lock.
drivers/scsi/lpfc/lpfc_sli.c:2227: unlock: Unlocking "phba->hbalock". "saveq" might now be unreliable because other threads can now change the data that it depends on.
drivers/scsi/lpfc/lpfc_sli.c:2229: lockagain: Locking "phba->hbalock" again.
drivers/scsi/lpfc/lpfc_sli.c:2281: use: Using an unreliable value of "saveq" inside the second locked section.  If the data that "saveq" depends on was changed by another thread, this use might be incorrect.

Error: ATOMICITY:
drivers/scsi/lpfc/lpfc_sli.c:2134: lock: Locking "phba->hbalock".
drivers/scsi/lpfc/lpfc_sli.c:2213: def: Assigning: "saveq" = data that might be protected by the lock.
drivers/scsi/lpfc/lpfc_sli.c:2227: unlock: Unlocking "phba->hbalock". "saveq" might now be unreliable because other threads can now change the data that it depends on.
drivers/scsi/lpfc/lpfc_sli.c:2269: unlock: Unlocking "phba->hbalock". "saveq" might now be unreliable because other threads can now change the data that it depends on.
drivers/scsi/lpfc/lpfc_sli.c:2272: lockagain: Locking "phba->hbalock" again.
drivers/scsi/lpfc/lpfc_sli.c:2332: use: Using an unreliable value of "saveq" inside the second locked section.  If the data that "saveq" depends on was changed by another thread, this use might be incorrect.

Error: ATOMICITY:
drivers/scsi/lpfc/lpfc_sli.c:2272: lock: Locking "phba->hbalock".
drivers/scsi/lpfc/lpfc_sli.c:2192: def: Assigning: "pring->rspidx" = data that might be protected by the lock.
drivers/scsi/lpfc/lpfc_sli.c:2227: unlock: Unlocking "phba->hbalock". "pring->rspidx" might now be unreliable because other threads can now change the data that it depends on.
drivers/scsi/lpfc/lpfc_sli.c:2269: unlock: Unlocking "phba->hbalock". "pring->rspidx" might now be unreliable because other threads can now change the data that it depends on.
drivers/scsi/lpfc/lpfc_sli.c:2272: lockagain: Locking "phba->hbalock" again.
drivers/scsi/lpfc/lpfc_sli.c:2202: use: Using an unreliable value of "pring->rspidx" inside the second locked section.  If the data that "pring->rspidx" depends on was changed by another thread, this use might be incorrect.

Error: ATOMICITY:
drivers/scsi/lpfc/lpfc_sli.c:2272: lock: Locking "phba->hbalock".
drivers/scsi/lpfc/lpfc_sli.c:2213: def: Assigning: "saveq" = data that might be protected by the lock.
drivers/scsi/lpfc/lpfc_sli.c:2227: unlock: Unlocking "phba->hbalock". "saveq" might now be unreliable because other threads can now change the data that it depends on.
drivers/scsi/lpfc/lpfc_sli.c:2269: unlock: Unlocking "phba->hbalock". "saveq" might now be unreliable because other threads can now change the data that it depends on.
drivers/scsi/lpfc/lpfc_sli.c:2272: lockagain: Locking "phba->hbalock" again.
drivers/scsi/lpfc/lpfc_sli.c:2332: use: Using an unreliable value of "saveq" inside the second locked section.  If the data that "saveq" depends on was changed by another thread, this use might be incorrect.

Error: ATOMICITY:
drivers/message/fusion/mptscsih.c:1026: lock: Locking "ioc->scsi_lookup_lock".
drivers/message/fusion/mptscsih.c:1049: def: Assigning: "ioc->ScsiLookup[ii]" = data that might be protected by the lock.
drivers/message/fusion/mptscsih.c:1050: unlock: Unlocking "ioc->scsi_lookup_lock". "ioc->ScsiLookup[ii]" might now be unreliable because other threads can now change the data that it depends on.
drivers/message/fusion/mptscsih.c:1060: lockagain: Locking "ioc->scsi_lookup_lock" again.
drivers/message/fusion/mptscsih.c:1028: use: Using an unreliable value of "ioc->ScsiLookup[ii]" inside the second locked section.  If the data that "ioc->ScsiLookup[ii]" depends on was changed by another thread, this use might be incorrect.

Error: ATOMICITY:
drivers/usb/wusbcore/wa-xfer.c:1178: lock: Locking "xfer->lock".
drivers/usb/wusbcore/wa-xfer.c:1179: def: Assigning: "rpipe" = data that might be protected by the lock.
drivers/usb/wusbcore/wa-xfer.c:1184: unlock: Unlocking "wa->xfer_list_lock". "rpipe" might now be unreliable because other threads can now change the data that it depends on.
drivers/usb/wusbcore/wa-xfer.c:1200: lockagain: Locking "rpipe->seg_lock" again.
drivers/usb/wusbcore/wa-xfer.c:1203: use: Using an unreliable value of "rpipe" inside the second locked section.  If the data that "rpipe" depends on was changed by another thread, this use might be incorrect.

Error: ATOMICITY:
drivers/scsi/lpfc/lpfc_sli.c:1939: lock: Locking "phba->hbalock".
drivers/scsi/lpfc/lpfc_sli.c:1965: def: Assigning: "pring->rspidx" = data that might be protected by the lock.
drivers/scsi/lpfc/lpfc_sli.c:1984: unlock: Unlocking "phba->hbalock". "pring->rspidx" might now be unreliable because other threads can now change the data that it depends on.
drivers/scsi/lpfc/lpfc_sli.c:1986: lockagain: Locking "phba->hbalock" again.
drivers/scsi/lpfc/lpfc_sli.c:2069: use: Using an unreliable value of "pring->rspidx" inside the second locked section.  If the data that "pring->rspidx" depends on was changed by another thread, this use might be incorrect.

Error: ATOMICITY:
drivers/scsi/lpfc/lpfc_sli.c:1986: lock: Locking "phba->hbalock".
drivers/scsi/lpfc/lpfc_sli.c:1971: def: Assigning: "irsp" = data that might be protected by the lock.
drivers/scsi/lpfc/lpfc_sli.c:1984: unlock: Unlocking "phba->hbalock". "irsp" might now be unreliable because other threads can now change the data that it depends on.
drivers/scsi/lpfc/lpfc_sli.c:1986: lockagain: Locking "phba->hbalock" again.
drivers/scsi/lpfc/lpfc_sli.c:2045: use: Using an unreliable value of "irsp" inside the second locked section.  If the data that "irsp" depends on was changed by another thread, this use might be incorrect.

Error: ATOMICITY:
drivers/scsi/lpfc/lpfc_sli.c:1986: lock: Locking "phba->hbalock".
drivers/scsi/lpfc/lpfc_sli.c:1965: def: Assigning: "pring->rspidx" = data that might be protected by the lock.
drivers/scsi/lpfc/lpfc_sli.c:1984: unlock: Unlocking "phba->hbalock". "pring->rspidx" might now be unreliable because other threads can now change the data that it depends on.
drivers/scsi/lpfc/lpfc_sli.c:1986: lockagain: Locking "phba->hbalock" again.
drivers/scsi/lpfc/lpfc_sli.c:2069: use: Using an unreliable value of "pring->rspidx" inside the second locked section.  If the data that "pring->rspidx" depends on was changed by another thread, this use might be incorrect.

Error: ATOMICITY:
drivers/scsi/lpfc/lpfc_sli.c:1986: lock: Locking "phba->hbalock".
drivers/scsi/lpfc/lpfc_sli.c:1965: def: Assigning: "pring->rspidx" = data that might be protected by the lock.
drivers/scsi/lpfc/lpfc_sli.c:2027: unlock: Unlocking "phba->hbalock". "pring->rspidx" might now be unreliable because other threads can now change the data that it depends on.
drivers/scsi/lpfc/lpfc_sli.c:2031: lockagain: Locking "phba->hbalock" again.
drivers/scsi/lpfc/lpfc_sli.c:2069: use: Using an unreliable value of "pring->rspidx" inside the second locked section.  If the data that "pring->rspidx" depends on was changed by another thread, this use might be incorrect.

Error: ATOMICITY:
drivers/scsi/lpfc/lpfc_sli.c:1986: lock: Locking "phba->hbalock".
drivers/scsi/lpfc/lpfc_sli.c:1973: def: Assigning: "type" = data that might be protected by the lock.
drivers/scsi/lpfc/lpfc_sli.c:1984: unlock: Unlocking "phba->hbalock". "type" might now be unreliable because other threads can now change the data that it depends on.
drivers/scsi/lpfc/lpfc_sli.c:1986: lockagain: Locking "phba->hbalock" again.
drivers/scsi/lpfc/lpfc_sli.c:2052: use: Using an unreliable value of "type" inside the second locked section.  If the data that "type" depends on was changed by another thread, this use might be incorrect.

Error: ATOMICITY:
drivers/scsi/lpfc/lpfc_sli.c:2031: lock: Locking "phba->hbalock".
drivers/scsi/lpfc/lpfc_sli.c:1965: def: Assigning: "pring->rspidx" = data that might be protected by the lock.
drivers/scsi/lpfc/lpfc_sli.c:2037: unlock: Unlocking "phba->hbalock". "pring->rspidx" might now be unreliable because other threads can now change the data that it depends on.
drivers/scsi/lpfc/lpfc_sli.c:2039: lockagain: Locking "phba->hbalock" again.
drivers/scsi/lpfc/lpfc_sli.c:2069: use: Using an unreliable value of "pring->rspidx" inside the second locked section.  If the data that "pring->rspidx" depends on was changed by another thread, this use might be incorrect.

Error: ATOMICITY:
drivers/net/pcnet32.c:906: lock: Locking "lp->lock".
drivers/net/pcnet32.c:973: def: Assigning: "x" = data that might be protected by the lock.
drivers/net/pcnet32.c:977: unlock: Unlocking "lp->lock". "x" might now be unreliable because other threads can now change the data that it depends on.
drivers/net/pcnet32.c:979: lockagain: Locking "lp->lock" again.
drivers/net/pcnet32.c:985: use: Using an unreliable value of "x" inside the second locked section.  If the data that "x" depends on was changed by another thread, this use might be incorrect.

Error: ATOMICITY:
drivers/acpi/sleep/wakeup.c:108: lock: Locking "acpi_device_lock".
drivers/acpi/sleep/wakeup.c:109: def: Assigning: "next" = data that might be protected by the lock.
drivers/acpi/sleep/wakeup.c:119: unlock: Unlocking "acpi_device_lock". "next" might now be unreliable because other threads can now change the data that it depends on.
drivers/acpi/sleep/wakeup.c:126: lockagain: Locking "acpi_device_lock" again.
drivers/acpi/sleep/wakeup.c:109: use: Using an unreliable value of "next" inside the second locked section.  If the data that "next" depends on was changed by another thread, this use might be incorrect.

Error: ATOMICITY:
drivers/acpi/sleep/wakeup.c:126: lock: Locking "acpi_device_lock".
drivers/acpi/sleep/wakeup.c:109: def: Assigning: "next" = data that might be protected by the lock.
drivers/acpi/sleep/wakeup.c:131: unlock: Unlocking "acpi_device_lock". "next" might now be unreliable because other threads can now change the data that it depends on.
drivers/acpi/sleep/wakeup.c:140: lockagain: Locking "acpi_device_lock" again.
drivers/acpi/sleep/wakeup.c:109: use: Using an unreliable value of "next" inside the second locked section.  If the data that "next" depends on was changed by another thread, this use might be incorrect.

Error: ATOMICITY:
sound/pci/intel8x0.c:981: lock: Locking "chip->reg_lock".
sound/pci/intel8x0.c:1002: def: Assigning: "cnt" = data that might be protected by the lock.
sound/pci/intel8x0.c:1016: unlock: Unlocking "chip->reg_lock". "cnt" might now be unreliable because other threads can now change the data that it depends on.
sound/pci/intel8x0.c:1018: lockagain: Locking "chip->reg_lock" again.
sound/pci/intel8x0.c:1024: use: Using an unreliable value of "cnt" inside the second locked section.  If the data that "cnt" depends on was changed by another thread, this use might be incorrect.

Error: ATOMICITY:
net/unix/af_unix.c:1407: lock: Locking "((struct unix_sock *)other)->lock".
net/unix/af_unix.c:1455: def: Assigning: "timeo" = data that might be protected by the lock.
net/unix/af_unix.c:1417: unlock: Unlocking "((struct unix_sock *)other)->lock". "timeo" might now be unreliable because other threads can now change the data that it depends on.
net/unix/af_unix.c:1424: unlock: Unlocking "((struct unix_sock *)sk)->lock". "timeo" might now be unreliable because other threads can now change the data that it depends on.
net/unix/af_unix.c:1407: lockagain: Locking "((struct unix_sock *)other)->lock" again.
net/unix/af_unix.c:1455: use: Using an unreliable value of "timeo" inside the second locked section.  If the data that "timeo" depends on was changed by another thread, this use might be incorrect.

Error: ATOMICITY:
drivers/acpi/sleep/wakeup.c:65: lock: Locking "acpi_device_lock".
drivers/acpi/sleep/wakeup.c:66: def: Assigning: "next" = data that might be protected by the lock.
drivers/acpi/sleep/wakeup.c:79: unlock: Unlocking "acpi_device_lock". "next" might now be unreliable because other threads can now change the data that it depends on.
drivers/acpi/sleep/wakeup.c:84: lockagain: Locking "acpi_device_lock" again.
drivers/acpi/sleep/wakeup.c:66: use: Using an unreliable value of "next" inside the second locked section.  If the data that "next" depends on was changed by another thread, this use might be incorrect.

Error: ATOMICITY:
drivers/acpi/sleep/wakeup.c:84: lock: Locking "acpi_device_lock".
drivers/acpi/sleep/wakeup.c:66: def: Assigning: "next" = data that might be protected by the lock.
drivers/acpi/sleep/wakeup.c:88: unlock: Unlocking "acpi_device_lock". "next" might now be unreliable because other threads can now change the data that it depends on.
drivers/acpi/sleep/wakeup.c:92: lockagain: Locking "acpi_device_lock" again.
drivers/acpi/sleep/wakeup.c:66: use: Using an unreliable value of "next" inside the second locked section.  If the data that "next" depends on was changed by another thread, this use might be incorrect.

Error: ATOMICITY:
fs/xfs/xfs_trans_ail.c:146: lock: Locking "mp->m_ail_lock".
fs/xfs/xfs_trans_ail.c:147: def: Assigning: "lip" = data that might be protected by the lock.
fs/xfs/xfs_trans_ail.c:187: unlock: Unlocking "mp->m_ail_lock". "lip" might now be unreliable because other threads can now change the data that it depends on.
fs/xfs/xfs_trans_ail.c:224: lockagain: Locking "mp->m_ail_lock" again.
fs/xfs/xfs_trans_ail.c:247: use: Using an unreliable value of "lip" inside the second locked section.  If the data that "lip" depends on was changed by another thread, this use might be incorrect.

Error: ATOMICITY:
fs/gfs2/glock.c:1832: lock: Locking "*gl_lock_addr(gi->hash)".
fs/gfs2/glock.c:1833: def: Assigning: "gi->gl" = data that might be protected by the lock.
fs/gfs2/glock.c:1837: unlock: Unlocking "*gl_lock_addr(gi->hash)". "gi->gl" might now be unreliable because other threads can now change the data that it depends on.
fs/gfs2/glock.c:1814: lockagain: Locking "*gl_lock_addr(gi->hash)" again.
fs/gfs2/glock.c:1815: use: Using an unreliable value of "gi->gl" inside the second locked section.  If the data that "gi->gl" depends on was changed by another thread, this use might be incorrect.

Error: ATOMICITY:
fs/sysfs/file.c:271: lock: Locking "sysfs_open_dirent_lock".
fs/sysfs/file.c:274: def: Assigning: "(*sd).s_attr.open" = data that might be protected by the lock.
fs/sysfs/file.c:284: unlock: Unlocking "sysfs_open_dirent_lock". "(*sd).s_attr.open" might now be unreliable because other threads can now change the data that it depends on.
fs/sysfs/file.c:271: lockagain: Locking "sysfs_open_dirent_lock" again.
fs/sysfs/file.c:278: use: Using an unreliable value of "(*sd).s_attr.open" inside the second locked section.  If the data that "(*sd).s_attr.open" depends on was changed by another thread, this use might be incorrect.

Error: ATOMICITY:
drivers/net/tulip/interrupt.c:555: lock: Locking "tp->lock".
drivers/net/tulip/interrupt.c:619: def: Assigning: "tp->dirty_tx" = data that might be protected by the lock.
drivers/net/tulip/interrupt.c:627: unlock: Unlocking "tp->lock". "tp->dirty_tx" might now be unreliable because other threads can now change the data that it depends on.
drivers/net/tulip/interrupt.c:555: lockagain: Locking "tp->lock" again.
drivers/net/tulip/interrupt.c:557: use: Using an unreliable value of "tp->dirty_tx" inside the second locked section.  If the data that "tp->dirty_tx" depends on was changed by another thread, this use might be incorrect.

Error: ATOMICITY:
drivers/net/tulip/interrupt.c:555: lock: Locking "tp->lock".
drivers/net/tulip/interrupt.c:604: def: Assigning: "tp->tx_buffers[entry].mapping" = data that might be protected by the lock.
drivers/net/tulip/interrupt.c:627: unlock: Unlocking "tp->lock". "tp->tx_buffers[entry].mapping" might now be unreliable because other threads can now change the data that it depends on.
drivers/net/tulip/interrupt.c:555: lockagain: Locking "tp->lock" again.
drivers/net/tulip/interrupt.c:569: use: Using an unreliable value of "tp->tx_buffers[entry].mapping" inside the second locked section.  If the data that "tp->tx_buffers[entry].mapping" depends on was changed by another thread, this use might be incorrect.

Error: ATOMICITY:
drivers/net/tulip/interrupt.c:555: lock: Locking "tp->lock".
drivers/net/tulip/interrupt.c:604: def: Assigning: "tp->tx_buffers[entry].mapping" = data that might be protected by the lock.
drivers/net/tulip/interrupt.c:627: unlock: Unlocking "tp->lock". "tp->tx_buffers[entry].mapping" might now be unreliable because other threads can now change the data that it depends on.
drivers/net/tulip/interrupt.c:555: lockagain: Locking "tp->lock" again.
drivers/net/tulip/interrupt.c:597: use: Using an unreliable value of "tp->tx_buffers[entry].mapping" inside the second locked section.  If the data that "tp->tx_buffers[entry].mapping" depends on was changed by another thread, this use might be incorrect.

Error: ATOMICITY:
drivers/net/tulip/interrupt.c:555: lock: Locking "tp->lock".
drivers/net/tulip/interrupt.c:603: def: Assigning: "tp->tx_buffers[entry].skb" = data that might be protected by the lock.
drivers/net/tulip/interrupt.c:627: unlock: Unlocking "tp->lock". "tp->tx_buffers[entry].skb" might now be unreliable because other threads can now change the data that it depends on.
drivers/net/tulip/interrupt.c:555: lockagain: Locking "tp->lock" again.
drivers/net/tulip/interrupt.c:602: use: Using an unreliable value of "tp->tx_buffers[entry].skb" inside the second locked section.  If the data that "tp->tx_buffers[entry].skb" depends on was changed by another thread, this use might be incorrect.

Error: ATOMICITY:
drivers/scsi/libsas/sas_port.c:60: lock: Locking "sas_ha->phy_port_lock".
drivers/scsi/libsas/sas_port.c:60: def: Assigning: "flags" = data that might be protected by the lock.
drivers/scsi/libsas/sas_port.c:76: unlock: Unlocking "port->phy_list_lock". "flags" might now be unreliable because other threads can now change the data that it depends on.
drivers/scsi/libsas/sas_port.c:63: lockagain: Locking "port->phy_list_lock" again.
drivers/scsi/libsas/sas_port.c:82: use: Using an unreliable value of "flags" inside the second locked section.  If the data that "flags" depends on was changed by another thread, this use might be incorrect.

Error: ATOMICITY:
drivers/atm/zatm.c:508: lock: Locking "zatm_dev->lock".
drivers/atm/zatm.c:513: def: Assigning: "chan" = data that might be protected by the lock.
drivers/atm/zatm.c:514: unlock: Unlocking "zatm_dev->lock". "chan" might now be unreliable because other threads can now change the data that it depends on.
drivers/atm/zatm.c:520: lockagain: Locking "zatm_dev->lock" again.
drivers/atm/zatm.c:526: use: Using an unreliable value of "chan" inside the second locked section.  If the data that "chan" depends on was changed by another thread, this use might be incorrect.

Error: ATOMICITY:
drivers/isdn/gigaset/ser-gigaset.c:138: lock: Locking "cs->cmdlock".
drivers/isdn/gigaset/ser-gigaset.c:141: def: Assigning: "cb" = data that might be protected by the lock.
drivers/isdn/gigaset/ser-gigaset.c:149: unlock: Unlocking "cs->cmdlock". "cb" might now be unreliable because other threads can now change the data that it depends on.
drivers/isdn/gigaset/ser-gigaset.c:138: lockagain: Locking "cs->cmdlock" again.
drivers/isdn/gigaset/ser-gigaset.c:140: use: Using an unreliable value of "cb" inside the second locked section.  If the data that "cb" depends on was changed by another thread, this use might be incorrect.

Error: ATOMICITY:
drivers/ide/ide-io.c:1097: lock: Locking "ide_lock".
drivers/ide/ide-io.c:1035: def: Assigning: "hwgroup->drive" = data that might be protected by the lock.
drivers/ide/ide-io.c:1093: unlock: Unlocking "ide_lock". "hwgroup->drive" might now be unreliable because other threads can now change the data that it depends on.
drivers/ide/ide-io.c:1097: lockagain: Locking "ide_lock" again.
drivers/ide/ide-io.c:983: use: Using an unreliable value of "hwgroup->drive" inside the second locked section.  If the data that "hwgroup->drive" depends on was changed by another thread, this use might be incorrect.

Error: ATOMICITY:
drivers/infiniband/hw/mthca/mthca_provider.c:753: lock: Locking "cq->lock".
drivers/infiniband/hw/mthca/mthca_provider.c:759: def: Assigning: "cq->resize_buf" = data that might be protected by the lock.
drivers/infiniband/hw/mthca/mthca_provider.c:770: unlock: Unlocking "cq->lock". "cq->resize_buf" might now be unreliable because other threads can now change the data that it depends on.
drivers/infiniband/hw/mthca/mthca_provider.c:777: lockagain: Locking "cq->lock" again.
drivers/infiniband/hw/mthca/mthca_provider.c:778: use: Using an unreliable value of "cq->resize_buf" inside the second locked section.  If the data that "cq->resize_buf" depends on was changed by another thread, this use might be incorrect.

Error: ATOMICITY:
sound/pci/emu10k1/emumpu401.c:84: lock: Locking "midi->input_lock".
sound/pci/emu10k1/emumpu401.c:89: def: Assigning: "byte" = data that might be protected by the lock.
sound/pci/emu10k1/emumpu401.c:94: unlock: Unlocking "midi->input_lock". "byte" might now be unreliable because other threads can now change the data that it depends on.
sound/pci/emu10k1/emumpu401.c:96: lockagain: Locking "midi->output_lock" again.
sound/pci/emu10k1/emumpu401.c:100: use: Using an unreliable value of "byte" inside the second locked section.  If the data that "byte" depends on was changed by another thread, this use might be incorrect.

Error: ATOMICITY:
net/xfrm/xfrm_policy.c:631: lock: Locking "policy->lock".
net/xfrm/xfrm_policy.c:638: def: Assigning: "gc_list" = data that might be protected by the lock.
net/xfrm/xfrm_policy.c:642: unlock: Unlocking "policy->lock". "gc_list" might now be unreliable because other threads can now change the data that it depends on.
net/xfrm/xfrm_policy.c:631: lockagain: Locking "policy->lock" again.
net/xfrm/xfrm_policy.c:637: use: Using an unreliable value of "gc_list" inside the second locked section.  If the data that "gc_list" depends on was changed by another thread, this use might be incorrect.

Error: ATOMICITY:
fs/dlm/lowcomms.c:1264: lock: Locking "con->writequeue_lock".
fs/dlm/lowcomms.c:1266: def: Assigning: "e" = data that might be protected by the lock.
fs/dlm/lowcomms.c:1274: unlock: Unlocking "con->writequeue_lock". "e" might now be unreliable because other threads can now change the data that it depends on.
fs/dlm/lowcomms.c:1291: lockagain: Locking "con->writequeue_lock" again.
fs/dlm/lowcomms.c:1298: use: Using an unreliable value of "e" inside the second locked section.  If the data that "e" depends on was changed by another thread, this use might be incorrect.

Error: ATOMICITY:
sound/pci/ens1370.c:2169: lock: Locking "ensoniq->reg_lock".
sound/pci/ens1370.c:2175: def: Assigning: "byte" = data that might be protected by the lock.
sound/pci/ens1370.c:2178: unlock: Unlocking "ensoniq->reg_lock". "byte" might now be unreliable because other threads can now change the data that it depends on.
sound/pci/ens1370.c:2181: lockagain: Locking "ensoniq->reg_lock" again.
sound/pci/ens1370.c:2192: use: Using an unreliable value of "byte" inside the second locked section.  If the data that "byte" depends on was changed by another thread, this use might be incorrect.

Error: ATOMICITY:
drivers/isdn/hisax/isdnl2.c:401: lock: Locking "l2->lock".
drivers/isdn/hisax/isdnl2.c:412: def: Assigning: "l2->windowar[l2->sow]" = data that might be protected by the lock.
drivers/isdn/hisax/isdnl2.c:414: unlock: Unlocking "l2->lock". "l2->windowar[l2->sow]" might now be unreliable because other threads can now change the data that it depends on.
drivers/isdn/hisax/isdnl2.c:417: lockagain: Locking "l2->lock" again.
drivers/isdn/hisax/isdnl2.c:411: use: Using an unreliable value of "l2->windowar[l2->sow]" inside the second locked section.  If the data that "l2->windowar[l2->sow]" depends on was changed by another thread, this use might be incorrect.

Error: ATOMICITY:
fs/gfs2/glock.c:1390: lock: Locking "sdp->sd_reclaim_lock".
fs/gfs2/glock.c:1395: def: Assigning: "gl" = data that might be protected by the lock.
fs/gfs2/glock.c:1398: unlock: Unlocking "sdp->sd_reclaim_lock". "gl" might now be unreliable because other threads can now change the data that it depends on.
fs/gfs2/glock.c:1403: lockagain: Locking "gl->gl_spin" again.
fs/gfs2/glock.c:1404: use: Using an unreliable value of "gl" inside the second locked section.  If the data that "gl" depends on was changed by another thread, this use might be incorrect.

Error: ATOMICITY:
sound/oss/sb_audio.c:703: lock: Locking "devc->lock".
sound/oss/sb_audio.c:704: def: Assigning: "bits" = data that might be protected by the lock.
sound/oss/sb_audio.c:708: unlock: Unlocking "devc->lock". "bits" might now be unreliable because other threads can now change the data that it depends on.
sound/oss/sb_audio.c:715: lockagain: Locking "devc->lock" again.
sound/oss/sb_audio.c:730: use: Using an unreliable value of "bits" inside the second locked section.  If the data that "bits" depends on was changed by another thread, this use might be incorrect.

Error: ATOMICITY:
sound/pci/emu10k1/emu10k1x.c:1250: lock: Locking "midi->input_lock".
sound/pci/emu10k1/emu10k1x.c:1255: def: Assigning: "byte" = data that might be protected by the lock.
sound/pci/emu10k1/emu10k1x.c:1260: unlock: Unlocking "midi->input_lock". "byte" might now be unreliable because other threads can now change the data that it depends on.
sound/pci/emu10k1/emu10k1x.c:1262: lockagain: Locking "midi->output_lock" again.
sound/pci/emu10k1/emu10k1x.c:1266: use: Using an unreliable value of "byte" inside the second locked section.  If the data that "byte" depends on was changed by another thread, this use might be incorrect.

Error: ATOMICITY:
fs/autofs4/inode.c:112: lock: Locking "dcache_lock".
fs/autofs4/inode.c:143: def: Assigning: "next" = data that might be protected by the lock.
fs/autofs4/inode.c:145: unlock: Unlocking "dcache_lock". "next" might now be unreliable because other threads can now change the data that it depends on.
fs/autofs4/inode.c:149: lockagain: Locking "dcache_lock" again.
fs/autofs4/inode.c:117: use: Using an unreliable value of "next" inside the second locked section.  If the data that "next" depends on was changed by another thread, this use might be incorrect.

Error: ATOMICITY:
fs/autofs4/inode.c:112: lock: Locking "dcache_lock".
fs/autofs4/inode.c:144: def: Assigning: "this_parent" = data that might be protected by the lock.
fs/autofs4/inode.c:145: unlock: Unlocking "dcache_lock". "this_parent" might now be unreliable because other threads can now change the data that it depends on.
fs/autofs4/inode.c:149: lockagain: Locking "dcache_lock" again.
fs/autofs4/inode.c:141: use: Using an unreliable value of "this_parent" inside the second locked section.  If the data that "this_parent" depends on was changed by another thread, this use might be incorrect.

Error: ATOMICITY:
fs/autofs4/inode.c:149: lock: Locking "dcache_lock".
fs/autofs4/inode.c:130: def: Assigning: "next" = data that might be protected by the lock.
fs/autofs4/inode.c:131: unlock: Unlocking "dcache_lock". "next" might now be unreliable because other threads can now change the data that it depends on.
fs/autofs4/inode.c:137: lockagain: Locking "dcache_lock" again.
fs/autofs4/inode.c:117: use: Using an unreliable value of "next" inside the second locked section.  If the data that "next" depends on was changed by another thread, this use might be incorrect.

Error: ATOMICITY:
fs/autofs4/inode.c:149: lock: Locking "dcache_lock".
fs/autofs4/inode.c:126: def: Assigning: "this_parent" = data that might be protected by the lock.
fs/autofs4/inode.c:131: unlock: Unlocking "dcache_lock". "this_parent" might now be unreliable because other threads can now change the data that it depends on.
fs/autofs4/inode.c:137: lockagain: Locking "dcache_lock" again.
fs/autofs4/inode.c:141: use: Using an unreliable value of "this_parent" inside the second locked section.  If the data that "this_parent" depends on was changed by another thread, this use might be incorrect.

Error: ATOMICITY:
net/packet/af_packet.c:1852: lock: Locking "po->bind_lock".
net/packet/af_packet.c:1854: def: Assigning: "num" = data that might be protected by the lock.
net/packet/af_packet.c:1861: unlock: Unlocking "po->bind_lock". "num" might now be unreliable because other threads can now change the data that it depends on.
net/packet/af_packet.c:1888: lockagain: Locking "po->bind_lock" again.
net/packet/af_packet.c:1892: use: Using an unreliable value of "num" inside the second locked section.  If the data that "num" depends on was changed by another thread, this use might be incorrect.

Error: ATOMICITY:
drivers/usb/serial/whiteheat.c:1514: lock: Locking "info->lock".
drivers/usb/serial/whiteheat.c:1520: def: Assigning: "tmp" = data that might be protected by the lock.
drivers/usb/serial/whiteheat.c:1522: unlock: Unlocking "info->lock". "tmp" might now be unreliable because other threads can now change the data that it depends on.
drivers/usb/serial/whiteheat.c:1532: lockagain: Locking "info->lock" again.
drivers/usb/serial/whiteheat.c:1533: use: Using an unreliable value of "tmp" inside the second locked section.  If the data that "tmp" depends on was changed by another thread, this use might be incorrect.

Error: ATOMICITY:
drivers/usb/serial/whiteheat.c:1514: lock: Locking "info->lock".
drivers/usb/serial/whiteheat.c:1520: def: Assigning: "tmp" = data that might be protected by the lock.
drivers/usb/serial/whiteheat.c:1522: unlock: Unlocking "info->lock". "tmp" might now be unreliable because other threads can now change the data that it depends on.
drivers/usb/serial/whiteheat.c:1549: lockagain: Locking "info->lock" again.
drivers/usb/serial/whiteheat.c:1550: use: Using an unreliable value of "tmp" inside the second locked section.  If the data that "tmp" depends on was changed by another thread, this use might be incorrect.

Error: ATOMICITY:
drivers/usb/serial/whiteheat.c:1514: lock: Locking "info->lock".
drivers/usb/serial/whiteheat.c:1520: def: Assigning: "tmp" = data that might be protected by the lock.
drivers/usb/serial/whiteheat.c:1522: unlock: Unlocking "info->lock". "tmp" might now be unreliable because other threads can now change the data that it depends on.
drivers/usb/serial/whiteheat.c:1554: lockagain: Locking "info->lock" again.
drivers/usb/serial/whiteheat.c:1555: use: Using an unreliable value of "tmp" inside the second locked section.  If the data that "tmp" depends on was changed by another thread, this use might be incorrect.

Error: ATOMICITY:
drivers/usb/serial/whiteheat.c:1514: lock: Locking "info->lock".
drivers/usb/serial/whiteheat.c:1520: def: Assigning: "tmp2" = data that might be protected by the lock.
drivers/usb/serial/whiteheat.c:1522: unlock: Unlocking "info->lock". "tmp2" might now be unreliable because other threads can now change the data that it depends on.
drivers/usb/serial/whiteheat.c:1549: lockagain: Locking "info->lock" again.
drivers/usb/serial/whiteheat.c:1520: use: Using an unreliable value of "tmp2" inside the second locked section.  If the data that "tmp2" depends on was changed by another thread, this use might be incorrect.

Error: ATOMICITY:
drivers/usb/serial/whiteheat.c:1514: lock: Locking "info->lock".
drivers/usb/serial/whiteheat.c:1520: def: Assigning: "tmp2" = data that might be protected by the lock.
drivers/usb/serial/whiteheat.c:1522: unlock: Unlocking "info->lock". "tmp2" might now be unreliable because other threads can now change the data that it depends on.
drivers/usb/serial/whiteheat.c:1554: lockagain: Locking "info->lock" again.
drivers/usb/serial/whiteheat.c:1520: use: Using an unreliable value of "tmp2" inside the second locked section.  If the data that "tmp2" depends on was changed by another thread, this use might be incorrect.

Error: ATOMICITY:
fs/ntfs/mft.c:1614: lock: Locking "mftbmp_ni->size_lock".
fs/ntfs/mft.c:1615: def: Assigning: "old_data_size" = data that might be protected by the lock.
fs/ntfs/mft.c:1630: unlock: Unlocking "mftbmp_ni->size_lock". "old_data_size" might now be unreliable because other threads can now change the data that it depends on.
fs/ntfs/mft.c:1669: lockagain: Locking "mftbmp_ni->size_lock" again.
fs/ntfs/mft.c:1674: use: Using an unreliable value of "old_data_size" inside the second locked section.  If the data that "old_data_size" depends on was changed by another thread, this use might be incorrect.

Error: ATOMICITY:
fs/ntfs/mft.c:1614: lock: Locking "mftbmp_ni->size_lock".
fs/ntfs/mft.c:1616: def: Assigning: "old_initialized_size" = data that might be protected by the lock.
fs/ntfs/mft.c:1630: unlock: Unlocking "mftbmp_ni->size_lock". "old_initialized_size" might now be unreliable because other threads can now change the data that it depends on.
fs/ntfs/mft.c:1669: lockagain: Locking "mftbmp_ni->size_lock" again.
fs/ntfs/mft.c:1670: use: Using an unreliable value of "old_initialized_size" inside the second locked section.  If the data that "old_initialized_size" depends on was changed by another thread, this use might be incorrect.

Error: ATOMICITY:
fs/ntfs/mft.c:1669: lock: Locking "mftbmp_ni->size_lock".
fs/ntfs/mft.c:1670: def: Assigning: "mftbmp_ni->initialized_size" = data that might be protected by the lock.
fs/ntfs/mft.c:1677: unlock: Unlocking "mftbmp_ni->size_lock". "mftbmp_ni->initialized_size" might now be unreliable because other threads can now change the data that it depends on.
fs/ntfs/mft.c:1683: lockagain: Locking "mftbmp_ni->size_lock" again.
fs/ntfs/mft.c:1684: use: Using an unreliable value of "mftbmp_ni->initialized_size" inside the second locked section.  If the data that "mftbmp_ni->initialized_size" depends on was changed by another thread, this use might be incorrect.

Error: ATOMICITY:
sound/pci/ens1370.c:2169: lock: Locking "ensoniq->reg_lock".
sound/pci/ens1370.c:2175: def: Assigning: "byte" = data that might be protected by the lock.
sound/pci/ens1370.c:2178: unlock: Unlocking "ensoniq->reg_lock". "byte" might now be unreliable because other threads can now change the data that it depends on.
sound/pci/ens1370.c:2181: lockagain: Locking "ensoniq->reg_lock" again.
sound/pci/ens1370.c:2192: use: Using an unreliable value of "byte" inside the second locked section.  If the data that "byte" depends on was changed by another thread, this use might be incorrect.

Error: ATOMICITY:
drivers/net/wireless/hostap/hostap_hw.c:716: lock: Locking "local->cmdlock".
drivers/net/wireless/hostap/hostap_hw.c:723: def: Assigning: "entry" = data that might be protected by the lock.
drivers/net/wireless/hostap/hostap_hw.c:728: unlock: Unlocking "local->cmdlock". "entry" might now be unreliable because other threads can now change the data that it depends on.
drivers/net/wireless/hostap/hostap_hw.c:734: lockagain: Locking "local->cmdlock" again.
drivers/net/wireless/hostap/hostap_hw.c:735: use: Using an unreliable value of "entry" inside the second locked section.  If the data that "entry" depends on was changed by another thread, this use might be incorrect.

Error: ATOMICITY:
drivers/net/eepro100.c:2098: lock: Locking "sp->lock".
drivers/net/eepro100.c:2101: def: Assigning: "sp->last_cmd" = data that might be protected by the lock.
drivers/net/eepro100.c:2132: unlock: Unlocking "sp->lock". "sp->last_cmd" might now be unreliable because other threads can now change the data that it depends on.
drivers/net/eepro100.c:2141: lockagain: Locking "sp->lock" again.
drivers/net/eepro100.c:2143: use: Using an unreliable value of "sp->last_cmd" inside the second locked section.  If the data that "sp->last_cmd" depends on was changed by another thread, this use might be incorrect.

Error: ATOMICITY:
drivers/net/eepro100.c:2098: lock: Locking "sp->lock".
drivers/net/eepro100.c:2101: def: Assigning: "sp->last_cmd" = data that might be protected by the lock.
drivers/net/eepro100.c:2132: unlock: Unlocking "sp->lock". "sp->last_cmd" might now be unreliable because other threads can now change the data that it depends on.
drivers/net/eepro100.c:2213: lockagain: Locking "sp->lock" again.
drivers/net/eepro100.c:2223: use: Using an unreliable value of "sp->last_cmd" inside the second locked section.  If the data that "sp->last_cmd" depends on was changed by another thread, this use might be incorrect.

Error: ATOMICITY:
drivers/scsi/scsi_transport_sas.c:178: lock: Locking "*q->queue_lock".
drivers/scsi/scsi_transport_sas.c:166: def: Assigning: "req" = data that might be protected by the lock.
drivers/scsi/scsi_transport_sas.c:172: unlock: Unlocking "*q->queue_lock". "req" might now be unreliable because other threads can now change the data that it depends on.
drivers/scsi/scsi_transport_sas.c:178: lockagain: Locking "*q->queue_lock" again.
drivers/scsi/scsi_transport_sas.c:180: use: Using an unreliable value of "req" inside the second locked section.  If the data that "req" depends on was changed by another thread, this use might be incorrect.

Error: ATOMICITY:
fs/inode.c:414: lock: Locking "inode_lock".
fs/inode.c:421: def: Assigning: "inode" = data that might be protected by the lock.
fs/inode.c:429: unlock: Unlocking "inode_lock". "inode" might now be unreliable because other threads can now change the data that it depends on.
fs/inode.c:434: lockagain: Locking "inode_lock" again.
fs/inode.c:439: use: Using an unreliable value of "inode" inside the second locked section.  If the data that "inode" depends on was changed by another thread, this use might be incorrect.

Error: ATOMICITY:
fs/inode.c:434: lock: Locking "inode_lock".
fs/inode.c:421: def: Assigning: "inode" = data that might be protected by the lock.
fs/inode.c:429: unlock: Unlocking "inode_lock". "inode" might now be unreliable because other threads can now change the data that it depends on.
fs/inode.c:434: lockagain: Locking "inode_lock" again.
fs/inode.c:439: use: Using an unreliable value of "inode" inside the second locked section.  If the data that "inode" depends on was changed by another thread, this use might be incorrect.

Error: ATOMICITY:
drivers/usb/serial/whiteheat.c:1445: lock: Locking "info->lock".
drivers/usb/serial/whiteheat.c:1447: def: Assigning: "tmp" = data that might be protected by the lock.
drivers/usb/serial/whiteheat.c:1452: unlock: Unlocking "info->lock". "tmp" might now be unreliable because other threads can now change the data that it depends on.
drivers/usb/serial/whiteheat.c:1455: lockagain: Locking "info->lock" again.
drivers/usb/serial/whiteheat.c:1456: use: Using an unreliable value of "tmp" inside the second locked section.  If the data that "tmp" depends on was changed by another thread, this use might be incorrect.

Error: ATOMICITY:
drivers/usb/serial/whiteheat.c:1445: lock: Locking "info->lock".
drivers/usb/serial/whiteheat.c:1447: def: Assigning: "tmp" = data that might be protected by the lock.
drivers/usb/serial/whiteheat.c:1452: unlock: Unlocking "info->lock". "tmp" might now be unreliable because other threads can now change the data that it depends on.
drivers/usb/serial/whiteheat.c:1468: lockagain: Locking "info->lock" again.
drivers/usb/serial/whiteheat.c:1469: use: Using an unreliable value of "tmp" inside the second locked section.  If the data that "tmp" depends on was changed by another thread, this use might be incorrect.

Error: ATOMICITY:
drivers/usb/serial/whiteheat.c:1445: lock: Locking "info->lock".
drivers/usb/serial/whiteheat.c:1447: def: Assigning: "tmp2" = data that might be protected by the lock.
drivers/usb/serial/whiteheat.c:1452: unlock: Unlocking "info->lock". "tmp2" might now be unreliable because other threads can now change the data that it depends on.
drivers/usb/serial/whiteheat.c:1468: lockagain: Locking "info->lock" again.
drivers/usb/serial/whiteheat.c:1447: use: Using an unreliable value of "tmp2" inside the second locked section.  If the data that "tmp2" depends on was changed by another thread, this use might be incorrect.

Error: ATOMICITY:
drivers/usb/serial/whiteheat.c:1455: lock: Locking "info->lock".
drivers/usb/serial/whiteheat.c:1457: def: Assigning: "tmp" = data that might be protected by the lock.
drivers/usb/serial/whiteheat.c:1461: unlock: Unlocking "info->lock". "tmp" might now be unreliable because other threads can now change the data that it depends on.
drivers/usb/serial/whiteheat.c:1463: lockagain: Locking "info->lock" again.
drivers/usb/serial/whiteheat.c:1464: use: Using an unreliable value of "tmp" inside the second locked section.  If the data that "tmp" depends on was changed by another thread, this use might be incorrect.

Error: ATOMICITY:
drivers/usb/serial/whiteheat.c:1455: lock: Locking "info->lock".
drivers/usb/serial/whiteheat.c:1457: def: Assigning: "tmp2" = data that might be protected by the lock.
drivers/usb/serial/whiteheat.c:1461: unlock: Unlocking "info->lock". "tmp2" might now be unreliable because other threads can now change the data that it depends on.
drivers/usb/serial/whiteheat.c:1463: lockagain: Locking "info->lock" again.
drivers/usb/serial/whiteheat.c:1457: use: Using an unreliable value of "tmp2" inside the second locked section.  If the data that "tmp2" depends on was changed by another thread, this use might be incorrect.

Error: ATOMICITY:
drivers/block/DAC960.c:5961: lock: Locking "Controller->queue_lock".
drivers/block/DAC960.c:5962: def: Assigning: "Command" = data that might be protected by the lock.
drivers/block/DAC960.c:5964: unlock: Unlocking "Controller->queue_lock". "Command" might now be unreliable because other threads can now change the data that it depends on.
drivers/block/DAC960.c:6155: lockagain: Locking "Controller->queue_lock" again.
drivers/block/DAC960.c:6156: use: Using an unreliable value of "Command" inside the second locked section.  If the data that "Command" depends on was changed by another thread, this use might be incorrect.

Error: ATOMICITY:
fs/ntfs/compress.c:713: lock: Locking "ntfs_cb_lock".
fs/ntfs/compress.c:832: def: Assigning: "cur_ofs" = data that might be protected by the lock.
fs/ntfs/compress.c:835: unlock: Unlocking "ntfs_cb_lock". "cur_ofs" might now be unreliable because other threads can now change the data that it depends on.
fs/ntfs/compress.c:713: lockagain: Locking "ntfs_cb_lock" again.
fs/ntfs/compress.c:797: use: Using an unreliable value of "cur_ofs" inside the second locked section.  If the data that "cur_ofs" depends on was changed by another thread, this use might be incorrect.

Error: ATOMICITY:
fs/ntfs/compress.c:713: lock: Locking "ntfs_cb_lock".
fs/ntfs/compress.c:888: def: Assigning: "pages[prev_cur_page]" = data that might be protected by the lock.
fs/ntfs/compress.c:750: unlock: Unlocking "ntfs_cb_lock". "pages[prev_cur_page]" might now be unreliable because other threads can now change the data that it depends on.
fs/ntfs/compress.c:713: lockagain: Locking "ntfs_cb_lock" again.
fs/ntfs/compress.c:881: use: Using an unreliable value of "pages[prev_cur_page]" inside the second locked section.  If the data that "pages[prev_cur_page]" depends on was changed by another thread, this use might be incorrect.

Error: ATOMICITY:
fs/ntfs/compress.c:713: lock: Locking "ntfs_cb_lock".
fs/ntfs/compress.c:888: def: Assigning: "pages[prev_cur_page]" = data that might be protected by the lock.
fs/ntfs/compress.c:750: unlock: Unlocking "ntfs_cb_lock". "pages[prev_cur_page]" might now be unreliable because other threads can now change the data that it depends on.
fs/ntfs/compress.c:835: unlock: Unlocking "ntfs_cb_lock". "pages[prev_cur_page]" might now be unreliable because other threads can now change the data that it depends on.
fs/ntfs/compress.c:713: lockagain: Locking "ntfs_cb_lock" again.
fs/ntfs/compress.c:881: use: Using an unreliable value of "pages[prev_cur_page]" inside the second locked section.  If the data that "pages[prev_cur_page]" depends on was changed by another thread, this use might be incorrect.

Error: ATOMICITY:
fs/ntfs/compress.c:558: lock: Locking "ni->size_lock".
fs/ntfs/compress.c:559: def: Assigning: "i_size" = data that might be protected by the lock.
fs/ntfs/compress.c:561: unlock: Unlocking "ni->size_lock". "i_size" might now be unreliable because other threads can now change the data that it depends on.
fs/ntfs/compress.c:750: unlock: Unlocking "ntfs_cb_lock". "i_size" might now be unreliable because other threads can now change the data that it depends on.
fs/ntfs/compress.c:835: unlock: Unlocking "ntfs_cb_lock". "i_size" might now be unreliable because other threads can now change the data that it depends on.
fs/ntfs/compress.c:713: lockagain: Locking "ntfs_cb_lock" again.
fs/ntfs/compress.c:866: use: Using an unreliable value of "i_size" inside the second locked section.  If the data that "i_size" depends on was changed by another thread, this use might be incorrect.

Error: ATOMICITY:
fs/ntfs/compress.c:558: lock: Locking "ni->size_lock".
fs/ntfs/compress.c:560: def: Assigning: "initialized_size" = data that might be protected by the lock.
fs/ntfs/compress.c:561: unlock: Unlocking "ni->size_lock". "initialized_size" might now be unreliable because other threads can now change the data that it depends on.
fs/ntfs/compress.c:750: unlock: Unlocking "ntfs_cb_lock". "initialized_size" might now be unreliable because other threads can now change the data that it depends on.
fs/ntfs/compress.c:835: unlock: Unlocking "ntfs_cb_lock". "initialized_size" might now be unreliable because other threads can now change the data that it depends on.
fs/ntfs/compress.c:713: lockagain: Locking "ntfs_cb_lock" again.
fs/ntfs/compress.c:866: use: Using an unreliable value of "initialized_size" inside the second locked section.  If the data that "initialized_size" depends on was changed by another thread, this use might be incorrect.

Error: ATOMICITY:
drivers/atm/he.c:1685: lock: Locking "vcc_sklist_lock".
drivers/atm/he.c:1710: def: Assigning: "vcc" = data that might be protected by the lock.
drivers/atm/he.c:1819: unlock: Unlocking "he_dev->global_lock". "vcc" might now be unreliable because other threads can now change the data that it depends on.
drivers/atm/he.c:1821: lockagain: Locking "he_dev->global_lock" again.
drivers/atm/he.c:1768: use: Using an unreliable value of "vcc" inside the second locked section.  If the data that "vcc" depends on was changed by another thread, this use might be incorrect.

Error: ATOMICITY:
drivers/message/fusion/mptlan.c:1209: lock: Locking "priv->rxfidx_lock".
drivers/message/fusion/mptlan.c:1245: def: Assigning: "(priv->RcvCtl + ctx).dma" = data that might be protected by the lock.
drivers/message/fusion/mptlan.c:1249: unlock: Unlocking "priv->rxfidx_lock". "(priv->RcvCtl + ctx).dma" might now be unreliable because other threads can now change the data that it depends on.
drivers/message/fusion/mptlan.c:1209: lockagain: Locking "priv->rxfidx_lock" again.
drivers/message/fusion/mptlan.c:1222: use: Using an unreliable value of "(priv->RcvCtl + ctx).dma" inside the second locked section.  If the data that "(priv->RcvCtl + ctx).dma" depends on was changed by another thread, this use might be incorrect.

Error: ATOMICITY:
drivers/message/fusion/mptlan.c:1209: lock: Locking "priv->rxfidx_lock".
drivers/message/fusion/mptlan.c:1246: def: Assigning: "(priv->RcvCtl + ctx).len" = data that might be protected by the lock.
drivers/message/fusion/mptlan.c:1249: unlock: Unlocking "priv->rxfidx_lock". "(priv->RcvCtl + ctx).len" might now be unreliable because other threads can now change the data that it depends on.
drivers/message/fusion/mptlan.c:1209: lockagain: Locking "priv->rxfidx_lock" again.
drivers/message/fusion/mptlan.c:1222: use: Using an unreliable value of "(priv->RcvCtl + ctx).len" inside the second locked section.  If the data that "(priv->RcvCtl + ctx).len" depends on was changed by another thread, this use might be incorrect.

Error: ATOMICITY:
drivers/message/fusion/mptlan.c:1209: lock: Locking "priv->rxfidx_lock".
drivers/message/fusion/mptlan.c:1227: def: Assigning: "(priv->RcvCtl + ctx).skb" = data that might be protected by the lock.
drivers/message/fusion/mptlan.c:1237: unlock: Unlocking "priv->rxfidx_lock". "(priv->RcvCtl + ctx).skb" might now be unreliable because other threads can now change the data that it depends on.
drivers/message/fusion/mptlan.c:1209: lockagain: Locking "priv->rxfidx_lock" again.
drivers/message/fusion/mptlan.c:1220: use: Using an unreliable value of "(priv->RcvCtl + ctx).skb" inside the second locked section.  If the data that "(priv->RcvCtl + ctx).skb" depends on was changed by another thread, this use might be incorrect.

Error: ATOMICITY:
drivers/message/fusion/mptlan.c:1209: lock: Locking "priv->rxfidx_lock".
drivers/message/fusion/mptlan.c:1244: def: Assigning: "(priv->RcvCtl + ctx).skb" = data that might be protected by the lock.
drivers/message/fusion/mptlan.c:1249: unlock: Unlocking "priv->rxfidx_lock". "(priv->RcvCtl + ctx).skb" might now be unreliable because other threads can now change the data that it depends on.
drivers/message/fusion/mptlan.c:1209: lockagain: Locking "priv->rxfidx_lock" again.
drivers/message/fusion/mptlan.c:1220: use: Using an unreliable value of "(priv->RcvCtl + ctx).skb" inside the second locked section.  If the data that "(priv->RcvCtl + ctx).skb" depends on was changed by another thread, this use might be incorrect.

Error: ATOMICITY:
sound/core/seq/seq_fifo.c:185: lock: Locking "f->lock".
sound/core/seq/seq_fifo.c:185: def: Assigning: "flags" = data that might be protected by the lock.
sound/core/seq/seq_fifo.c:194: unlock: Unlocking "f->lock". "flags" might now be unreliable because other threads can now change the data that it depends on.
sound/core/seq/seq_fifo.c:196: lockagain: Locking "f->lock" again.
sound/core/seq/seq_fifo.c:189: use: Using an unreliable value of "flags" inside the second locked section.  If the data that "flags" depends on was changed by another thread, this use might be incorrect.

Error: ATOMICITY:
sound/core/seq/seq_fifo.c:185: lock: Locking "f->lock".
sound/core/seq/seq_fifo.c:185: def: Assigning: "flags" = data that might be protected by the lock.
sound/core/seq/seq_fifo.c:194: unlock: Unlocking "f->lock". "flags" might now be unreliable because other threads can now change the data that it depends on.
sound/core/seq/seq_fifo.c:196: lockagain: Locking "f->lock" again.
sound/core/seq/seq_fifo.c:199: use: Using an unreliable value of "flags" inside the second locked section.  If the data that "flags" depends on was changed by another thread, this use might be incorrect.

Error: ATOMICITY:
sound/core/seq/seq_fifo.c:185: lock: Locking "f->lock".
sound/core/seq/seq_fifo.c:185: def: Assigning: "flags" = data that might be protected by the lock.
sound/core/seq/seq_fifo.c:194: unlock: Unlocking "f->lock". "flags" might now be unreliable because other threads can now change the data that it depends on.
sound/core/seq/seq_fifo.c:196: lockagain: Locking "f->lock" again.
sound/core/seq/seq_fifo.c:203: use: Using an unreliable value of "flags" inside the second locked section.  If the data that "flags" depends on was changed by another thread, this use might be incorrect.

Error: ATOMICITY:
drivers/ieee1394/eth1394.c:1134: lock: Locking "pdg->lock".
drivers/ieee1394/eth1394.c:1195: def: Assigning: "skb" = data that might be protected by the lock.
drivers/ieee1394/eth1394.c:1197: unlock: Unlocking "pdg->lock". "skb" might now be unreliable because other threads can now change the data that it depends on.
drivers/ieee1394/eth1394.c:1217: lockagain: Locking "priv->lock" again.
drivers/ieee1394/eth1394.c:1222: use: Using an unreliable value of "skb" inside the second locked section.  If the data that "skb" depends on was changed by another thread, this use might be incorrect.

Error: ATOMICITY:
drivers/ieee1394/eth1394.c:1134: lock: Locking "pdg->lock".
drivers/ieee1394/eth1394.c:1195: def: Assigning: "skb" = data that might be protected by the lock.
drivers/ieee1394/eth1394.c:1197: unlock: Unlocking "pdg->lock". "skb" might now be unreliable because other threads can now change the data that it depends on.
drivers/ieee1394/eth1394.c:1217: lockagain: Locking "priv->lock" again.
drivers/ieee1394/eth1394.c:1223: use: Using an unreliable value of "skb" inside the second locked section.  If the data that "skb" depends on was changed by another thread, this use might be incorrect.

Error: ATOMICITY:
drivers/usb/serial/oti6858.c:480: lock: Locking "priv->lock".
drivers/usb/serial/oti6858.c:483: def: Assigning: "control" = data that might be protected by the lock.
drivers/usb/serial/oti6858.c:484: unlock: Unlocking "priv->lock". "control" might now be unreliable because other threads can now change the data that it depends on.
drivers/usb/serial/oti6858.c:559: lockagain: Locking "priv->lock" again.
drivers/usb/serial/oti6858.c:564: use: Using an unreliable value of "control" inside the second locked section.  If the data that "control" depends on was changed by another thread, this use might be incorrect.

Error: ATOMICITY:
drivers/usb/serial/oti6858.c:480: lock: Locking "priv->lock".
drivers/usb/serial/oti6858.c:482: def: Assigning: "frame_fmt" = data that might be protected by the lock.
drivers/usb/serial/oti6858.c:484: unlock: Unlocking "priv->lock". "frame_fmt" might now be unreliable because other threads can now change the data that it depends on.
drivers/usb/serial/oti6858.c:559: lockagain: Locking "priv->lock" again.
drivers/usb/serial/oti6858.c:565: use: Using an unreliable value of "frame_fmt" inside the second locked section.  If the data that "frame_fmt" depends on was changed by another thread, this use might be incorrect.

Error: ATOMICITY:
drivers/net/wireless/iwlwifi/iwl-tx.c:790: lock: Locking "priv->lock".
drivers/net/wireless/iwlwifi/iwl-tx.c:804: def: Assigning: "fc" = data that might be protected by the lock.
drivers/net/wireless/iwlwifi/iwl-tx.c:826: unlock: Unlocking "priv->lock". "fc" might now be unreliable because other threads can now change the data that it depends on.
drivers/net/wireless/iwlwifi/iwl-tx.c:863: lockagain: Locking "priv->lock" again.
drivers/net/wireless/iwlwifi/iwl-tx.c:946: use: Using an unreliable value of "fc" inside the second locked section.  If the data that "fc" depends on was changed by another thread, this use might be incorrect.

Error: ATOMICITY:
drivers/net/wireless/iwlwifi/iwl-tx.c:790: lock: Locking "priv->lock".
drivers/net/wireless/iwlwifi/iwl-tx.c:802: def: Assigning: "unicast" = data that might be protected by the lock.
drivers/net/wireless/iwlwifi/iwl-tx.c:826: unlock: Unlocking "priv->lock". "unicast" might now be unreliable because other threads can now change the data that it depends on.
drivers/net/wireless/iwlwifi/iwl-tx.c:863: lockagain: Locking "priv->lock" again.
drivers/net/wireless/iwlwifi/iwl-tx.c:943: use: Using an unreliable value of "unicast" inside the second locked section.  If the data that "unicast" depends on was changed by another thread, this use might be incorrect.

Error: ATOMICITY:
drivers/block/DAC960.c:6224: lock: Locking "Controller->queue_lock".
drivers/block/DAC960.c:6225: def: Assigning: "Command" = data that might be protected by the lock.
drivers/block/DAC960.c:6227: unlock: Unlocking "Controller->queue_lock". "Command" might now be unreliable because other threads can now change the data that it depends on.
drivers/block/DAC960.c:6418: lockagain: Locking "Controller->queue_lock" again.
drivers/block/DAC960.c:6419: use: Using an unreliable value of "Command" inside the second locked section.  If the data that "Command" depends on was changed by another thread, this use might be incorrect.

Error: ATOMICITY:
fs/dcache.c:548: lock: Locking "sb_lock".
fs/dcache.c:549: def: Assigning: "sb" = data that might be protected by the lock.
fs/dcache.c:562: unlock: Unlocking "sb_lock". "sb" might now be unreliable because other threads can now change the data that it depends on.
fs/dcache.c:578: unlock: Unlocking "dcache_lock". "sb" might now be unreliable because other threads can now change the data that it depends on.
fs/dcache.c:586: lockagain: Locking "sb_lock" again.
fs/dcache.c:592: use: Using an unreliable value of "sb" inside the second locked section.  If the data that "sb" depends on was changed by another thread, this use might be incorrect.

Error: ATOMICITY:
drivers/isdn/gigaset/usb-gigaset.c:463: lock: Locking "cs->cmdlock".
drivers/isdn/gigaset/usb-gigaset.c:470: def: Assigning: "cs->curlen" = data that might be protected by the lock.
drivers/isdn/gigaset/usb-gigaset.c:475: unlock: Unlocking "cs->cmdlock". "cs->curlen" might now be unreliable because other threads can now change the data that it depends on.
drivers/isdn/gigaset/usb-gigaset.c:497: unlock: Unlocking "cs->lock". "cs->curlen" might now be unreliable because other threads can now change the data that it depends on.
drivers/isdn/gigaset/usb-gigaset.c:463: lockagain: Locking "cs->cmdlock" again.
drivers/isdn/gigaset/usb-gigaset.c:465: use: Using an unreliable value of "cs->curlen" inside the second locked section.  If the data that "cs->curlen" depends on was changed by another thread, this use might be incorrect.

Error: ATOMICITY:
drivers/isdn/gigaset/usb-gigaset.c:463: lock: Locking "cs->cmdlock".
drivers/isdn/gigaset/usb-gigaset.c:473: def: Assigning: "cs->curlen" = data that might be protected by the lock.
drivers/isdn/gigaset/usb-gigaset.c:475: unlock: Unlocking "cs->cmdlock". "cs->curlen" might now be unreliable because other threads can now change the data that it depends on.
drivers/isdn/gigaset/usb-gigaset.c:497: unlock: Unlocking "cs->lock". "cs->curlen" might now be unreliable because other threads can now change the data that it depends on.
drivers/isdn/gigaset/usb-gigaset.c:463: lockagain: Locking "cs->cmdlock" again.
drivers/isdn/gigaset/usb-gigaset.c:465: use: Using an unreliable value of "cs->curlen" inside the second locked section.  If the data that "cs->curlen" depends on was changed by another thread, this use might be incorrect.

Error: ATOMICITY:
kernel/timer.c:836: lock: Locking "base->lock".
kernel/timer.c:839: def: Assigning: "head" = data that might be protected by the lock.
kernel/timer.c:864: unlock: Unlocking "base->lock". "head" might now be unreliable because other threads can now change the data that it depends on.
kernel/timer.c:877: lockagain: Locking "base->lock" again.
kernel/timer.c:852: use: Using an unreliable value of "head" inside the second locked section.  If the data that "head" depends on was changed by another thread, this use might be incorrect.

Error: ATOMICITY:
drivers/scsi/eata.c:1100: lock: Locking "driver_lock".
drivers/scsi/eata.c:1186: def: Assigning: "dma_channel" = data that might be protected by the lock.
drivers/scsi/eata.c:1268: unlock: Unlocking "driver_lock". "dma_channel" might now be unreliable because other threads can now change the data that it depends on.
drivers/scsi/eata.c:1270: lockagain: Locking "driver_lock" again.
drivers/scsi/eata.c:1280: use: Using an unreliable value of "dma_channel" inside the second locked section.  If the data that "dma_channel" depends on was changed by another thread, this use might be incorrect.

Error: ATOMICITY:
drivers/scsi/eata.c:1100: lock: Locking "driver_lock".
drivers/scsi/eata.c:1186: def: Assigning: "dma_channel" = data that might be protected by the lock.
drivers/scsi/eata.c:1268: unlock: Unlocking "driver_lock". "dma_channel" might now be unreliable because other threads can now change the data that it depends on.
drivers/scsi/eata.c:1270: lockagain: Locking "driver_lock" again.
drivers/scsi/eata.c:1438: use: Using an unreliable value of "dma_channel" inside the second locked section.  If the data that "dma_channel" depends on was changed by another thread, this use might be incorrect.

Error: ATOMICITY:
drivers/scsi/eata.c:1100: lock: Locking "driver_lock".
drivers/scsi/eata.c:1125: def: Assigning: "info.queue_size" = data that might be protected by the lock.
drivers/scsi/eata.c:1268: unlock: Unlocking "driver_lock". "info.queue_size" might now be unreliable because other threads can now change the data that it depends on.
drivers/scsi/eata.c:1270: lockagain: Locking "driver_lock" again.
drivers/scsi/eata.c:1284: use: Using an unreliable value of "(ushort)info.queue_size" inside the second locked section.  If the data that "(ushort)info.queue_size" depends on was changed by another thread, this use might be incorrect.

Error: ATOMICITY:
drivers/scsi/eata.c:1100: lock: Locking "driver_lock".
drivers/scsi/eata.c:1124: def: Assigning: "info.scatt_size" = data that might be protected by the lock.
drivers/scsi/eata.c:1268: unlock: Unlocking "driver_lock". "info.scatt_size" might now be unreliable because other threads can now change the data that it depends on.
drivers/scsi/eata.c:1270: lockagain: Locking "driver_lock" again.
drivers/scsi/eata.c:1282: use: Using an unreliable value of "(ushort)info.scatt_size" inside the second locked section.  If the data that "(ushort)info.scatt_size" depends on was changed by another thread, this use might be incorrect.

Error: ATOMICITY:
drivers/scsi/eata.c:1100: lock: Locking "driver_lock".
drivers/scsi/eata.c:1219: def: Assigning: "irq" = data that might be protected by the lock.
drivers/scsi/eata.c:1268: unlock: Unlocking "driver_lock". "irq" might now be unreliable because other threads can now change the data that it depends on.
drivers/scsi/eata.c:1270: lockagain: Locking "driver_lock" again.
drivers/scsi/eata.c:1281: use: Using an unreliable value of "irq" inside the second locked section.  If the data that "irq" depends on was changed by another thread, this use might be incorrect.

Error: ATOMICITY:
drivers/scsi/eata.c:1100: lock: Locking "driver_lock".
drivers/scsi/eata.c:1219: def: Assigning: "irq" = data that might be protected by the lock.
drivers/scsi/eata.c:1268: unlock: Unlocking "driver_lock". "irq" might now be unreliable because other threads can now change the data that it depends on.
drivers/scsi/eata.c:1270: lockagain: Locking "driver_lock" again.
drivers/scsi/eata.c:1440: use: Using an unreliable value of "irq" inside the second locked section.  If the data that "irq" depends on was changed by another thread, this use might be incorrect.

Error: ATOMICITY:
drivers/scsi/eata.c:1100: lock: Locking "driver_lock".
drivers/scsi/eata.c:1150: def: Assigning: "is_pci" = data that might be protected by the lock.
drivers/scsi/eata.c:1268: unlock: Unlocking "driver_lock". "is_pci" might now be unreliable because other threads can now change the data that it depends on.
drivers/scsi/eata.c:1270: lockagain: Locking "driver_lock" again.
drivers/scsi/eata.c:1292: use: Using an unreliable value of "is_pci" inside the second locked section.  If the data that "is_pci" depends on was changed by another thread, this use might be incorrect.

Error: ATOMICITY:
drivers/scsi/eata.c:1100: lock: Locking "driver_lock".
drivers/scsi/eata.c:1208: def: Assigning: "pdev" = data that might be protected by the lock.
drivers/scsi/eata.c:1268: unlock: Unlocking "driver_lock". "pdev" might now be unreliable because other threads can now change the data that it depends on.
drivers/scsi/eata.c:1270: lockagain: Locking "driver_lock" again.
drivers/scsi/eata.c:1293: use: Using an unreliable value of "pdev" inside the second locked section.  If the data that "pdev" depends on was changed by another thread, this use might be incorrect.

Error: ATOMICITY:
drivers/scsi/eata.c:1100: lock: Locking "driver_lock".
drivers/scsi/eata.c:1141: def: Assigning: "protocol_rev" = data that might be protected by the lock.
drivers/scsi/eata.c:1268: unlock: Unlocking "driver_lock". "protocol_rev" might now be unreliable because other threads can now change the data that it depends on.
drivers/scsi/eata.c:1270: lockagain: Locking "driver_lock" again.
drivers/scsi/eata.c:1291: use: Using an unreliable value of "protocol_rev" inside the second locked section.  If the data that "protocol_rev" depends on was changed by another thread, this use might be incorrect.

Error: ATOMICITY:
drivers/scsi/eata.c:1100: lock: Locking "driver_lock".
drivers/scsi/eata.c:1185: def: Assigning: "subversion" = data that might be protected by the lock.
drivers/scsi/eata.c:1268: unlock: Unlocking "driver_lock". "subversion" might now be unreliable because other threads can now change the data that it depends on.
drivers/scsi/eata.c:1270: lockagain: Locking "driver_lock" again.
drivers/scsi/eata.c:1290: use: Using an unreliable value of "subversion" inside the second locked section.  If the data that "subversion" depends on was changed by another thread, this use might be incorrect.

Error: ATOMICITY:
drivers/usb/serial/garmin_gps.c:515: lock: Locking "garmin_data_p->lock".
drivers/usb/serial/garmin_gps.c:517: def: Assigning: "size" = data that might be protected by the lock.
drivers/usb/serial/garmin_gps.c:520: unlock: Unlocking "garmin_data_p->lock". "size" might now be unreliable because other threads can now change the data that it depends on.
drivers/usb/serial/garmin_gps.c:587: lockagain: Locking "garmin_data_p->lock" again.
drivers/usb/serial/garmin_gps.c:589: use: Using an unreliable value of "size" inside the second locked section.  If the data that "size" depends on was changed by another thread, this use might be incorrect.

Error: ATOMICITY:
drivers/block/pktcdvd.c:1309: lock: Locking "pd->lock".
drivers/block/pktcdvd.c:1319: def: Assigning: "zone" = data that might be protected by the lock.
drivers/block/pktcdvd.c:1337: unlock: Unlocking "pd->lock". "zone" might now be unreliable because other threads can now change the data that it depends on.
drivers/block/pktcdvd.c:1354: lockagain: Locking "pd->lock" again.
drivers/block/pktcdvd.c:1356: use: Using an unreliable value of "zone" inside the second locked section.  If the data that "zone" depends on was changed by another thread, this use might be incorrect.

Error: ATOMICITY:
fs/drop_caches.c:40: lock: Locking "sb_lock".
fs/drop_caches.c:42: def: Assigning: "sb" = data that might be protected by the lock.
fs/drop_caches.c:44: unlock: Unlocking "sb_lock". "sb" might now be unreliable because other threads can now change the data that it depends on.
fs/drop_caches.c:49: lockagain: Locking "sb_lock" again.
fs/drop_caches.c:50: use: Using an unreliable value of "sb" inside the second locked section.  If the data that "sb" depends on was changed by another thread, this use might be incorrect.

Error: ATOMICITY:
fs/drop_caches.c:49: lock: Locking "sb_lock".
fs/drop_caches.c:42: def: Assigning: "sb" = data that might be protected by the lock.
fs/drop_caches.c:44: unlock: Unlocking "sb_lock". "sb" might now be unreliable because other threads can now change the data that it depends on.
fs/drop_caches.c:49: lockagain: Locking "sb_lock" again.
fs/drop_caches.c:50: use: Using an unreliable value of "sb" inside the second locked section.  If the data that "sb" depends on was changed by another thread, this use might be incorrect.

Error: ATOMICITY:
drivers/net/usb/usbnet.c:268: lock: Locking "list->lock".
drivers/net/usb/usbnet.c:268: def: Assigning: "flags" = data that might be protected by the lock.
drivers/net/usb/usbnet.c:270: unlock: Unlocking "list->lock". "flags" might now be unreliable because other threads can now change the data that it depends on.
drivers/net/usb/usbnet.c:271: lockagain: Locking "dev->done.lock" again.
drivers/net/usb/usbnet.c:275: use: Using an unreliable value of "flags" inside the second locked section.  If the data that "flags" depends on was changed by another thread, this use might be incorrect.

Error: ATOMICITY:
fs/ocfs2/dlm/dlmthread.c:517: lock: Locking "dlm->ast_lock".
fs/ocfs2/dlm/dlmthread.c:519: def: Assigning: "lock" = data that might be protected by the lock.
fs/ocfs2/dlm/dlmthread.c:531: unlock: Unlocking "dlm->ast_lock". "lock" might now be unreliable because other threads can now change the data that it depends on.
fs/ocfs2/dlm/dlmthread.c:540: lockagain: Locking "dlm->ast_lock" again.
fs/ocfs2/dlm/dlmthread.c:553: use: Using an unreliable value of "lock" inside the second locked section.  If the data that "lock" depends on was changed by another thread, this use might be incorrect.

Error: ATOMICITY:
fs/ocfs2/dlm/dlmthread.c:517: lock: Locking "dlm->ast_lock".
fs/ocfs2/dlm/dlmthread.c:523: def: Assigning: "res" = data that might be protected by the lock.
fs/ocfs2/dlm/dlmthread.c:531: unlock: Unlocking "dlm->ast_lock". "res" might now be unreliable because other threads can now change the data that it depends on.
fs/ocfs2/dlm/dlmthread.c:540: lockagain: Locking "dlm->ast_lock" again.
fs/ocfs2/dlm/dlmthread.c:554: use: Using an unreliable value of "res" inside the second locked section.  If the data that "res" depends on was changed by another thread, this use might be incorrect.

Error: ATOMICITY:
fs/ocfs2/dlm/dlmthread.c:540: lock: Locking "dlm->ast_lock".
fs/ocfs2/dlm/dlmthread.c:519: def: Assigning: "lock" = data that might be protected by the lock.
fs/ocfs2/dlm/dlmthread.c:531: unlock: Unlocking "dlm->ast_lock". "lock" might now be unreliable because other threads can now change the data that it depends on.
fs/ocfs2/dlm/dlmthread.c:540: lockagain: Locking "dlm->ast_lock" again.
fs/ocfs2/dlm/dlmthread.c:553: use: Using an unreliable value of "lock" inside the second locked section.  If the data that "lock" depends on was changed by another thread, this use might be incorrect.

Error: ATOMICITY:
fs/ocfs2/dlm/dlmthread.c:540: lock: Locking "dlm->ast_lock".
fs/ocfs2/dlm/dlmthread.c:523: def: Assigning: "res" = data that might be protected by the lock.
fs/ocfs2/dlm/dlmthread.c:531: unlock: Unlocking "dlm->ast_lock". "res" might now be unreliable because other threads can now change the data that it depends on.
fs/ocfs2/dlm/dlmthread.c:540: lockagain: Locking "dlm->ast_lock" again.
fs/ocfs2/dlm/dlmthread.c:554: use: Using an unreliable value of "res" inside the second locked section.  If the data that "res" depends on was changed by another thread, this use might be incorrect.

Error: ATOMICITY:
fs/ocfs2/dlm/dlmthread.c:540: lock: Locking "dlm->ast_lock".
fs/ocfs2/dlm/dlmthread.c:558: def: Assigning: "lock" = data that might be protected by the lock.
fs/ocfs2/dlm/dlmthread.c:571: unlock: Unlocking "lock->spinlock". "lock" might now be unreliable because other threads can now change the data that it depends on.
fs/ocfs2/dlm/dlmthread.c:576: unlock: Unlocking "dlm->ast_lock". "lock" might now be unreliable because other threads can now change the data that it depends on.
fs/ocfs2/dlm/dlmthread.c:588: lockagain: Locking "dlm->ast_lock" again.
fs/ocfs2/dlm/dlmthread.c:601: use: Using an unreliable value of "lock" inside the second locked section.  If the data that "lock" depends on was changed by another thread, this use might be incorrect.

Error: ATOMICITY:
fs/ocfs2/dlm/dlmthread.c:540: lock: Locking "dlm->ast_lock".
fs/ocfs2/dlm/dlmthread.c:562: def: Assigning: "res" = data that might be protected by the lock.
fs/ocfs2/dlm/dlmthread.c:571: unlock: Unlocking "lock->spinlock". "res" might now be unreliable because other threads can now change the data that it depends on.
fs/ocfs2/dlm/dlmthread.c:576: unlock: Unlocking "dlm->ast_lock". "res" might now be unreliable because other threads can now change the data that it depends on.
fs/ocfs2/dlm/dlmthread.c:588: lockagain: Locking "dlm->ast_lock" again.
fs/ocfs2/dlm/dlmthread.c:602: use: Using an unreliable value of "res" inside the second locked section.  If the data that "res" depends on was changed by another thread, this use might be incorrect.

Error: ATOMICITY:
fs/ocfs2/dlm/dlmthread.c:588: lock: Locking "dlm->ast_lock".
fs/ocfs2/dlm/dlmthread.c:558: def: Assigning: "lock" = data that might be protected by the lock.
fs/ocfs2/dlm/dlmthread.c:571: unlock: Unlocking "lock->spinlock". "lock" might now be unreliable because other threads can now change the data that it depends on.
fs/ocfs2/dlm/dlmthread.c:576: unlock: Unlocking "dlm->ast_lock". "lock" might now be unreliable because other threads can now change the data that it depends on.
fs/ocfs2/dlm/dlmthread.c:588: lockagain: Locking "dlm->ast_lock" again.
fs/ocfs2/dlm/dlmthread.c:601: use: Using an unreliable value of "lock" inside the second locked section.  If the data that "lock" depends on was changed by another thread, this use might be incorrect.

Error: ATOMICITY:
fs/ocfs2/dlm/dlmthread.c:588: lock: Locking "dlm->ast_lock".
fs/ocfs2/dlm/dlmthread.c:562: def: Assigning: "res" = data that might be protected by the lock.
fs/ocfs2/dlm/dlmthread.c:571: unlock: Unlocking "lock->spinlock". "res" might now be unreliable because other threads can now change the data that it depends on.
fs/ocfs2/dlm/dlmthread.c:576: unlock: Unlocking "dlm->ast_lock". "res" might now be unreliable because other threads can now change the data that it depends on.
fs/ocfs2/dlm/dlmthread.c:588: lockagain: Locking "dlm->ast_lock" again.
fs/ocfs2/dlm/dlmthread.c:602: use: Using an unreliable value of "res" inside the second locked section.  If the data that "res" depends on was changed by another thread, this use might be incorrect.

Error: ATOMICITY:
drivers/char/hvc_console.c:584: lock: Locking "hp->lock".
drivers/char/hvc_console.c:598: def: Assigning: "tty" = data that might be protected by the lock.
drivers/char/hvc_console.c:626: unlock: Unlocking "hp->lock". "tty" might now be unreliable because other threads can now change the data that it depends on.
drivers/char/hvc_console.c:628: lockagain: Locking "hp->lock" again.
drivers/char/hvc_console.c:663: use: Using an unreliable value of "tty" inside the second locked section.  If the data that "tty" depends on was changed by another thread, this use might be incorrect.

Error: ATOMICITY:
drivers/video/console/vgacon.c:876: lock: Locking "vga_lock".
drivers/video/console/vgacon.c:878: def: Assigning: "vga_state.CrtCtrlIndex" = data that might be protected by the lock.
drivers/video/console/vgacon.c:880: unlock: Unlocking "vga_lock". "vga_state.CrtCtrlIndex" might now be unreliable because other threads can now change the data that it depends on.
drivers/video/console/vgacon.c:903: lockagain: Locking "vga_lock" again.
drivers/video/console/vgacon.c:938: use: Using an unreliable value of "vga_state.CrtCtrlIndex" inside the second locked section.  If the data that "vga_state.CrtCtrlIndex" depends on was changed by another thread, this use might be incorrect.

Error: ATOMICITY:
drivers/video/console/vgacon.c:876: lock: Locking "vga_lock".
drivers/video/console/vgacon.c:877: def: Assigning: "vga_state.SeqCtrlIndex" = data that might be protected by the lock.
drivers/video/console/vgacon.c:880: unlock: Unlocking "vga_lock". "vga_state.SeqCtrlIndex" might now be unreliable because other threads can now change the data that it depends on.
drivers/video/console/vgacon.c:903: lockagain: Locking "vga_lock" again.
drivers/video/console/vgacon.c:937: use: Using an unreliable value of "vga_state.SeqCtrlIndex" inside the second locked section.  If the data that "vga_state.SeqCtrlIndex" depends on was changed by another thread, this use might be incorrect.

Error: ATOMICITY:
drivers/char/ipmi/ipmi_devintf.c:300: lock: Locking "priv->recv_msg_lock".
drivers/char/ipmi/ipmi_devintf.c:306: def: Assigning: "entry" = data that might be protected by the lock.
drivers/char/ipmi/ipmi_devintf.c:309: unlock: Unlocking "priv->recv_msg_lock". "entry" might now be unreliable because other threads can now change the data that it depends on.
drivers/char/ipmi/ipmi_devintf.c:363: lockagain: Locking "priv->recv_msg_lock" again.
drivers/char/ipmi/ipmi_devintf.c:364: use: Using an unreliable value of "entry" inside the second locked section.  If the data that "entry" depends on was changed by another thread, this use might be incorrect.

Error: ATOMICITY:
drivers/net/wireless/hostap/hostap_hw.c:716: lock: Locking "local->cmdlock".
drivers/net/wireless/hostap/hostap_hw.c:723: def: Assigning: "entry" = data that might be protected by the lock.
drivers/net/wireless/hostap/hostap_hw.c:728: unlock: Unlocking "local->cmdlock". "entry" might now be unreliable because other threads can now change the data that it depends on.
drivers/net/wireless/hostap/hostap_hw.c:734: lockagain: Locking "local->cmdlock" again.
drivers/net/wireless/hostap/hostap_hw.c:735: use: Using an unreliable value of "entry" inside the second locked section.  If the data that "entry" depends on was changed by another thread, this use might be incorrect.

Error: ATOMICITY:
drivers/usb/serial/cypress_m8.c:1047: lock: Locking "priv->lock".
drivers/usb/serial/cypress_m8.c:1050: def: Assigning: "*tty->termios" = data that might be protected by the lock.
drivers/usb/serial/cypress_m8.c:1070: unlock: Unlocking "priv->lock". "*tty->termios" might now be unreliable because other threads can now change the data that it depends on.
drivers/usb/serial/cypress_m8.c:1080: lockagain: Locking "priv->lock" again.
drivers/usb/serial/cypress_m8.c:1081: use: Using an unreliable value of "*tty->termios" inside the second locked section.  If the data that "*tty->termios" depends on was changed by another thread, this use might be incorrect.

Error: ATOMICITY:
drivers/net/wireless/iwlwifi/iwl3945-base.c:2541: lock: Locking "priv->lock".
drivers/net/wireless/iwlwifi/iwl3945-base.c:2555: def: Assigning: "fc" = data that might be protected by the lock.
drivers/net/wireless/iwlwifi/iwl3945-base.c:2575: unlock: Unlocking "priv->lock". "fc" might now be unreliable because other threads can now change the data that it depends on.
drivers/net/wireless/iwlwifi/iwl3945-base.c:2606: lockagain: Locking "priv->lock" again.
drivers/net/wireless/iwlwifi/iwl3945-base.c:2711: use: Using an unreliable value of "fc" inside the second locked section.  If the data that "fc" depends on was changed by another thread, this use might be incorrect.

Error: ATOMICITY:
drivers/net/wireless/iwlwifi/iwl3945-base.c:2541: lock: Locking "priv->lock".
drivers/net/wireless/iwlwifi/iwl3945-base.c:2552: def: Assigning: "unicast" = data that might be protected by the lock.
drivers/net/wireless/iwlwifi/iwl3945-base.c:2575: unlock: Unlocking "priv->lock". "unicast" might now be unreliable because other threads can now change the data that it depends on.
drivers/net/wireless/iwlwifi/iwl3945-base.c:2606: lockagain: Locking "priv->lock" again.
drivers/net/wireless/iwlwifi/iwl3945-base.c:2691: use: Using an unreliable value of "unicast" inside the second locked section.  If the data that "unicast" depends on was changed by another thread, this use might be incorrect.

Error: ATOMICITY:
drivers/media/video/pwc/pwc-if.c:524: lock: Locking "pdev->ptrlock".
drivers/media/video/pwc/pwc-if.c:539: def: Assigning: "pdev->read_frame" = data that might be protected by the lock.
drivers/media/video/pwc/pwc-if.c:549: unlock: Unlocking "pdev->ptrlock". "pdev->read_frame" might now be unreliable because other threads can now change the data that it depends on.
drivers/media/video/pwc/pwc-if.c:551: lockagain: Locking "pdev->ptrlock" again.
drivers/media/video/pwc/pwc-if.c:555: use: Using an unreliable value of "pdev->read_frame" inside the second locked section.  If the data that "pdev->read_frame" depends on was changed by another thread, this use might be incorrect.

Error: ATOMICITY:
drivers/media/video/pwc/pwc-if.c:524: lock: Locking "pdev->ptrlock".
drivers/media/video/pwc/pwc-if.c:539: def: Assigning: "pdev->read_frame" = data that might be protected by the lock.
drivers/media/video/pwc/pwc-if.c:549: unlock: Unlocking "pdev->ptrlock". "pdev->read_frame" might now be unreliable because other threads can now change the data that it depends on.
drivers/media/video/pwc/pwc-if.c:551: lockagain: Locking "pdev->ptrlock" again.
drivers/media/video/pwc/pwc-if.c:559: use: Using an unreliable value of "pdev->read_frame" inside the second locked section.  If the data that "pdev->read_frame" depends on was changed by another thread, this use might be incorrect.

Error: ATOMICITY:
drivers/net/tulip/de4x5.c:1498: lock: Locking "lp->lock".
drivers/net/tulip/de4x5.c:1510: def: Assigning: "skb" = data that might be protected by the lock.
drivers/net/tulip/de4x5.c:1511: unlock: Unlocking "lp->lock". "skb" might now be unreliable because other threads can now change the data that it depends on.
drivers/net/tulip/de4x5.c:1498: lockagain: Locking "lp->lock" again.
drivers/net/tulip/de4x5.c:1500: use: Using an unreliable value of "skb" inside the second locked section.  If the data that "skb" depends on was changed by another thread, this use might be incorrect.

Error: ATOMICITY:
drivers/net/wireless/libertas_tf/cmd.c:590: lock: Locking "priv->driver_lock".
drivers/net/wireless/libertas_tf/cmd.c:601: def: Assigning: "result" = data that might be protected by the lock.
drivers/net/wireless/libertas_tf/cmd.c:652: unlock: Unlocking "priv->driver_lock". "result" might now be unreliable because other threads can now change the data that it depends on.
drivers/net/wireless/libertas_tf/cmd.c:658: lockagain: Locking "priv->driver_lock" again.
drivers/net/wireless/libertas_tf/cmd.c:662: use: Using an unreliable value of "result" inside the second locked section.  If the data that "result" depends on was changed by another thread, this use might be incorrect.

Error: ATOMICITY:
kernel/sched_rt.c:1194: lock: Locking "src_rq->lock".
kernel/sched_rt.c:1197: def: Assigning: "next" = data that might be protected by the lock.
kernel/sched_rt.c:1251: unlock: Unlocking "src_rq->lock". "next" might now be unreliable because other threads can now change the data that it depends on.
kernel/sched_rt.c:1194: lockagain: Locking "src_rq->lock" again.
kernel/sched_rt.c:1195: use: Using an unreliable value of "next" inside the second locked section.  If the data that "next" depends on was changed by another thread, this use might be incorrect.

Error: ATOMICITY:
drivers/char/epca.c:1385: lock: Locking "epca_lock".
drivers/char/epca.c:1399: def: Assigning: "ch->m_dcd" = data that might be protected by the lock.
drivers/char/epca.c:1515: unlock: Unlocking "epca_lock". "ch->m_dcd" might now be unreliable because other threads can now change the data that it depends on.
drivers/char/epca.c:1385: lockagain: Locking "epca_lock" again.
drivers/char/epca.c:1420: use: Using an unreliable value of "ch->m_dcd" inside the second locked section.  If the data that "ch->m_dcd" depends on was changed by another thread, this use might be incorrect.

Error: ATOMICITY:
drivers/char/epca.c:1385: lock: Locking "epca_lock".
drivers/char/epca.c:1399: def: Assigning: "ch->m_dcd" = data that might be protected by the lock.
drivers/char/epca.c:1515: unlock: Unlocking "epca_lock". "ch->m_dcd" might now be unreliable because other threads can now change the data that it depends on.
drivers/char/epca.c:1385: lockagain: Locking "epca_lock" again.
drivers/char/epca.c:1424: use: Using an unreliable value of "ch->m_dcd" inside the second locked section.  If the data that "ch->m_dcd" depends on was changed by another thread, this use might be incorrect.

Error: ATOMICITY:
drivers/char/epca.c:1385: lock: Locking "epca_lock".
drivers/char/epca.c:1400: def: Assigning: "ch->m_dsr" = data that might be protected by the lock.
drivers/char/epca.c:1515: unlock: Unlocking "epca_lock". "ch->m_dsr" might now be unreliable because other threads can now change the data that it depends on.
drivers/char/epca.c:1385: lockagain: Locking "epca_lock" again.
drivers/char/epca.c:1421: use: Using an unreliable value of "ch->m_dsr" inside the second locked section.  If the data that "ch->m_dsr" depends on was changed by another thread, this use might be incorrect.

Error: ATOMICITY:
drivers/char/epca.c:1385: lock: Locking "epca_lock".
drivers/char/epca.c:1400: def: Assigning: "ch->m_dsr" = data that might be protected by the lock.
drivers/char/epca.c:1515: unlock: Unlocking "epca_lock". "ch->m_dsr" might now be unreliable because other threads can now change the data that it depends on.
drivers/char/epca.c:1385: lockagain: Locking "epca_lock" again.
drivers/char/epca.c:1425: use: Using an unreliable value of "ch->m_dsr" inside the second locked section.  If the data that "ch->m_dsr" depends on was changed by another thread, this use might be incorrect.

Error: ATOMICITY:
drivers/scsi/lpfc/lpfc_hbadisc.c:489: lock: Locking "phba->hbalock".
drivers/scsi/lpfc/lpfc_hbadisc.c:490: def: Assigning: "ha_copy" = data that might be protected by the lock.
drivers/scsi/lpfc/lpfc_hbadisc.c:492: unlock: Unlocking "phba->hbalock". "ha_copy" might now be unreliable because other threads can now change the data that it depends on.
drivers/scsi/lpfc/lpfc_hbadisc.c:558: lockagain: Locking "phba->hbalock" again.
drivers/scsi/lpfc/lpfc_hbadisc.c:561: use: Using an unreliable value of "ha_copy" inside the second locked section.  If the data that "ha_copy" depends on was changed by another thread, this use might be incorrect.

Error: ATOMICITY:
drivers/scsi/lpfc/lpfc_hbadisc.c:489: lock: Locking "phba->hbalock".
drivers/scsi/lpfc/lpfc_hbadisc.c:490: def: Assigning: "ha_copy" = data that might be protected by the lock.
drivers/scsi/lpfc/lpfc_hbadisc.c:492: unlock: Unlocking "phba->hbalock". "ha_copy" might now be unreliable because other threads can now change the data that it depends on.
drivers/scsi/lpfc/lpfc_hbadisc.c:558: lockagain: Locking "phba->hbalock" again.
drivers/scsi/lpfc/lpfc_hbadisc.c:570: use: Using an unreliable value of "ha_copy" inside the second locked section.  If the data that "ha_copy" depends on was changed by another thread, this use might be incorrect.

Error: ATOMICITY:
drivers/scsi/lpfc/lpfc_hbadisc.c:489: lock: Locking "phba->hbalock".
drivers/scsi/lpfc/lpfc_hbadisc.c:490: def: Assigning: "ha_copy" = data that might be protected by the lock.
drivers/scsi/lpfc/lpfc_hbadisc.c:492: unlock: Unlocking "phba->hbalock". "ha_copy" might now be unreliable because other threads can now change the data that it depends on.
drivers/scsi/lpfc/lpfc_hbadisc.c:520: unlock: Unlocking "vport->work_port_lock". "ha_copy" might now be unreliable because other threads can now change the data that it depends on.
drivers/scsi/lpfc/lpfc_hbadisc.c:558: lockagain: Locking "phba->hbalock" again.
drivers/scsi/lpfc/lpfc_hbadisc.c:561: use: Using an unreliable value of "ha_copy" inside the second locked section.  If the data that "ha_copy" depends on was changed by another thread, this use might be incorrect.

Error: ATOMICITY:
drivers/scsi/lpfc/lpfc_hbadisc.c:489: lock: Locking "phba->hbalock".
drivers/scsi/lpfc/lpfc_hbadisc.c:490: def: Assigning: "ha_copy" = data that might be protected by the lock.
drivers/scsi/lpfc/lpfc_hbadisc.c:492: unlock: Unlocking "phba->hbalock". "ha_copy" might now be unreliable because other threads can now change the data that it depends on.
drivers/scsi/lpfc/lpfc_hbadisc.c:520: unlock: Unlocking "vport->work_port_lock". "ha_copy" might now be unreliable because other threads can now change the data that it depends on.
drivers/scsi/lpfc/lpfc_hbadisc.c:558: lockagain: Locking "phba->hbalock" again.
drivers/scsi/lpfc/lpfc_hbadisc.c:570: use: Using an unreliable value of "ha_copy" inside the second locked section.  If the data that "ha_copy" depends on was changed by another thread, this use might be incorrect.

Error: ATOMICITY:
drivers/net/wireless/libertas/cmdresp.c:297: lock: Locking "priv->driver_lock".
drivers/net/wireless/libertas/cmdresp.c:309: def: Assigning: "result" = data that might be protected by the lock.
drivers/net/wireless/libertas/cmdresp.c:384: unlock: Unlocking "priv->driver_lock". "result" might now be unreliable because other threads can now change the data that it depends on.
drivers/net/wireless/libertas/cmdresp.c:388: lockagain: Locking "priv->driver_lock" again.
drivers/net/wireless/libertas/cmdresp.c:398: use: Using an unreliable value of "result" inside the second locked section.  If the data that "result" depends on was changed by another thread, this use might be incorrect.

Error: ATOMICITY:
drivers/net/wireless/libertas/cmdresp.c:297: lock: Locking "priv->driver_lock".
drivers/net/wireless/libertas/cmdresp.c:309: def: Assigning: "result" = data that might be protected by the lock.
drivers/net/wireless/libertas/cmdresp.c:426: unlock: Unlocking "priv->driver_lock". "result" might now be unreliable because other threads can now change the data that it depends on.
drivers/net/wireless/libertas/cmdresp.c:434: lockagain: Locking "priv->driver_lock" again.
drivers/net/wireless/libertas/cmdresp.c:438: use: Using an unreliable value of "result" inside the second locked section.  If the data that "result" depends on was changed by another thread, this use might be incorrect.

Error: ATOMICITY:
drivers/net/wireless/libertas/cmd.c:1658: lock: Locking "priv->driver_lock".
drivers/net/wireless/libertas/cmd.c:1668: def: Assigning: "cmdnode" = data that might be protected by the lock.
drivers/net/wireless/libertas/cmd.c:1672: unlock: Unlocking "priv->driver_lock". "cmdnode" might now be unreliable because other threads can now change the data that it depends on.
drivers/net/wireless/libertas/cmd.c:1731: lockagain: Locking "priv->driver_lock" again.
drivers/net/wireless/libertas/cmd.c:1732: use: Using an unreliable value of "cmdnode" inside the second locked section.  If the data that "cmdnode" depends on was changed by another thread, this use might be incorrect.

Error: ATOMICITY:
drivers/net/wireless/libertas/cmd.c:1658: lock: Locking "priv->driver_lock".
drivers/net/wireless/libertas/cmd.c:1668: def: Assigning: "cmdnode" = data that might be protected by the lock.
drivers/net/wireless/libertas/cmd.c:1672: unlock: Unlocking "priv->driver_lock". "cmdnode" might now be unreliable because other threads can now change the data that it depends on.
drivers/net/wireless/libertas/cmd.c:1744: lockagain: Locking "priv->driver_lock" again.
drivers/net/wireless/libertas/cmd.c:1745: use: Using an unreliable value of "cmdnode" inside the second locked section.  If the data that "cmdnode" depends on was changed by another thread, this use might be incorrect.

Error: ATOMICITY:
drivers/scsi/ipr.c:3544: lock: Locking "*ioa_cfg->host->host_lock".
drivers/scsi/ipr.c:3545: def: Assigning: "res" = data that might be protected by the lock.
drivers/scsi/ipr.c:3549: unlock: Unlocking "*ioa_cfg->host->host_lock". "res" might now be unreliable because other threads can now change the data that it depends on.
drivers/scsi/ipr.c:3556: lockagain: Locking "*ioa_cfg->host->host_lock" again.
drivers/scsi/ipr.c:3559: use: Using an unreliable value of "res" inside the second locked section.  If the data that "res" depends on was changed by another thread, this use might be incorrect.

Error: ATOMICITY:
drivers/scsi/BusLogic.c:2841: lock: Locking "*HostAdapter->SCSI_Host->host_lock".
drivers/scsi/BusLogic.c:2842: def: Assigning: "CCB" = data that might be protected by the lock.
drivers/scsi/BusLogic.c:2967: unlock: Unlocking "*HostAdapter->SCSI_Host->host_lock". "CCB" might now be unreliable because other threads can now change the data that it depends on.
drivers/scsi/BusLogic.c:2970: lockagain: Locking "*HostAdapter->SCSI_Host->host_lock" again.
drivers/scsi/BusLogic.c:2971: use: Using an unreliable value of "CCB" inside the second locked section.  If the data that "CCB" depends on was changed by another thread, this use might be incorrect.

Error: ATOMICITY:
drivers/infiniband/hw/ipath/ipath_verbs.c:498: lock: Locking "qp->r_rq.lock".
drivers/infiniband/hw/ipath/ipath_verbs.c:516: def: Assigning: "wq->head" = data that might be protected by the lock.
drivers/infiniband/hw/ipath/ipath_verbs.c:517: unlock: Unlocking "qp->r_rq.lock". "wq->head" might now be unreliable because other threads can now change the data that it depends on.
drivers/infiniband/hw/ipath/ipath_verbs.c:498: lockagain: Locking "qp->r_rq.lock" again.
drivers/infiniband/hw/ipath/ipath_verbs.c:509: use: Using an unreliable value of "wq->head" inside the second locked section.  If the data that "wq->head" depends on was changed by another thread, this use might be incorrect.

Error: ATOMICITY:
drivers/media/video/ivtv/ivtv-driver.c:1004: lock: Locking "ivtv_cards_lock".
drivers/media/video/ivtv/ivtv-driver.c:1019: def: Assigning: "ivtv_cards[ivtv_cards_active]" = data that might be protected by the lock.
drivers/media/video/ivtv/ivtv-driver.c:1025: unlock: Unlocking "ivtv_cards_lock". "ivtv_cards[ivtv_cards_active]" might now be unreliable because other threads can now change the data that it depends on.
drivers/media/video/ivtv/ivtv-driver.c:1264: lockagain: Locking "ivtv_cards_lock" again.
drivers/media/video/ivtv/ivtv-driver.c:1265: use: Using an unreliable value of "ivtv_cards[ivtv_cards_active]" inside the second locked section.  If the data that "ivtv_cards[ivtv_cards_active]" depends on was changed by another thread, this use might be incorrect.

Error: ATOMICITY:
drivers/net/wireless/libertas/main.c:863: lock: Locking "priv->driver_lock".
drivers/net/wireless/libertas/main.c:872: def: Assigning: "priv->tx_pending_len" = data that might be protected by the lock.
drivers/net/wireless/libertas/main.c:883: unlock: Unlocking "priv->driver_lock". "priv->tx_pending_len" might now be unreliable because other threads can now change the data that it depends on.
drivers/net/wireless/libertas/main.c:741: unlock: Unlocking "priv->driver_lock". "priv->tx_pending_len" might now be unreliable because other threads can now change the data that it depends on.
drivers/net/wireless/libertas/main.c:772: unlock: Unlocking "priv->driver_lock". "priv->tx_pending_len" might now be unreliable because other threads can now change the data that it depends on.
drivers/net/wireless/libertas/main.c:779: unlock: Unlocking "priv->driver_lock". "priv->tx_pending_len" might now be unreliable because other threads can now change the data that it depends on.
drivers/net/wireless/libertas/main.c:819: unlock: Unlocking "priv->driver_lock". "priv->tx_pending_len" might now be unreliable because other threads can now change the data that it depends on.
drivers/net/wireless/libertas/main.c:863: lockagain: Locking "priv->driver_lock" again.
drivers/net/wireless/libertas/main.c:865: use: Using an unreliable value of "priv->tx_pending_len" inside the second locked section.  If the data that "priv->tx_pending_len" depends on was changed by another thread, this use might be incorrect.

Error: ATOMICITY:
drivers/char/n_tty.c:1343: lock: Locking "tty->link->ctrl_lock".
drivers/char/n_tty.c:1345: def: Assigning: "tty->link->ctrl_status" = data that might be protected by the lock.
drivers/char/n_tty.c:1346: unlock: Unlocking "tty->link->ctrl_lock". "tty->link->ctrl_status" might now be unreliable because other threads can now change the data that it depends on.
drivers/char/n_tty.c:1343: lockagain: Locking "tty->link->ctrl_lock" again.
drivers/char/n_tty.c:1344: use: Using an unreliable value of "tty->link->ctrl_status" inside the second locked section.  If the data that "tty->link->ctrl_status" depends on was changed by another thread, this use might be incorrect.

Error: ATOMICITY:
drivers/char/n_tty.c:1343: lock: Locking "tty->link->ctrl_lock".
drivers/char/n_tty.c:1345: def: Assigning: "tty->link->ctrl_status" = data that might be protected by the lock.
drivers/char/n_tty.c:1346: unlock: Unlocking "tty->link->ctrl_lock". "tty->link->ctrl_status" might now be unreliable because other threads can now change the data that it depends on.
drivers/char/n_tty.c:1418: unlock: Unlocking "tty->read_lock". "tty->link->ctrl_status" might now be unreliable because other threads can now change the data that it depends on.
drivers/char/n_tty.c:1343: lockagain: Locking "tty->link->ctrl_lock" again.
drivers/char/n_tty.c:1344: use: Using an unreliable value of "tty->link->ctrl_status" inside the second locked section.  If the data that "tty->link->ctrl_status" depends on was changed by another thread, this use might be incorrect.

Error: ATOMICITY:
fs/ocfs2/dlm/dlmthread.c:637: lock: Locking "dlm->spinlock".
fs/ocfs2/dlm/dlmthread.c:640: def: Assigning: "res" = data that might be protected by the lock.
fs/ocfs2/dlm/dlmthread.c:651: unlock: Unlocking "res->spinlock". "res" might now be unreliable because other threads can now change the data that it depends on.
fs/ocfs2/dlm/dlmthread.c:652: unlock: Unlocking "dlm->spinlock". "res" might now be unreliable because other threads can now change the data that it depends on.
fs/ocfs2/dlm/dlmthread.c:659: lockagain: Locking "res->spinlock" again.
fs/ocfs2/dlm/dlmthread.c:661: use: Using an unreliable value of "res" inside the second locked section.  If the data that "res" depends on was changed by another thread, this use might be incorrect.

Error: ATOMICITY:
fs/ocfs2/dlm/dlmthread.c:637: lock: Locking "dlm->spinlock".
fs/ocfs2/dlm/dlmthread.c:640: def: Assigning: "res" = data that might be protected by the lock.
fs/ocfs2/dlm/dlmthread.c:651: unlock: Unlocking "res->spinlock". "res" might now be unreliable because other threads can now change the data that it depends on.
fs/ocfs2/dlm/dlmthread.c:652: unlock: Unlocking "dlm->spinlock". "res" might now be unreliable because other threads can now change the data that it depends on.
fs/ocfs2/dlm/dlmthread.c:659: lockagain: Locking "res->spinlock" again.
fs/ocfs2/dlm/dlmthread.c:697: use: Using an unreliable value of "res" inside the second locked section.  If the data that "res" depends on was changed by another thread, this use might be incorrect.

Error: ATOMICITY:
fs/ocfs2/dlm/dlmthread.c:637: lock: Locking "dlm->spinlock".
fs/ocfs2/dlm/dlmthread.c:640: def: Assigning: "res" = data that might be protected by the lock.
fs/ocfs2/dlm/dlmthread.c:651: unlock: Unlocking "res->spinlock". "res" might now be unreliable because other threads can now change the data that it depends on.
fs/ocfs2/dlm/dlmthread.c:652: unlock: Unlocking "dlm->spinlock". "res" might now be unreliable because other threads can now change the data that it depends on.
fs/ocfs2/dlm/dlmthread.c:678: unlock: Unlocking "res->spinlock". "res" might now be unreliable because other threads can now change the data that it depends on.
fs/ocfs2/dlm/dlmthread.c:705: lockagain: Locking "dlm->spinlock" again.
fs/ocfs2/dlm/dlmthread.c:713: use: Using an unreliable value of "res" inside the second locked section.  If the data that "res" depends on was changed by another thread, this use might be incorrect.

Error: ATOMICITY:
fs/ocfs2/dlm/dlmthread.c:637: lock: Locking "dlm->spinlock".
fs/ocfs2/dlm/dlmthread.c:640: def: Assigning: "res" = data that might be protected by the lock.
fs/ocfs2/dlm/dlmthread.c:651: unlock: Unlocking "res->spinlock". "res" might now be unreliable because other threads can now change the data that it depends on.
fs/ocfs2/dlm/dlmthread.c:652: unlock: Unlocking "dlm->spinlock". "res" might now be unreliable because other threads can now change the data that it depends on.
fs/ocfs2/dlm/dlmthread.c:678: unlock: Unlocking "res->spinlock". "res" might now be unreliable because other threads can now change the data that it depends on.
fs/ocfs2/dlm/dlmthread.c:709: lockagain: Locking "res->spinlock" again.
fs/ocfs2/dlm/dlmthread.c:710: use: Using an unreliable value of "res" inside the second locked section.  If the data that "res" depends on was changed by another thread, this use might be incorrect.

Error: ATOMICITY:
fs/gfs2/lops.c:169: lock: Locking "sdp->sd_log_lock".
fs/gfs2/lops.c:175: def: Assigning: "num" = data that might be protected by the lock.
fs/gfs2/lops.c:176: unlock: Unlocking "sdp->sd_log_lock". "num" might now be unreliable because other threads can now change the data that it depends on.
fs/gfs2/lops.c:178: lockagain: Locking "sdp->sd_log_lock" again.
fs/gfs2/lops.c:182: use: Using an unreliable value of "num" inside the second locked section.  If the data that "num" depends on was changed by another thread, this use might be incorrect.

Error: ATOMICITY:
fs/gfs2/lops.c:204: lock: Locking "sdp->sd_log_lock".
fs/gfs2/lops.c:175: def: Assigning: "num" = data that might be protected by the lock.
fs/gfs2/lops.c:176: unlock: Unlocking "sdp->sd_log_lock". "num" might now be unreliable because other threads can now change the data that it depends on.
fs/gfs2/lops.c:178: lockagain: Locking "sdp->sd_log_lock" again.
fs/gfs2/lops.c:182: use: Using an unreliable value of "num" inside the second locked section.  If the data that "num" depends on was changed by another thread, this use might be incorrect.

Error: ATOMICITY:
fs/gfs2/lops.c:169: lock: Locking "sdp->sd_log_lock".
fs/gfs2/lops.c:170: def: Assigning: "total" = data that might be protected by the lock.
fs/gfs2/lops.c:176: unlock: Unlocking "sdp->sd_log_lock". "total" might now be unreliable because other threads can now change the data that it depends on.
fs/gfs2/lops.c:192: unlock: Unlocking "sdp->sd_log_lock". "total" might now be unreliable because other threads can now change the data that it depends on.
fs/gfs2/lops.c:200: unlock: Unlocking "sdp->sd_log_lock". "total" might now be unreliable because other threads can now change the data that it depends on.
fs/gfs2/lops.c:204: lockagain: Locking "sdp->sd_log_lock" again.
fs/gfs2/lops.c:173: use: Using an unreliable value of "total" inside the second locked section.  If the data that "total" depends on was changed by another thread, this use might be incorrect.

Error: ATOMICITY:
drivers/infiniband/hw/nes/nes_cm.c:469: lock: Locking "cm_node->recv_list_lock".
drivers/infiniband/hw/nes/nes_cm.c:485: def: Assigning: "cm_id" = data that might be protected by the lock.
drivers/infiniband/hw/nes/nes_cm.c:486: unlock: Unlocking "cm_node->recv_list_lock". "cm_id" might now be unreliable because other threads can now change the data that it depends on.
drivers/infiniband/hw/nes/nes_cm.c:488: lockagain: Locking "nesqp->lock" again.
drivers/infiniband/hw/nes/nes_cm.c:490: use: Using an unreliable value of "cm_id" inside the second locked section.  If the data that "cm_id" depends on was changed by another thread, this use might be incorrect.

Error: ATOMICITY:
drivers/infiniband/hw/nes/nes_cm.c:618: lock: Locking "cm_core->ht_lock".
drivers/infiniband/hw/nes/nes_cm.c:466: def: Assigning: "cm_node" = data that might be protected by the lock.
drivers/infiniband/hw/nes/nes_cm.c:468: unlock: Unlocking "cm_core->ht_lock". "cm_node" might now be unreliable because other threads can now change the data that it depends on.
drivers/infiniband/hw/nes/nes_cm.c:516: unlock: Unlocking "cm_node->recv_list_lock". "cm_node" might now be unreliable because other threads can now change the data that it depends on.
drivers/infiniband/hw/nes/nes_cm.c:518: lockagain: Locking "cm_node->retrans_list_lock" again.
drivers/infiniband/hw/nes/nes_cm.c:534: use: Using an unreliable value of "cm_node" inside the second locked section.  If the data that "cm_node" depends on was changed by another thread, this use might be incorrect.

Error: ATOMICITY:
drivers/infiniband/hw/nes/nes_cm.c:618: lock: Locking "cm_core->ht_lock".
drivers/infiniband/hw/nes/nes_cm.c:466: def: Assigning: "cm_node" = data that might be protected by the lock.
drivers/infiniband/hw/nes/nes_cm.c:468: unlock: Unlocking "cm_core->ht_lock". "cm_node" might now be unreliable because other threads can now change the data that it depends on.
drivers/infiniband/hw/nes/nes_cm.c:516: unlock: Unlocking "cm_node->recv_list_lock". "cm_node" might now be unreliable because other threads can now change the data that it depends on.
drivers/infiniband/hw/nes/nes_cm.c:518: lockagain: Locking "cm_node->retrans_list_lock" again.
drivers/infiniband/hw/nes/nes_cm.c:541: use: Using an unreliable value of "cm_node" inside the second locked section.  If the data that "cm_node" depends on was changed by another thread, this use might be incorrect.

Error: ATOMICITY:
drivers/infiniband/hw/nes/nes_cm.c:618: lock: Locking "cm_core->ht_lock".
drivers/infiniband/hw/nes/nes_cm.c:466: def: Assigning: "cm_node" = data that might be protected by the lock.
drivers/infiniband/hw/nes/nes_cm.c:468: unlock: Unlocking "cm_core->ht_lock". "cm_node" might now be unreliable because other threads can now change the data that it depends on.
drivers/infiniband/hw/nes/nes_cm.c:516: unlock: Unlocking "cm_node->recv_list_lock". "cm_node" might now be unreliable because other threads can now change the data that it depends on.
drivers/infiniband/hw/nes/nes_cm.c:518: lockagain: Locking "cm_node->retrans_list_lock" again.
drivers/infiniband/hw/nes/nes_cm.c:550: use: Using an unreliable value of "cm_node" inside the second locked section.  If the data that "cm_node" depends on was changed by another thread, this use might be incorrect.

Error: ATOMICITY:
drivers/infiniband/hw/nes/nes_cm.c:618: lock: Locking "cm_core->ht_lock".
drivers/infiniband/hw/nes/nes_cm.c:466: def: Assigning: "cm_node" = data that might be protected by the lock.
drivers/infiniband/hw/nes/nes_cm.c:468: unlock: Unlocking "cm_core->ht_lock". "cm_node" might now be unreliable because other threads can now change the data that it depends on.
drivers/infiniband/hw/nes/nes_cm.c:516: unlock: Unlocking "cm_node->recv_list_lock". "cm_node" might now be unreliable because other threads can now change the data that it depends on.
drivers/infiniband/hw/nes/nes_cm.c:518: lockagain: Locking "cm_node->retrans_list_lock" again.
drivers/infiniband/hw/nes/nes_cm.c:564: use: Using an unreliable value of "cm_node" inside the second locked section.  If the data that "cm_node" depends on was changed by another thread, this use might be incorrect.

Error: ATOMICITY:
drivers/infiniband/hw/nes/nes_cm.c:469: lock: Locking "cm_node->recv_list_lock".
drivers/infiniband/hw/nes/nes_cm.c:470: def: Assigning: "list_node_temp" = data that might be protected by the lock.
drivers/infiniband/hw/nes/nes_cm.c:486: unlock: Unlocking "cm_node->recv_list_lock". "list_node_temp" might now be unreliable because other threads can now change the data that it depends on.
drivers/infiniband/hw/nes/nes_cm.c:498: unlock: Unlocking "nesqp->lock". "list_node_temp" might now be unreliable because other threads can now change the data that it depends on.
drivers/infiniband/hw/nes/nes_cm.c:514: lockagain: Locking "cm_node->recv_list_lock" again.
drivers/infiniband/hw/nes/nes_cm.c:470: use: Using an unreliable value of "list_node_temp" inside the second locked section.  If the data that "list_node_temp" depends on was changed by another thread, this use might be incorrect.

Error: ATOMICITY:
drivers/infiniband/hw/nes/nes_cm.c:462: lock: Locking "cm_core->ht_lock".
drivers/infiniband/hw/nes/nes_cm.c:466: def: Assigning: "cm_node" = data that might be protected by the lock.
drivers/infiniband/hw/nes/nes_cm.c:468: unlock: Unlocking "cm_core->ht_lock". "cm_node" might now be unreliable because other threads can now change the data that it depends on.
drivers/infiniband/hw/nes/nes_cm.c:516: unlock: Unlocking "cm_node->recv_list_lock". "cm_node" might now be unreliable because other threads can now change the data that it depends on.
drivers/infiniband/hw/nes/nes_cm.c:616: unlock: Unlocking "cm_node->retrans_list_lock". "cm_node" might now be unreliable because other threads can now change the data that it depends on.
drivers/infiniband/hw/nes/nes_cm.c:618: lockagain: Locking "cm_core->ht_lock" again.
drivers/infiniband/hw/nes/nes_cm.c:620: use: Using an unreliable value of "cm_node" inside the second locked section.  If the data that "cm_node" depends on was changed by another thread, this use might be incorrect.

Error: ATOMICITY:
drivers/infiniband/hw/nes/nes_cm.c:462: lock: Locking "cm_core->ht_lock".
drivers/infiniband/hw/nes/nes_cm.c:464: def: Assigning: "list_core_temp" = data that might be protected by the lock.
drivers/infiniband/hw/nes/nes_cm.c:468: unlock: Unlocking "cm_core->ht_lock". "list_core_temp" might now be unreliable because other threads can now change the data that it depends on.
drivers/infiniband/hw/nes/nes_cm.c:516: unlock: Unlocking "cm_node->recv_list_lock". "list_core_temp" might now be unreliable because other threads can now change the data that it depends on.
drivers/infiniband/hw/nes/nes_cm.c:616: unlock: Unlocking "cm_node->retrans_list_lock". "list_core_temp" might now be unreliable because other threads can now change the data that it depends on.
drivers/infiniband/hw/nes/nes_cm.c:618: lockagain: Locking "cm_core->ht_lock" again.
drivers/infiniband/hw/nes/nes_cm.c:464: use: Using an unreliable value of "list_core_temp" inside the second locked section.  If the data that "list_core_temp" depends on was changed by another thread, this use might be incorrect.

Error: ATOMICITY:
drivers/infiniband/hw/nes/nes_cm.c:618: lock: Locking "cm_core->ht_lock".
drivers/infiniband/hw/nes/nes_cm.c:466: def: Assigning: "cm_node" = data that might be protected by the lock.
drivers/infiniband/hw/nes/nes_cm.c:468: unlock: Unlocking "cm_core->ht_lock". "cm_node" might now be unreliable because other threads can now change the data that it depends on.
drivers/infiniband/hw/nes/nes_cm.c:516: unlock: Unlocking "cm_node->recv_list_lock". "cm_node" might now be unreliable because other threads can now change the data that it depends on.
drivers/infiniband/hw/nes/nes_cm.c:574: unlock: Unlocking "cm_node->retrans_list_lock". "cm_node" might now be unreliable because other threads can now change the data that it depends on.
drivers/infiniband/hw/nes/nes_cm.c:577: lockagain: Locking "cm_node->retrans_list_lock" again.
drivers/infiniband/hw/nes/nes_cm.c:579: use: Using an unreliable value of "cm_node" inside the second locked section.  If the data that "cm_node" depends on was changed by another thread, this use might be incorrect.

Error: ATOMICITY:
drivers/infiniband/hw/nes/nes_cm.c:618: lock: Locking "cm_core->ht_lock".
drivers/infiniband/hw/nes/nes_cm.c:466: def: Assigning: "cm_node" = data that might be protected by the lock.
drivers/infiniband/hw/nes/nes_cm.c:468: unlock: Unlocking "cm_core->ht_lock". "cm_node" might now be unreliable because other threads can now change the data that it depends on.
drivers/infiniband/hw/nes/nes_cm.c:516: unlock: Unlocking "cm_node->recv_list_lock". "cm_node" might now be unreliable because other threads can now change the data that it depends on.
drivers/infiniband/hw/nes/nes_cm.c:574: unlock: Unlocking "cm_node->retrans_list_lock". "cm_node" might now be unreliable because other threads can now change the data that it depends on.
drivers/infiniband/hw/nes/nes_cm.c:577: lockagain: Locking "cm_node->retrans_list_lock" again.
drivers/infiniband/hw/nes/nes_cm.c:607: use: Using an unreliable value of "cm_node" inside the second locked section.  If the data that "cm_node" depends on was changed by another thread, this use might be incorrect.

Error: ATOMICITY:
drivers/infiniband/hw/nes/nes_cm.c:618: lock: Locking "cm_core->ht_lock".
drivers/infiniband/hw/nes/nes_cm.c:466: def: Assigning: "cm_node" = data that might be protected by the lock.
drivers/infiniband/hw/nes/nes_cm.c:468: unlock: Unlocking "cm_core->ht_lock". "cm_node" might now be unreliable because other threads can now change the data that it depends on.
drivers/infiniband/hw/nes/nes_cm.c:516: unlock: Unlocking "cm_node->recv_list_lock". "cm_node" might now be unreliable because other threads can now change the data that it depends on.
drivers/infiniband/hw/nes/nes_cm.c:574: unlock: Unlocking "cm_node->retrans_list_lock". "cm_node" might now be unreliable because other threads can now change the data that it depends on.
drivers/infiniband/hw/nes/nes_cm.c:577: lockagain: Locking "cm_node->retrans_list_lock" again.
drivers/infiniband/hw/nes/nes_cm.c:609: use: Using an unreliable value of "cm_node" inside the second locked section.  If the data that "cm_node" depends on was changed by another thread, this use might be incorrect.

Error: ATOMICITY:
drivers/infiniband/hw/nes/nes_cm.c:618: lock: Locking "cm_core->ht_lock".
drivers/infiniband/hw/nes/nes_cm.c:466: def: Assigning: "cm_node" = data that might be protected by the lock.
drivers/infiniband/hw/nes/nes_cm.c:468: unlock: Unlocking "cm_core->ht_lock". "cm_node" might now be unreliable because other threads can now change the data that it depends on.
drivers/infiniband/hw/nes/nes_cm.c:516: unlock: Unlocking "cm_node->recv_list_lock". "cm_node" might now be unreliable because other threads can now change the data that it depends on.
drivers/infiniband/hw/nes/nes_cm.c:616: unlock: Unlocking "cm_node->retrans_list_lock". "cm_node" might now be unreliable because other threads can now change the data that it depends on.
drivers/infiniband/hw/nes/nes_cm.c:618: lockagain: Locking "cm_core->ht_lock" again.
drivers/infiniband/hw/nes/nes_cm.c:620: use: Using an unreliable value of "cm_node" inside the second locked section.  If the data that "cm_node" depends on was changed by another thread, this use might be incorrect.

Error: ATOMICITY:
drivers/infiniband/hw/nes/nes_cm.c:618: lock: Locking "cm_core->ht_lock".
drivers/infiniband/hw/nes/nes_cm.c:464: def: Assigning: "list_core_temp" = data that might be protected by the lock.
drivers/infiniband/hw/nes/nes_cm.c:468: unlock: Unlocking "cm_core->ht_lock". "list_core_temp" might now be unreliable because other threads can now change the data that it depends on.
drivers/infiniband/hw/nes/nes_cm.c:516: unlock: Unlocking "cm_node->recv_list_lock". "list_core_temp" might now be unreliable because other threads can now change the data that it depends on.
drivers/infiniband/hw/nes/nes_cm.c:616: unlock: Unlocking "cm_node->retrans_list_lock". "list_core_temp" might now be unreliable because other threads can now change the data that it depends on.
drivers/infiniband/hw/nes/nes_cm.c:618: lockagain: Locking "cm_core->ht_lock" again.
drivers/infiniband/hw/nes/nes_cm.c:464: use: Using an unreliable value of "list_core_temp" inside the second locked section.  If the data that "list_core_temp" depends on was changed by another thread, this use might be incorrect.

Error: ATOMICITY:
drivers/infiniband/hw/nes/nes_cm.c:618: lock: Locking "cm_core->ht_lock".
drivers/infiniband/hw/nes/nes_cm.c:466: def: Assigning: "cm_node" = data that might be protected by the lock.
drivers/infiniband/hw/nes/nes_cm.c:468: unlock: Unlocking "cm_core->ht_lock". "cm_node" might now be unreliable because other threads can now change the data that it depends on.
drivers/infiniband/hw/nes/nes_cm.c:486: unlock: Unlocking "cm_node->recv_list_lock". "cm_node" might now be unreliable because other threads can now change the data that it depends on.
drivers/infiniband/hw/nes/nes_cm.c:498: unlock: Unlocking "nesqp->lock". "cm_node" might now be unreliable because other threads can now change the data that it depends on.
drivers/infiniband/hw/nes/nes_cm.c:516: unlock: Unlocking "cm_node->recv_list_lock". "cm_node" might now be unreliable because other threads can now change the data that it depends on.
drivers/infiniband/hw/nes/nes_cm.c:518: lockagain: Locking "cm_node->retrans_list_lock" again.
drivers/infiniband/hw/nes/nes_cm.c:534: use: Using an unreliable value of "cm_node" inside the second locked section.  If the data that "cm_node" depends on was changed by another thread, this use might be incorrect.

Error: ATOMICITY:
drivers/infiniband/hw/nes/nes_cm.c:618: lock: Locking "cm_core->ht_lock".
drivers/infiniband/hw/nes/nes_cm.c:466: def: Assigning: "cm_node" = data that might be protected by the lock.
drivers/infiniband/hw/nes/nes_cm.c:468: unlock: Unlocking "cm_core->ht_lock". "cm_node" might now be unreliable because other threads can now change the data that it depends on.
drivers/infiniband/hw/nes/nes_cm.c:486: unlock: Unlocking "cm_node->recv_list_lock". "cm_node" might now be unreliable because other threads can now change the data that it depends on.
drivers/infiniband/hw/nes/nes_cm.c:498: unlock: Unlocking "nesqp->lock". "cm_node" might now be unreliable because other threads can now change the data that it depends on.
drivers/infiniband/hw/nes/nes_cm.c:516: unlock: Unlocking "cm_node->recv_list_lock". "cm_node" might now be unreliable because other threads can now change the data that it depends on.
drivers/infiniband/hw/nes/nes_cm.c:518: lockagain: Locking "cm_node->retrans_list_lock" again.
drivers/infiniband/hw/nes/nes_cm.c:541: use: Using an unreliable value of "cm_node" inside the second locked section.  If the data that "cm_node" depends on was changed by another thread, this use might be incorrect.

Error: ATOMICITY:
drivers/infiniband/hw/nes/nes_cm.c:618: lock: Locking "cm_core->ht_lock".
drivers/infiniband/hw/nes/nes_cm.c:466: def: Assigning: "cm_node" = data that might be protected by the lock.
drivers/infiniband/hw/nes/nes_cm.c:468: unlock: Unlocking "cm_core->ht_lock". "cm_node" might now be unreliable because other threads can now change the data that it depends on.
drivers/infiniband/hw/nes/nes_cm.c:486: unlock: Unlocking "cm_node->recv_list_lock". "cm_node" might now be unreliable because other threads can now change the data that it depends on.
drivers/infiniband/hw/nes/nes_cm.c:498: unlock: Unlocking "nesqp->lock". "cm_node" might now be unreliable because other threads can now change the data that it depends on.
drivers/infiniband/hw/nes/nes_cm.c:516: unlock: Unlocking "cm_node->recv_list_lock". "cm_node" might now be unreliable because other threads can now change the data that it depends on.
drivers/infiniband/hw/nes/nes_cm.c:518: lockagain: Locking "cm_node->retrans_list_lock" again.
drivers/infiniband/hw/nes/nes_cm.c:550: use: Using an unreliable value of "cm_node" inside the second locked section.  If the data that "cm_node" depends on was changed by another thread, this use might be incorrect.

Error: ATOMICITY:
drivers/infiniband/hw/nes/nes_cm.c:618: lock: Locking "cm_core->ht_lock".
drivers/infiniband/hw/nes/nes_cm.c:466: def: Assigning: "cm_node" = data that might be protected by the lock.
drivers/infiniband/hw/nes/nes_cm.c:468: unlock: Unlocking "cm_core->ht_lock". "cm_node" might now be unreliable because other threads can now change the data that it depends on.
drivers/infiniband/hw/nes/nes_cm.c:486: unlock: Unlocking "cm_node->recv_list_lock". "cm_node" might now be unreliable because other threads can now change the data that it depends on.
drivers/infiniband/hw/nes/nes_cm.c:498: unlock: Unlocking "nesqp->lock". "cm_node" might now be unreliable because other threads can now change the data that it depends on.
drivers/infiniband/hw/nes/nes_cm.c:516: unlock: Unlocking "cm_node->recv_list_lock". "cm_node" might now be unreliable because other threads can now change the data that it depends on.
drivers/infiniband/hw/nes/nes_cm.c:518: lockagain: Locking "cm_node->retrans_list_lock" again.
drivers/infiniband/hw/nes/nes_cm.c:564: use: Using an unreliable value of "cm_node" inside the second locked section.  If the data that "cm_node" depends on was changed by another thread, this use might be incorrect.

Error: ATOMICITY:
drivers/infiniband/hw/nes/nes_cm.c:618: lock: Locking "cm_core->ht_lock".
drivers/infiniband/hw/nes/nes_cm.c:464: def: Assigning: "list_core_temp" = data that might be protected by the lock.
drivers/infiniband/hw/nes/nes_cm.c:468: unlock: Unlocking "cm_core->ht_lock". "list_core_temp" might now be unreliable because other threads can now change the data that it depends on.
drivers/infiniband/hw/nes/nes_cm.c:516: unlock: Unlocking "cm_node->recv_list_lock". "list_core_temp" might now be unreliable because other threads can now change the data that it depends on.
drivers/infiniband/hw/nes/nes_cm.c:551: unlock: Unlocking "cm_node->retrans_list_lock". "list_core_temp" might now be unreliable because other threads can now change the data that it depends on.
drivers/infiniband/hw/nes/nes_cm.c:616: unlock: Unlocking "cm_node->retrans_list_lock". "list_core_temp" might now be unreliable because other threads can now change the data that it depends on.
drivers/infiniband/hw/nes/nes_cm.c:618: lockagain: Locking "cm_core->ht_lock" again.
drivers/infiniband/hw/nes/nes_cm.c:464: use: Using an unreliable value of "list_core_temp" inside the second locked section.  If the data that "list_core_temp" depends on was changed by another thread, this use might be incorrect.

Error: ATOMICITY:
drivers/infiniband/hw/nes/nes_cm.c:618: lock: Locking "cm_core->ht_lock".
drivers/infiniband/hw/nes/nes_cm.c:464: def: Assigning: "list_core_temp" = data that might be protected by the lock.
drivers/infiniband/hw/nes/nes_cm.c:468: unlock: Unlocking "cm_core->ht_lock". "list_core_temp" might now be unreliable because other threads can now change the data that it depends on.
drivers/infiniband/hw/nes/nes_cm.c:516: unlock: Unlocking "cm_node->recv_list_lock". "list_core_temp" might now be unreliable because other threads can now change the data that it depends on.
drivers/infiniband/hw/nes/nes_cm.c:574: unlock: Unlocking "cm_node->retrans_list_lock". "list_core_temp" might now be unreliable because other threads can now change the data that it depends on.
drivers/infiniband/hw/nes/nes_cm.c:616: unlock: Unlocking "cm_node->retrans_list_lock". "list_core_temp" might now be unreliable because other threads can now change the data that it depends on.
drivers/infiniband/hw/nes/nes_cm.c:618: lockagain: Locking "cm_core->ht_lock" again.
drivers/infiniband/hw/nes/nes_cm.c:464: use: Using an unreliable value of "list_core_temp" inside the second locked section.  If the data that "list_core_temp" depends on was changed by another thread, this use might be incorrect.

Error: ATOMICITY:
drivers/infiniband/hw/nes/nes_cm.c:618: lock: Locking "cm_core->ht_lock".
drivers/infiniband/hw/nes/nes_cm.c:466: def: Assigning: "cm_node" = data that might be protected by the lock.
drivers/infiniband/hw/nes/nes_cm.c:468: unlock: Unlocking "cm_core->ht_lock". "cm_node" might now be unreliable because other threads can now change the data that it depends on.
drivers/infiniband/hw/nes/nes_cm.c:486: unlock: Unlocking "cm_node->recv_list_lock". "cm_node" might now be unreliable because other threads can now change the data that it depends on.
drivers/infiniband/hw/nes/nes_cm.c:498: unlock: Unlocking "nesqp->lock". "cm_node" might now be unreliable because other threads can now change the data that it depends on.
drivers/infiniband/hw/nes/nes_cm.c:516: unlock: Unlocking "cm_node->recv_list_lock". "cm_node" might now be unreliable because other threads can now change the data that it depends on.
drivers/infiniband/hw/nes/nes_cm.c:616: unlock: Unlocking "cm_node->retrans_list_lock". "cm_node" might now be unreliable because other threads can now change the data that it depends on.
drivers/infiniband/hw/nes/nes_cm.c:618: lockagain: Locking "cm_core->ht_lock" again.
drivers/infiniband/hw/nes/nes_cm.c:620: use: Using an unreliable value of "cm_node" inside the second locked section.  If the data that "cm_node" depends on was changed by another thread, this use might be incorrect.

Error: ATOMICITY:
drivers/infiniband/hw/nes/nes_cm.c:618: lock: Locking "cm_core->ht_lock".
drivers/infiniband/hw/nes/nes_cm.c:464: def: Assigning: "list_core_temp" = data that might be protected by the lock.
drivers/infiniband/hw/nes/nes_cm.c:468: unlock: Unlocking "cm_core->ht_lock". "list_core_temp" might now be unreliable because other threads can now change the data that it depends on.
drivers/infiniband/hw/nes/nes_cm.c:486: unlock: Unlocking "cm_node->recv_list_lock". "list_core_temp" might now be unreliable because other threads can now change the data that it depends on.
drivers/infiniband/hw/nes/nes_cm.c:498: unlock: Unlocking "nesqp->lock". "list_core_temp" might now be unreliable because other threads can now change the data that it depends on.
drivers/infiniband/hw/nes/nes_cm.c:516: unlock: Unlocking "cm_node->recv_list_lock". "list_core_temp" might now be unreliable because other threads can now change the data that it depends on.
drivers/infiniband/hw/nes/nes_cm.c:616: unlock: Unlocking "cm_node->retrans_list_lock". "list_core_temp" might now be unreliable because other threads can now change the data that it depends on.
drivers/infiniband/hw/nes/nes_cm.c:618: lockagain: Locking "cm_core->ht_lock" again.
drivers/infiniband/hw/nes/nes_cm.c:464: use: Using an unreliable value of "list_core_temp" inside the second locked section.  If the data that "list_core_temp" depends on was changed by another thread, this use might be incorrect.

Error: ATOMICITY:
drivers/infiniband/hw/nes/nes_cm.c:618: lock: Locking "cm_core->ht_lock".
drivers/infiniband/hw/nes/nes_cm.c:464: def: Assigning: "list_core_temp" = data that might be protected by the lock.
drivers/infiniband/hw/nes/nes_cm.c:468: unlock: Unlocking "cm_core->ht_lock". "list_core_temp" might now be unreliable because other threads can now change the data that it depends on.
drivers/infiniband/hw/nes/nes_cm.c:486: unlock: Unlocking "cm_node->recv_list_lock". "list_core_temp" might now be unreliable because other threads can now change the data that it depends on.
drivers/infiniband/hw/nes/nes_cm.c:498: unlock: Unlocking "nesqp->lock". "list_core_temp" might now be unreliable because other threads can now change the data that it depends on.
drivers/infiniband/hw/nes/nes_cm.c:516: unlock: Unlocking "cm_node->recv_list_lock". "list_core_temp" might now be unreliable because other threads can now change the data that it depends on.
drivers/infiniband/hw/nes/nes_cm.c:574: unlock: Unlocking "cm_node->retrans_list_lock". "list_core_temp" might now be unreliable because other threads can now change the data that it depends on.
drivers/infiniband/hw/nes/nes_cm.c:616: unlock: Unlocking "cm_node->retrans_list_lock". "list_core_temp" might now be unreliable because other threads can now change the data that it depends on.
drivers/infiniband/hw/nes/nes_cm.c:618: lockagain: Locking "cm_core->ht_lock" again.
drivers/infiniband/hw/nes/nes_cm.c:464: use: Using an unreliable value of "list_core_temp" inside the second locked section.  If the data that "list_core_temp" depends on was changed by another thread, this use might be incorrect.

Error: ATOMICITY:
drivers/usb/misc/usbtest.c:728: lock: Locking "ctx->lock".
drivers/usb/misc/usbtest.c:774: def: Assigning: "ctx->status" = data that might be protected by the lock.
drivers/usb/misc/usbtest.c:794: unlock: Unlocking "ctx->lock". "ctx->status" might now be unreliable because other threads can now change the data that it depends on.
drivers/usb/misc/usbtest.c:796: lockagain: Locking "ctx->lock" again.
drivers/usb/misc/usbtest.c:807: use: Using an unreliable value of "ctx->status" inside the second locked section.  If the data that "ctx->status" depends on was changed by another thread, this use might be incorrect.

Error: ATOMICITY:
drivers/scsi/scsi_netlink.c:451: lock: Locking "scsi_nl_lock".
drivers/scsi/scsi_netlink.c:454: def: Assigning: "driver" = data that might be protected by the lock.
drivers/scsi/scsi_netlink.c:458: unlock: Unlocking "scsi_nl_lock". "driver" might now be unreliable because other threads can now change the data that it depends on.
drivers/scsi/scsi_netlink.c:460: lockagain: Locking "scsi_nl_lock" again.
drivers/scsi/scsi_netlink.c:463: use: Using an unreliable value of "driver" inside the second locked section.  If the data that "driver" depends on was changed by another thread, this use might be incorrect.

Error: ATOMICITY:
drivers/usb/gadget/printer.c:723: lock: Locking "dev->lock".
drivers/usb/gadget/printer.c:733: def: Assigning: "req" = data that might be protected by the lock.
drivers/usb/gadget/printer.c:751: unlock: Unlocking "dev->lock". "req" might now be unreliable because other threads can now change the data that it depends on.
drivers/usb/gadget/printer.c:763: lockagain: Locking "dev->lock" again.
drivers/usb/gadget/printer.c:773: use: Using an unreliable value of "req" inside the second locked section.  If the data that "req" depends on was changed by another thread, this use might be incorrect.

Error: ATOMICITY:
net/unix/af_unix.c:1904: lock: Locking "((struct unix_sock *)sk)->lock".
net/unix/af_unix.c:1906: def: Assigning: "other" = data that might be protected by the lock.
net/unix/af_unix.c:1909: unlock: Unlocking "((struct unix_sock *)sk)->lock". "other" might now be unreliable because other threads can now change the data that it depends on.
net/unix/af_unix.c:1923: unlock: Unlocking "((struct unix_sock *)other)->lock". "other" might now be unreliable because other threads can now change the data that it depends on.
net/unix/af_unix.c:1925: lockagain: Locking "other->sk_callback_lock" again.
net/unix/af_unix.c:1927: use: Using an unreliable value of "other" inside the second locked section.  If the data that "other" depends on was changed by another thread, this use might be incorrect.

Error: ATOMICITY:
net/unix/af_unix.c:1904: lock: Locking "((struct unix_sock *)sk)->lock".
net/unix/af_unix.c:1906: def: Assigning: "other" = data that might be protected by the lock.
net/unix/af_unix.c:1909: unlock: Unlocking "((struct unix_sock *)sk)->lock". "other" might now be unreliable because other threads can now change the data that it depends on.
net/unix/af_unix.c:1923: unlock: Unlocking "((struct unix_sock *)other)->lock". "other" might now be unreliable because other threads can now change the data that it depends on.
net/unix/af_unix.c:1925: lockagain: Locking "other->sk_callback_lock" again.
net/unix/af_unix.c:1929: use: Using an unreliable value of "other" inside the second locked section.  If the data that "other" depends on was changed by another thread, this use might be incorrect.

Error: ATOMICITY:
sound/pci/via82xx_modem.c:491: lock: Locking "chip->reg_lock".
sound/pci/via82xx_modem.c:494: def: Assigning: "c_status" = data that might be protected by the lock.
sound/pci/via82xx_modem.c:499: unlock: Unlocking "chip->reg_lock". "c_status" might now be unreliable because other threads can now change the data that it depends on.
sound/pci/via82xx_modem.c:501: lockagain: Locking "chip->reg_lock" again.
sound/pci/via82xx_modem.c:503: use: Using an unreliable value of "c_status" inside the second locked section.  If the data that "c_status" depends on was changed by another thread, this use might be incorrect.

Error: ATOMICITY:
sound/pci/via82xx.c:669: lock: Locking "chip->reg_lock".
sound/pci/via82xx.c:680: def: Assigning: "c_status" = data that might be protected by the lock.
sound/pci/via82xx.c:698: unlock: Unlocking "chip->reg_lock". "c_status" might now be unreliable because other threads can now change the data that it depends on.
sound/pci/via82xx.c:702: lockagain: Locking "chip->reg_lock" again.
sound/pci/via82xx.c:705: use: Using an unreliable value of "c_status" inside the second locked section.  If the data that "c_status" depends on was changed by another thread, this use might be incorrect.

Error: ATOMICITY:
sound/pci/via82xx.c:702: lock: Locking "chip->reg_lock".
sound/pci/via82xx.c:680: def: Assigning: "c_status" = data that might be protected by the lock.
sound/pci/via82xx.c:698: unlock: Unlocking "chip->reg_lock". "c_status" might now be unreliable because other threads can now change the data that it depends on.
sound/pci/via82xx.c:702: lockagain: Locking "chip->reg_lock" again.
sound/pci/via82xx.c:705: use: Using an unreliable value of "c_status" inside the second locked section.  If the data that "c_status" depends on was changed by another thread, this use might be incorrect.

Error: ATOMICITY:
fs/jbd2/journal.c:168: lock: Locking "journal->j_state_lock".
fs/jbd2/journal.c:202: def: Assigning: "journal->j_commit_request" = data that might be protected by the lock.
fs/jbd2/journal.c:151: unlock: Unlocking "journal->j_state_lock". "journal->j_commit_request" might now be unreliable because other threads can now change the data that it depends on.
fs/jbd2/journal.c:154: lockagain: Locking "journal->j_state_lock" again.
fs/jbd2/journal.c:146: use: Using an unreliable value of "journal->j_commit_request" inside the second locked section.  If the data that "journal->j_commit_request" depends on was changed by another thread, this use might be incorrect.

Error: ATOMICITY:
drivers/acpi/sleep/proc.c:351: lock: Locking "acpi_device_lock".
drivers/acpi/sleep/proc.c:352: def: Assigning: "next" = data that might be protected by the lock.
drivers/acpi/sleep/proc.c:359: unlock: Unlocking "acpi_device_lock". "next" might now be unreliable because other threads can now change the data that it depends on.
drivers/acpi/sleep/proc.c:374: lockagain: Locking "acpi_device_lock" again.
drivers/acpi/sleep/proc.c:352: use: Using an unreliable value of "next" inside the second locked section.  If the data that "next" depends on was changed by another thread, this use might be incorrect.

Error: ATOMICITY:
sound/sound_core.c:527: lock: Locking "sound_loader_lock".
sound/sound_core.c:530: def: Assigning: "new_fops" = data that might be protected by the lock.
sound/sound_core.c:532: unlock: Unlocking "sound_loader_lock". "new_fops" might now be unreliable because other threads can now change the data that it depends on.
sound/sound_core.c:542: lockagain: Locking "sound_loader_lock" again.
sound/sound_core.c:557: use: Using an unreliable value of "new_fops" inside the second locked section.  If the data that "new_fops" depends on was changed by another thread, this use might be incorrect.

Error: ATOMICITY:
drivers/ata/libata-scsi.c:3545: lock: Locking "*ap->lock".
drivers/ata/libata-scsi.c:3548: def: Assigning: "dev" = data that might be protected by the lock.
drivers/ata/libata-scsi.c:3556: unlock: Unlocking "*ap->lock". "dev" might now be unreliable because other threads can now change the data that it depends on.
drivers/ata/libata-scsi.c:3559: lockagain: Locking "*ap->lock" again.
drivers/ata/libata-scsi.c:3551: use: Using an unreliable value of "dev" inside the second locked section.  If the data that "dev" depends on was changed by another thread, this use might be incorrect.

Error: ATOMICITY:
drivers/ata/libata-scsi.c:3545: lock: Locking "*ap->lock".
drivers/ata/libata-scsi.c:3547: def: Assigning: "link" = data that might be protected by the lock.
drivers/ata/libata-scsi.c:3556: unlock: Unlocking "*ap->lock". "link" might now be unreliable because other threads can now change the data that it depends on.
drivers/ata/libata-scsi.c:3559: lockagain: Locking "*ap->lock" again.
drivers/ata/libata-scsi.c:3548: use: Using an unreliable value of "link" inside the second locked section.  If the data that "link" depends on was changed by another thread, this use might be incorrect.

Error: ATOMICITY:
sound/isa/sb/sb16_main.c:765: lock: Locking "chip->mixer_lock".
sound/isa/sb/sb16_main.c:766: def: Assigning: "mpureg" = data that might be protected by the lock.
sound/isa/sb/sb16_main.c:767: unlock: Unlocking "chip->mixer_lock". "mpureg" might now be unreliable because other threads can now change the data that it depends on.
sound/isa/sb/sb16_main.c:825: lockagain: Locking "chip->mixer_lock" again.
sound/isa/sb/sb16_main.c:833: use: Using an unreliable value of "mpureg" inside the second locked section.  If the data that "mpureg" depends on was changed by another thread, this use might be incorrect.

Error: ATOMICITY:
drivers/net/bonding/bond_main.c:3148: lock: Locking "bond->lock".
drivers/net/bonding/bond_main.c:3153: def: Assigning: "delta_in_ticks" = data that might be protected by the lock.
drivers/net/bonding/bond_main.c:3161: unlock: Unlocking "bond->curr_slave_lock". "delta_in_ticks" might now be unreliable because other threads can now change the data that it depends on.
drivers/net/bonding/bond_main.c:3165: unlock: Unlocking "bond->lock". "delta_in_ticks" might now be unreliable because other threads can now change the data that it depends on.
drivers/net/bonding/bond_main.c:3167: lockagain: Locking "bond->lock" again.
drivers/net/bonding/bond_main.c:3169: use: Using an unreliable value of "delta_in_ticks" inside the second locked section.  If the data that "delta_in_ticks" depends on was changed by another thread, this use might be incorrect.

Error: ATOMICITY:
drivers/media/video/stk-webcam.c:379: lock: Locking "dev->spinlock".
drivers/media/video/stk-webcam.c:433: def: Assigning: "fb->v4lbuf.bytesused" = data that might be protected by the lock.
drivers/media/video/stk-webcam.c:457: unlock: Unlocking "dev->spinlock". "fb->v4lbuf.bytesused" might now be unreliable because other threads can now change the data that it depends on.
drivers/media/video/stk-webcam.c:459: lockagain: Locking "dev->spinlock" again.
drivers/media/video/stk-webcam.c:424: use: Using an unreliable value of "fb->v4lbuf.bytesused" inside the second locked section.  If the data that "fb->v4lbuf.bytesused" depends on was changed by another thread, this use might be incorrect.

Error: ATOMICITY:
drivers/media/video/stk-webcam.c:379: lock: Locking "dev->spinlock".
drivers/media/video/stk-webcam.c:396: def: Assigning: "i" = data that might be protected by the lock.
drivers/media/video/stk-webcam.c:457: unlock: Unlocking "dev->spinlock". "i" might now be unreliable because other threads can now change the data that it depends on.
drivers/media/video/stk-webcam.c:459: lockagain: Locking "dev->spinlock" again.
drivers/media/video/stk-webcam.c:399: use: Using an unreliable value of "i" inside the second locked section.  If the data that "i" depends on was changed by another thread, this use might be incorrect.

Error: ATOMICITY:
drivers/media/video/stk-webcam.c:379: lock: Locking "dev->spinlock".
drivers/media/video/stk-webcam.c:396: def: Assigning: "i" = data that might be protected by the lock.
drivers/media/video/stk-webcam.c:457: unlock: Unlocking "dev->spinlock". "i" might now be unreliable because other threads can now change the data that it depends on.
drivers/media/video/stk-webcam.c:459: lockagain: Locking "dev->spinlock" again.
drivers/media/video/stk-webcam.c:424: use: Using an unreliable value of "i" inside the second locked section.  If the data that "i" depends on was changed by another thread, this use might be incorrect.

Error: ATOMICITY:
drivers/media/video/stk-webcam.c:459: lock: Locking "dev->spinlock".
drivers/media/video/stk-webcam.c:428: def: Assigning: "fb->v4lbuf.bytesused" = data that might be protected by the lock.
drivers/media/video/stk-webcam.c:457: unlock: Unlocking "dev->spinlock". "fb->v4lbuf.bytesused" might now be unreliable because other threads can now change the data that it depends on.
drivers/media/video/stk-webcam.c:459: lockagain: Locking "dev->spinlock" again.
drivers/media/video/stk-webcam.c:424: use: Using an unreliable value of "fb->v4lbuf.bytesused" inside the second locked section.  If the data that "fb->v4lbuf.bytesused" depends on was changed by another thread, this use might be incorrect.

Error: ATOMICITY:
net/core/neighbour.c:785: lock: Locking "neigh->lock".
net/core/neighbour.c:802: def: Assigning: "next" = data that might be protected by the lock.
net/core/neighbour.c:855: unlock: Unlocking "neigh->lock". "next" might now be unreliable because other threads can now change the data that it depends on.
net/core/neighbour.c:857: lockagain: Locking "neigh->lock" again.
net/core/neighbour.c:865: use: Using an unreliable value of "next" inside the second locked section.  If the data that "next" depends on was changed by another thread, this use might be incorrect.

Error: ATOMICITY:
net/core/neighbour.c:785: lock: Locking "neigh->lock".
net/core/neighbour.c:831: def: Assigning: "next" = data that might be protected by the lock.
net/core/neighbour.c:855: unlock: Unlocking "neigh->lock". "next" might now be unreliable because other threads can now change the data that it depends on.
net/core/neighbour.c:857: lockagain: Locking "neigh->lock" again.
net/core/neighbour.c:865: use: Using an unreliable value of "next" inside the second locked section.  If the data that "next" depends on was changed by another thread, this use might be incorrect.

Error: ATOMICITY:
drivers/usb/misc/adutux.c:455: lock: Locking "dev->buflock".
drivers/usb/misc/adutux.c:466: def: Assigning: "dev->read_buffer_length" = data that might be protected by the lock.
drivers/usb/misc/adutux.c:467: unlock: Unlocking "dev->buflock". "dev->read_buffer_length" might now be unreliable because other threads can now change the data that it depends on.
drivers/usb/misc/adutux.c:455: lockagain: Locking "dev->buflock" again.
drivers/usb/misc/adutux.c:459: use: Using an unreliable value of "dev->read_buffer_length" inside the second locked section.  If the data that "dev->read_buffer_length" depends on was changed by another thread, this use might be incorrect.

Error: ATOMICITY:
drivers/usb/misc/adutux.c:455: lock: Locking "dev->buflock".
drivers/usb/misc/adutux.c:466: def: Assigning: "dev->read_buffer_length" = data that might be protected by the lock.
drivers/usb/misc/adutux.c:467: unlock: Unlocking "dev->buflock". "dev->read_buffer_length" might now be unreliable because other threads can now change the data that it depends on.
drivers/usb/misc/adutux.c:455: lockagain: Locking "dev->buflock" again.
drivers/usb/misc/adutux.c:465: use: Using an unreliable value of "dev->read_buffer_length" inside the second locked section.  If the data that "dev->read_buffer_length" depends on was changed by another thread, this use might be incorrect.

Error: ATOMICITY:
drivers/usb/misc/adutux.c:455: lock: Locking "dev->buflock".
drivers/usb/misc/adutux.c:463: def: Assigning: "dev->read_buffer_primary" = data that might be protected by the lock.
drivers/usb/misc/adutux.c:467: unlock: Unlocking "dev->buflock". "dev->read_buffer_primary" might now be unreliable because other threads can now change the data that it depends on.
drivers/usb/misc/adutux.c:455: lockagain: Locking "dev->buflock" again.
drivers/usb/misc/adutux.c:462: use: Using an unreliable value of "dev->read_buffer_primary" inside the second locked section.  If the data that "dev->read_buffer_primary" depends on was changed by another thread, this use might be incorrect.

Error: ATOMICITY:
drivers/usb/misc/adutux.c:455: lock: Locking "dev->buflock".
drivers/usb/misc/adutux.c:462: def: Assigning: "dev->read_buffer_secondary" = data that might be protected by the lock.
drivers/usb/misc/adutux.c:467: unlock: Unlocking "dev->buflock". "dev->read_buffer_secondary" might now be unreliable because other threads can now change the data that it depends on.
drivers/usb/misc/adutux.c:455: lockagain: Locking "dev->buflock" again.
drivers/usb/misc/adutux.c:461: use: Using an unreliable value of "dev->read_buffer_secondary" inside the second locked section.  If the data that "dev->read_buffer_secondary" depends on was changed by another thread, this use might be incorrect.

Error: ATOMICITY:
drivers/usb/misc/adutux.c:455: lock: Locking "dev->buflock".
drivers/usb/misc/adutux.c:466: def: Assigning: "dev->read_buffer_length" = data that might be protected by the lock.
drivers/usb/misc/adutux.c:467: unlock: Unlocking "dev->buflock". "dev->read_buffer_length" might now be unreliable because other threads can now change the data that it depends on.
drivers/usb/misc/adutux.c:480: unlock: Unlocking "dev->buflock". "dev->read_buffer_length" might now be unreliable because other threads can now change the data that it depends on.
drivers/usb/misc/adutux.c:506: unlock: Unlocking "dev->buflock". "dev->read_buffer_length" might now be unreliable because other threads can now change the data that it depends on.
drivers/usb/misc/adutux.c:455: lockagain: Locking "dev->buflock" again.
drivers/usb/misc/adutux.c:459: use: Using an unreliable value of "dev->read_buffer_length" inside the second locked section.  If the data that "dev->read_buffer_length" depends on was changed by another thread, this use might be incorrect.

Error: ATOMICITY:
drivers/usb/misc/adutux.c:455: lock: Locking "dev->buflock".
drivers/usb/misc/adutux.c:466: def: Assigning: "dev->read_buffer_length" = data that might be protected by the lock.
drivers/usb/misc/adutux.c:467: unlock: Unlocking "dev->buflock". "dev->read_buffer_length" might now be unreliable because other threads can now change the data that it depends on.
drivers/usb/misc/adutux.c:480: unlock: Unlocking "dev->buflock". "dev->read_buffer_length" might now be unreliable because other threads can now change the data that it depends on.
drivers/usb/misc/adutux.c:506: unlock: Unlocking "dev->buflock". "dev->read_buffer_length" might now be unreliable because other threads can now change the data that it depends on.
drivers/usb/misc/adutux.c:455: lockagain: Locking "dev->buflock" again.
drivers/usb/misc/adutux.c:465: use: Using an unreliable value of "dev->read_buffer_length" inside the second locked section.  If the data that "dev->read_buffer_length" depends on was changed by another thread, this use might be incorrect.

Error: ATOMICITY:
drivers/usb/misc/adutux.c:455: lock: Locking "dev->buflock".
drivers/usb/misc/adutux.c:463: def: Assigning: "dev->read_buffer_primary" = data that might be protected by the lock.
drivers/usb/misc/adutux.c:467: unlock: Unlocking "dev->buflock". "dev->read_buffer_primary" might now be unreliable because other threads can now change the data that it depends on.
drivers/usb/misc/adutux.c:480: unlock: Unlocking "dev->buflock". "dev->read_buffer_primary" might now be unreliable because other threads can now change the data that it depends on.
drivers/usb/misc/adutux.c:506: unlock: Unlocking "dev->buflock". "dev->read_buffer_primary" might now be unreliable because other threads can now change the data that it depends on.
drivers/usb/misc/adutux.c:455: lockagain: Locking "dev->buflock" again.
drivers/usb/misc/adutux.c:462: use: Using an unreliable value of "dev->read_buffer_primary" inside the second locked section.  If the data that "dev->read_buffer_primary" depends on was changed by another thread, this use might be incorrect.

Error: ATOMICITY:
drivers/usb/misc/adutux.c:455: lock: Locking "dev->buflock".
drivers/usb/misc/adutux.c:462: def: Assigning: "dev->read_buffer_secondary" = data that might be protected by the lock.
drivers/usb/misc/adutux.c:467: unlock: Unlocking "dev->buflock". "dev->read_buffer_secondary" might now be unreliable because other threads can now change the data that it depends on.
drivers/usb/misc/adutux.c:480: unlock: Unlocking "dev->buflock". "dev->read_buffer_secondary" might now be unreliable because other threads can now change the data that it depends on.
drivers/usb/misc/adutux.c:506: unlock: Unlocking "dev->buflock". "dev->read_buffer_secondary" might now be unreliable because other threads can now change the data that it depends on.
drivers/usb/misc/adutux.c:455: lockagain: Locking "dev->buflock" again.
drivers/usb/misc/adutux.c:461: use: Using an unreliable value of "dev->read_buffer_secondary" inside the second locked section.  If the data that "dev->read_buffer_secondary" depends on was changed by another thread, this use might be incorrect.

Error: ATOMICITY:
drivers/ieee1394/dv1394.c:1526: lock: Locking "video->spinlock".
drivers/ieee1394/dv1394.c:1528: def: Assigning: "video->first_clear_frame" = data that might be protected by the lock.
drivers/ieee1394/dv1394.c:1529: unlock: Unlocking "video->spinlock". "video->first_clear_frame" might now be unreliable because other threads can now change the data that it depends on.
drivers/ieee1394/dv1394.c:1474: lockagain: Locking "video->spinlock" again.
drivers/ieee1394/dv1394.c:1476: use: Using an unreliable value of "video->first_clear_frame" inside the second locked section.  If the data that "video->first_clear_frame" depends on was changed by another thread, this use might be incorrect.

Error: ATOMICITY:
fs/afs/vlocation.c:638: lock: Locking "afs_vlocation_updates_lock".
fs/afs/vlocation.c:646: def: Assigning: "vl" = data that might be protected by the lock.
fs/afs/vlocation.c:664: unlock: Unlocking "afs_vlocation_updates_lock". "vl" might now be unreliable because other threads can now change the data that it depends on.
fs/afs/vlocation.c:673: lockagain: Locking "vl->lock" again.
fs/afs/vlocation.c:676: use: Using an unreliable value of "vl" inside the second locked section.  If the data that "vl" depends on was changed by another thread, this use might be incorrect.

Error: ATOMICITY:
drivers/usb/serial/cypress_m8.c:1297: lock: Locking "priv->lock".
drivers/usb/serial/cypress_m8.c:1303: def: Assigning: "priv->current_status" = data that might be protected by the lock.
drivers/usb/serial/cypress_m8.c:1318: unlock: Unlocking "priv->lock". "priv->current_status" might now be unreliable because other threads can now change the data that it depends on.
drivers/usb/serial/cypress_m8.c:1328: lockagain: Locking "priv->lock" again.
drivers/usb/serial/cypress_m8.c:1334: use: Using an unreliable value of "priv->current_status" inside the second locked section.  If the data that "priv->current_status" depends on was changed by another thread, this use might be incorrect.

Error: ATOMICITY:
drivers/acpi/sleep/wakeup.c:152: lock: Locking "acpi_device_lock".
drivers/acpi/sleep/wakeup.c:153: def: Assigning: "next" = data that might be protected by the lock.
drivers/acpi/sleep/wakeup.c:160: unlock: Unlocking "acpi_device_lock". "next" might now be unreliable because other threads can now change the data that it depends on.
drivers/acpi/sleep/wakeup.c:167: lockagain: Locking "acpi_device_lock" again.
drivers/acpi/sleep/wakeup.c:153: use: Using an unreliable value of "next" inside the second locked section.  If the data that "next" depends on was changed by another thread, this use might be incorrect.

Error: ATOMICITY:
fs/proc/inode.c:340: lock: Locking "pde->pde_unload_lock".
fs/proc/inode.c:348: def: Assigning: "release" = data that might be protected by the lock.
fs/proc/inode.c:349: unlock: Unlocking "pde->pde_unload_lock". "release" might now be unreliable because other threads can now change the data that it depends on.
fs/proc/inode.c:354: lockagain: Locking "pde->pde_unload_lock" again.
fs/proc/inode.c:360: use: Using an unreliable value of "release" inside the second locked section.  If the data that "release" depends on was changed by another thread, this use might be incorrect.

Error: ATOMICITY:
drivers/usb/storage/usb.c:323: lock: Locking "*host->host_lock".
drivers/usb/storage/usb.c:411: def: Assigning: "us->srb" = data that might be protected by the lock.
drivers/usb/storage/usb.c:412: unlock: Unlocking "*host->host_lock". "us->srb" might now be unreliable because other threads can now change the data that it depends on.
drivers/usb/storage/usb.c:339: unlock: Unlocking "*host->host_lock". "us->srb" might now be unreliable because other threads can now change the data that it depends on.
drivers/usb/storage/usb.c:385: lockagain: Locking "*host->host_lock" again.
drivers/usb/storage/usb.c:391: use: Using an unreliable value of "us->srb" inside the second locked section.  If the data that "us->srb" depends on was changed by another thread, this use might be incorrect.

Error: ATOMICITY:
drivers/usb/c67x00/c67x00-sched.c:470: lock: Locking "c67x00->lock".
drivers/usb/c67x00/c67x00-sched.c:470: def: Assigning: "flags" = data that might be protected by the lock.
drivers/usb/c67x00/c67x00-sched.c:478: unlock: Unlocking "c67x00->lock". "flags" might now be unreliable because other threads can now change the data that it depends on.
drivers/usb/c67x00/c67x00-sched.c:480: lockagain: Locking "c67x00->lock" again.
drivers/usb/c67x00/c67x00-sched.c:482: use: Using an unreliable value of "flags" inside the second locked section.  If the data that "flags" depends on was changed by another thread, this use might be incorrect.

Error: ATOMICITY:
drivers/block/DAC960.c:6773: lock: Locking "Controller->queue_lock".
drivers/block/DAC960.c:6774: def: Assigning: "Command" = data that might be protected by the lock.
drivers/block/DAC960.c:6787: unlock: Unlocking "Controller->queue_lock". "Command" might now be unreliable because other threads can now change the data that it depends on.
drivers/block/DAC960.c:6812: lockagain: Locking "Controller->queue_lock" again.
drivers/block/DAC960.c:6813: use: Using an unreliable value of "Command" inside the second locked section.  If the data that "Command" depends on was changed by another thread, this use might be incorrect.

Error: ATOMICITY:
drivers/block/DAC960.c:6773: lock: Locking "Controller->queue_lock".
drivers/block/DAC960.c:6773: def: Assigning: "flags" = data that might be protected by the lock.
drivers/block/DAC960.c:6779: unlock: Unlocking "Controller->queue_lock". "flags" might now be unreliable because other threads can now change the data that it depends on.
drivers/block/DAC960.c:6783: lockagain: Locking "Controller->queue_lock" again.
drivers/block/DAC960.c:6787: use: Using an unreliable value of "flags" inside the second locked section.  If the data that "flags" depends on was changed by another thread, this use might be incorrect.

Error: ATOMICITY:
drivers/block/DAC960.c:6919: lock: Locking "Controller->queue_lock".
drivers/block/DAC960.c:6920: def: Assigning: "Command" = data that might be protected by the lock.
drivers/block/DAC960.c:6922: unlock: Unlocking "Controller->queue_lock". "Command" might now be unreliable because other threads can now change the data that it depends on.
drivers/block/DAC960.c:6970: lockagain: Locking "Controller->queue_lock" again.
drivers/block/DAC960.c:6971: use: Using an unreliable value of "Command" inside the second locked section.  If the data that "Command" depends on was changed by another thread, this use might be incorrect.

Error: ATOMICITY:
drivers/block/DAC960.c:6773: lock: Locking "Controller->queue_lock".
drivers/block/DAC960.c:6774: def: Assigning: "Command" = data that might be protected by the lock.
drivers/block/DAC960.c:6779: unlock: Unlocking "Controller->queue_lock". "Command" might now be unreliable because other threads can now change the data that it depends on.
drivers/block/DAC960.c:6787: unlock: Unlocking "Controller->queue_lock". "Command" might now be unreliable because other threads can now change the data that it depends on.
drivers/block/DAC960.c:6812: lockagain: Locking "Controller->queue_lock" again.
drivers/block/DAC960.c:6813: use: Using an unreliable value of "Command" inside the second locked section.  If the data that "Command" depends on was changed by another thread, this use might be incorrect.

Error: ATOMICITY:
drivers/infiniband/core/mad.c:2366: lock: Locking "mad_agent_priv->lock".
drivers/infiniband/core/mad.c:2368: def: Assigning: "local" = data that might be protected by the lock.
drivers/infiniband/core/mad.c:2372: unlock: Unlocking "mad_agent_priv->lock". "local" might now be unreliable because other threads can now change the data that it depends on.
drivers/infiniband/core/mad.c:2423: lockagain: Locking "mad_agent_priv->lock" again.
drivers/infiniband/core/mad.c:2427: use: Using an unreliable value of "local" inside the second locked section.  If the data that "local" depends on was changed by another thread, this use might be incorrect.

Error: ATOMICITY:
drivers/usb/host/isp116x-hcd.c:1410: lock: Locking "isp116x->lock".
drivers/usb/host/isp116x-hcd.c:1411: def: Assigning: "val" = data that might be protected by the lock.
drivers/usb/host/isp116x-hcd.c:1415: unlock: Unlocking "isp116x->lock". "val" might now be unreliable because other threads can now change the data that it depends on.
drivers/usb/host/isp116x-hcd.c:1422: lockagain: Locking "isp116x->lock" again.
drivers/usb/host/isp116x-hcd.c:1423: use: Using an unreliable value of "val" inside the second locked section.  If the data that "val" depends on was changed by another thread, this use might be incorrect.

Error: ATOMICITY:
fs/jfs/jfs_logmgr.c:2348: lock: Locking "log_redrive_lock".
fs/jfs/jfs_logmgr.c:2350: def: Assigning: "log_redrive_list" = data that might be protected by the lock.
fs/jfs/jfs_logmgr.c:2352: unlock: Unlocking "log_redrive_lock". "log_redrive_list" might now be unreliable because other threads can now change the data that it depends on.
fs/jfs/jfs_logmgr.c:2354: lockagain: Locking "log_redrive_lock" again.
fs/jfs/jfs_logmgr.c:2349: use: Using an unreliable value of "log_redrive_list" inside the second locked section.  If the data that "log_redrive_list" depends on was changed by another thread, this use might be incorrect.

Error: ATOMICITY:
drivers/misc/tifm_7xx1.c:148: lock: Locking "fm->lock".
drivers/misc/tifm_7xx1.c:169: def: Assigning: "sock_addr" = data that might be protected by the lock.
drivers/misc/tifm_7xx1.c:170: unlock: Unlocking "fm->lock". "sock_addr" might now be unreliable because other threads can now change the data that it depends on.
drivers/misc/tifm_7xx1.c:172: lockagain: Locking "fm->lock" again.
drivers/misc/tifm_7xx1.c:173: use: Using an unreliable value of "sock_addr" inside the second locked section.  If the data that "sock_addr" depends on was changed by another thread, this use might be incorrect.

Error: ATOMICITY:
drivers/misc/tifm_7xx1.c:188: lock: Locking "fm->lock".
drivers/misc/tifm_7xx1.c:190: def: Assigning: "fm->sockets[cnt]" = data that might be protected by the lock.
drivers/misc/tifm_7xx1.c:193: unlock: Unlocking "fm->lock". "fm->sockets[cnt]" might now be unreliable because other threads can now change the data that it depends on.
drivers/misc/tifm_7xx1.c:198: lockagain: Locking "fm->lock" again.
drivers/misc/tifm_7xx1.c:163: use: Using an unreliable value of "fm->sockets[cnt]" inside the second locked section.  If the data that "fm->sockets[cnt]" depends on was changed by another thread, this use might be incorrect.

Error: ATOMICITY:
drivers/misc/tifm_7xx1.c:148: lock: Locking "fm->lock".
drivers/misc/tifm_7xx1.c:160: def: Assigning: "cnt" = data that might be protected by the lock.
drivers/misc/tifm_7xx1.c:170: unlock: Unlocking "fm->lock". "cnt" might now be unreliable because other threads can now change the data that it depends on.
drivers/misc/tifm_7xx1.c:177: unlock: Unlocking "fm->lock". "cnt" might now be unreliable because other threads can now change the data that it depends on.
drivers/misc/tifm_7xx1.c:193: unlock: Unlocking "fm->lock". "cnt" might now be unreliable because other threads can now change the data that it depends on.
drivers/misc/tifm_7xx1.c:198: lockagain: Locking "fm->lock" again.
drivers/misc/tifm_7xx1.c:165: use: Using an unreliable value of "cnt" inside the second locked section.  If the data that "cnt" depends on was changed by another thread, this use might be incorrect.

Error: ATOMICITY:
sound/pci/au88x0/au88x0_core.c:2430: lock: Locking "vortex->lock".
sound/pci/au88x0/au88x0_core.c:2431: def: Assigning: "i" = data that might be protected by the lock.
sound/pci/au88x0/au88x0_core.c:2434: unlock: Unlocking "vortex->lock". "i" might now be unreliable because other threads can now change the data that it depends on.
sound/pci/au88x0/au88x0_core.c:2437: lockagain: Locking "vortex->lock" again.
sound/pci/au88x0/au88x0_core.c:2433: use: Using an unreliable value of "i" inside the second locked section.  If the data that "i" depends on was changed by another thread, this use might be incorrect.

Error: ATOMICITY:
sound/pci/au88x0/au88x0_core.c:2437: lock: Locking "vortex->lock".
sound/pci/au88x0/au88x0_core.c:2441: def: Assigning: "i" = data that might be protected by the lock.
sound/pci/au88x0/au88x0_core.c:2444: unlock: Unlocking "vortex->lock". "i" might now be unreliable because other threads can now change the data that it depends on.
sound/pci/au88x0/au88x0_core.c:2447: lockagain: Locking "vortex->lock" again.
sound/pci/au88x0/au88x0_core.c:2443: use: Using an unreliable value of "i" inside the second locked section.  If the data that "i" depends on was changed by another thread, this use might be incorrect.

Error: ATOMICITY:
drivers/net/wireless/libertas/if_sdio.c:342: lock: Locking "card->lock".
drivers/net/wireless/libertas/if_sdio.c:345: def: Assigning: "card->packets" = data that might be protected by the lock.
drivers/net/wireless/libertas/if_sdio.c:346: unlock: Unlocking "card->lock". "card->packets" might now be unreliable because other threads can now change the data that it depends on.
drivers/net/wireless/libertas/if_sdio.c:342: lockagain: Locking "card->lock" again.
drivers/net/wireless/libertas/if_sdio.c:343: use: Using an unreliable value of "card->packets" inside the second locked section.  If the data that "card->packets" depends on was changed by another thread, this use might be incorrect.

Error: ATOMICITY:
drivers/usb/host/ohci-hcd.c:325: lock: Locking "ohci->lock".
drivers/usb/host/ohci-hcd.c:329: def: Assigning: "ed->state" = data that might be protected by the lock.
drivers/usb/host/ohci-hcd.c:347: unlock: Unlocking "ohci->lock". "ed->state" might now be unreliable because other threads can now change the data that it depends on.
drivers/usb/host/ohci-hcd.c:325: lockagain: Locking "ohci->lock" again.
drivers/usb/host/ohci-hcd.c:361: use: Using an unreliable value of "ed->state" inside the second locked section.  If the data that "ed->state" depends on was changed by another thread, this use might be incorrect.

Error: ATOMICITY:
fs/ocfs2/dlm/dlmmaster.c:2257: lock: Locking "dlm->spinlock".
fs/ocfs2/dlm/dlmmaster.c:2258: def: Assigning: "res" = data that might be protected by the lock.
fs/ocfs2/dlm/dlmmaster.c:2265: unlock: Unlocking "dlm->spinlock". "res" might now be unreliable because other threads can now change the data that it depends on.
fs/ocfs2/dlm/dlmmaster.c:2267: lockagain: Locking "res->spinlock" again.
fs/ocfs2/dlm/dlmmaster.c:2273: use: Using an unreliable value of "res" inside the second locked section.  If the data that "res" depends on was changed by another thread, this use might be incorrect.

Error: ATOMICITY:
drivers/usb/serial/belkin_sa.c:371: lock: Locking "priv->lock".
drivers/usb/serial/belkin_sa.c:372: def: Assigning: "control_state" = data that might be protected by the lock.
drivers/usb/serial/belkin_sa.c:374: unlock: Unlocking "priv->lock". "control_state" might now be unreliable because other threads can now change the data that it depends on.
drivers/usb/serial/belkin_sa.c:485: lockagain: Locking "priv->lock" again.
drivers/usb/serial/belkin_sa.c:486: use: Using an unreliable value of "control_state" inside the second locked section.  If the data that "control_state" depends on was changed by another thread, this use might be incorrect.

Error: ATOMICITY:
drivers/media/video/cafe_ccic.c:1827: lock: Locking "cam->dev_lock".
drivers/media/video/cafe_ccic.c:1835: def: Assigning: "cam->next_buf" = data that might be protected by the lock.
drivers/media/video/cafe_ccic.c:1846: unlock: Unlocking "cam->dev_lock". "cam->next_buf" might now be unreliable because other threads can now change the data that it depends on.
drivers/media/video/cafe_ccic.c:1853: lockagain: Locking "cam->dev_lock" again.
drivers/media/video/cafe_ccic.c:1829: use: Using an unreliable value of "cam->next_buf" inside the second locked section.  If the data that "cam->next_buf" depends on was changed by another thread, this use might be incorrect.

Error: ATOMICITY:
fs/fuse/dev.c:884: lock: Locking "fc->lock".
fs/fuse/dev.c:889: def: Assigning: "req" = data that might be protected by the lock.
fs/fuse/dev.c:894: unlock: Unlocking "fc->lock". "req" might now be unreliable because other threads can now change the data that it depends on.
fs/fuse/dev.c:896: lockagain: Locking "fc->lock" again.
fs/fuse/dev.c:897: use: Using an unreliable value of "req" inside the second locked section.  If the data that "req" depends on was changed by another thread, this use might be incorrect.

Error: ATOMICITY:
fs/fuse/dev.c:884: lock: Locking "fc->lock".
fs/fuse/dev.c:889: def: Assigning: "req" = data that might be protected by the lock.
fs/fuse/dev.c:921: unlock: Unlocking "fc->lock". "req" might now be unreliable because other threads can now change the data that it depends on.
fs/fuse/dev.c:926: lockagain: Locking "fc->lock" again.
fs/fuse/dev.c:933: use: Using an unreliable value of "req" inside the second locked section.  If the data that "req" depends on was changed by another thread, this use might be incorrect.

Error: ATOMICITY:
drivers/usb/wusbcore/wa-xfer.c:1049: lock: Locking "wa->xfer_list_lock".
drivers/usb/wusbcore/wa-xfer.c:1050: def: Assigning: "next" = data that might be protected by the lock.
drivers/usb/wusbcore/wa-xfer.c:1053: unlock: Unlocking "wa->xfer_list_lock". "next" might now be unreliable because other threads can now change the data that it depends on.
drivers/usb/wusbcore/wa-xfer.c:1059: lockagain: Locking "wa->xfer_list_lock" again.
drivers/usb/wusbcore/wa-xfer.c:1050: use: Using an unreliable value of "next" inside the second locked section.  If the data that "next" depends on was changed by another thread, this use might be incorrect.

Error: ATOMICITY:
drivers/usb/wusbcore/wa-xfer.c:1059: lock: Locking "wa->xfer_list_lock".
drivers/usb/wusbcore/wa-xfer.c:1050: def: Assigning: "next" = data that might be protected by the lock.
drivers/usb/wusbcore/wa-xfer.c:1053: unlock: Unlocking "wa->xfer_list_lock". "next" might now be unreliable because other threads can now change the data that it depends on.
drivers/usb/wusbcore/wa-xfer.c:1059: lockagain: Locking "wa->xfer_list_lock" again.
drivers/usb/wusbcore/wa-xfer.c:1050: use: Using an unreliable value of "next" inside the second locked section.  If the data that "next" depends on was changed by another thread, this use might be incorrect.

Error: ATOMICITY:
fs/jbd/journal.c:164: lock: Locking "journal->j_state_lock".
fs/jbd/journal.c:198: def: Assigning: "journal->j_commit_request" = data that might be protected by the lock.
fs/jbd/journal.c:147: unlock: Unlocking "journal->j_state_lock". "journal->j_commit_request" might now be unreliable because other threads can now change the data that it depends on.
fs/jbd/journal.c:150: lockagain: Locking "journal->j_state_lock" again.
fs/jbd/journal.c:142: use: Using an unreliable value of "journal->j_commit_request" inside the second locked section.  If the data that "journal->j_commit_request" depends on was changed by another thread, this use might be incorrect.

Error: ATOMICITY:
fs/exec.c:142: lock: Locking "binfmt_lock".
fs/exec.c:143: def: Assigning: "fmt" = data that might be protected by the lock.
fs/exec.c:148: unlock: Unlocking "binfmt_lock". "fmt" might now be unreliable because other threads can now change the data that it depends on.
fs/exec.c:150: lockagain: Locking "binfmt_lock" again.
fs/exec.c:151: use: Using an unreliable value of "fmt" inside the second locked section.  If the data that "fmt" depends on was changed by another thread, this use might be incorrect.

Error: ATOMICITY:
sound/core/timer.c:619: lock: Locking "timer->lock".
sound/core/timer.c:619: def: Assigning: "flags" = data that might be protected by the lock.
sound/core/timer.c:633: unlock: Unlocking "timer->lock". "flags" might now be unreliable because other threads can now change the data that it depends on.
sound/core/timer.c:636: lockagain: Locking "timer->lock" again.
sound/core/timer.c:639: use: Using an unreliable value of "flags" inside the second locked section.  If the data that "flags" depends on was changed by another thread, this use might be incorrect.

Error: ATOMICITY:
fs/dquot.c:484: lock: Locking "dq_list_lock".
fs/dquot.c:485: def: Assigning: "dirty" = data that might be protected by the lock.
fs/dquot.c:498: unlock: Unlocking "dq_list_lock". "dirty" might now be unreliable because other threads can now change the data that it depends on.
fs/dquot.c:501: lockagain: Locking "dq_list_lock" again.
fs/dquot.c:486: use: Using an unreliable value of "dirty" inside the second locked section.  If the data that "dirty" depends on was changed by another thread, this use might be incorrect.

Error: ATOMICITY:
sound/pci/via82xx.c:630: lock: Locking "chip->reg_lock".
sound/pci/via82xx.c:633: def: Assigning: "c_status" = data that might be protected by the lock.
sound/pci/via82xx.c:647: unlock: Unlocking "chip->reg_lock". "c_status" might now be unreliable because other threads can now change the data that it depends on.
sound/pci/via82xx.c:649: lockagain: Locking "chip->reg_lock" again.
sound/pci/via82xx.c:652: use: Using an unreliable value of "c_status" inside the second locked section.  If the data that "c_status" depends on was changed by another thread, this use might be incorrect.

Error: ATOMICITY:
fs/dcache.c:2107: lock: Locking "get_current()->fs->lock".
fs/dcache.c:2110: def: Assigning: "root" = data that might be protected by the lock.
fs/dcache.c:2112: unlock: Unlocking "get_current()->fs->lock". "root" might now be unreliable because other threads can now change the data that it depends on.
fs/dcache.c:2116: lockagain: Locking "dcache_lock" again.
fs/dcache.c:2119: use: Using an unreliable value of "root" inside the second locked section.  If the data that "root" depends on was changed by another thread, this use might be incorrect.

Error: ATOMICITY:
drivers/rtc/rtc-dev.c:155: lock: Locking "rtc->irq_lock".
drivers/rtc/rtc-dev.c:157: def: Assigning: "rtc->irq_data" = data that might be protected by the lock.
drivers/rtc/rtc-dev.c:158: unlock: Unlocking "rtc->irq_lock". "rtc->irq_data" might now be unreliable because other threads can now change the data that it depends on.
drivers/rtc/rtc-dev.c:155: lockagain: Locking "rtc->irq_lock" again.
drivers/rtc/rtc-dev.c:156: use: Using an unreliable value of "rtc->irq_data" inside the second locked section.  If the data that "rtc->irq_data" depends on was changed by another thread, this use might be incorrect.

Error: ATOMICITY:
drivers/char/hpet.c:304: lock: Locking "hpet_lock".
drivers/char/hpet.c:306: def: Assigning: "devp->hd_irqdata" = data that might be protected by the lock.
drivers/char/hpet.c:307: unlock: Unlocking "hpet_lock". "devp->hd_irqdata" might now be unreliable because other threads can now change the data that it depends on.
drivers/char/hpet.c:304: lockagain: Locking "hpet_lock" again.
drivers/char/hpet.c:305: use: Using an unreliable value of "devp->hd_irqdata" inside the second locked section.  If the data that "devp->hd_irqdata" depends on was changed by another thread, this use might be incorrect.

Error: ATOMICITY:
drivers/net/pcnet32.c:1079: lock: Locking "lp->lock".
drivers/net/pcnet32.c:1081: def: Assigning: "regs[i - 4]" = data that might be protected by the lock.
drivers/net/pcnet32.c:1083: unlock: Unlocking "lp->lock". "regs[i - 4]" might now be unreliable because other threads can now change the data that it depends on.
drivers/net/pcnet32.c:1096: lockagain: Locking "lp->lock" again.
drivers/net/pcnet32.c:1098: use: Using an unreliable value of "regs[i - 4]" inside the second locked section.  If the data that "regs[i - 4]" depends on was changed by another thread, this use might be incorrect.

Error: ATOMICITY:
drivers/block/cciss.c:2898: lock: Locking "*q->queue_lock".
drivers/block/cciss.c:2798: def: Assigning: "c" = data that might be protected by the lock.
drivers/block/cciss.c:2803: unlock: Unlocking "*q->queue_lock". "c" might now be unreliable because other threads can now change the data that it depends on.
drivers/block/cciss.c:2898: lockagain: Locking "*q->queue_lock" again.
drivers/block/cciss.c:2900: use: Using an unreliable value of "c" inside the second locked section.  If the data that "c" depends on was changed by another thread, this use might be incorrect.

Error: ATOMICITY:
net/unix/af_unix.c:1054: lock: Locking "((struct unix_sock *)other)->lock".
net/unix/af_unix.c:1072: def: Assigning: "timeo" = data that might be protected by the lock.
net/unix/af_unix.c:1058: unlock: Unlocking "((struct unix_sock *)other)->lock". "timeo" might now be unreliable because other threads can now change the data that it depends on.
net/unix/af_unix.c:1054: lockagain: Locking "((struct unix_sock *)other)->lock" again.
net/unix/af_unix.c:1072: use: Using an unreliable value of "timeo" inside the second locked section.  If the data that "timeo" depends on was changed by another thread, this use might be incorrect.

Error: ATOMICITY:
net/unix/af_unix.c:1054: lock: Locking "((struct unix_sock *)other)->lock".
net/unix/af_unix.c:1072: def: Assigning: "timeo" = data that might be protected by the lock.
net/unix/af_unix.c:1058: unlock: Unlocking "((struct unix_sock *)other)->lock". "timeo" might now be unreliable because other threads can now change the data that it depends on.
net/unix/af_unix.c:1110: unlock: Unlocking "((struct unix_sock *)sk)->lock". "timeo" might now be unreliable because other threads can now change the data that it depends on.
net/unix/af_unix.c:1111: unlock: Unlocking "((struct unix_sock *)other)->lock". "timeo" might now be unreliable because other threads can now change the data that it depends on.
net/unix/af_unix.c:1054: lockagain: Locking "((struct unix_sock *)other)->lock" again.
net/unix/af_unix.c:1072: use: Using an unreliable value of "timeo" inside the second locked section.  If the data that "timeo" depends on was changed by another thread, this use might be incorrect.

Error: ATOMICITY:
drivers/net/wireless/libertas/if_cs.c:490: lock: Locking "priv->driver_lock".
drivers/net/wireless/libertas/if_cs.c:491: def: Assigning: "i" = data that might be protected by the lock.
drivers/net/wireless/libertas/if_cs.c:492: unlock: Unlocking "priv->driver_lock". "i" might now be unreliable because other threads can now change the data that it depends on.
drivers/net/wireless/libertas/if_cs.c:498: lockagain: Locking "priv->driver_lock" again.
drivers/net/wireless/libertas/if_cs.c:499: use: Using an unreliable value of "i" inside the second locked section.  If the data that "i" depends on was changed by another thread, this use might be incorrect.

Error: ATOMICITY:
drivers/usb/gadget/inode.c:981: lock: Locking "dev->lock".
drivers/usb/gadget/inode.c:991: def: Assigning: "state" = data that might be protected by the lock.
drivers/usb/gadget/inode.c:1113: unlock: Unlocking "dev->lock". "state" might now be unreliable because other threads can now change the data that it depends on.
drivers/usb/gadget/inode.c:1121: lockagain: Locking "dev->lock" again.
drivers/usb/gadget/inode.c:1108: use: Using an unreliable value of "state" inside the second locked section.  If the data that "state" depends on was changed by another thread, this use might be incorrect.

Error: ATOMICITY:
drivers/net/niu.c:6834: lock: Locking "np->parent->lock".
drivers/net/niu.c:6835: def: Assigning: "flow_key" = data that might be protected by the lock.
drivers/net/niu.c:6842: unlock: Unlocking "np->parent->lock". "flow_key" might now be unreliable because other threads can now change the data that it depends on.
drivers/net/niu.c:6849: lockagain: Locking "np->parent->lock" again.
drivers/net/niu.c:6850: use: Using an unreliable value of "flow_key" inside the second locked section.  If the data that "flow_key" depends on was changed by another thread, this use might be incorrect.

Error: ATOMICITY:
mm/swapfile.c:1253: lock: Locking "swap_lock".
mm/swapfile.c:1275: def: Assigning: "swap_list.head" = data that might be protected by the lock.
mm/swapfile.c:1291: unlock: Unlocking "swap_lock". "swap_list.head" might now be unreliable because other threads can now change the data that it depends on.
mm/swapfile.c:1299: lockagain: Locking "swap_lock" again.
mm/swapfile.c:1303: use: Using an unreliable value of "swap_list.head" inside the second locked section.  If the data that "swap_list.head" depends on was changed by another thread, this use might be incorrect.

Error: ATOMICITY:
fs/ocfs2/dlm/dlmconvert.c:467: lock: Locking "res->spinlock".
fs/ocfs2/dlm/dlmconvert.c:475: def: Assigning: "lock" = data that might be protected by the lock.
fs/ocfs2/dlm/dlmconvert.c:483: unlock: Unlocking "res->spinlock". "lock" might now be unreliable because other threads can now change the data that it depends on.
fs/ocfs2/dlm/dlmconvert.c:507: lockagain: Locking "res->spinlock" again.
fs/ocfs2/dlm/dlmconvert.c:513: use: Using an unreliable value of "lock" inside the second locked section.  If the data that "lock" depends on was changed by another thread, this use might be incorrect.

Error: ATOMICITY:
fs/libfs.c:152: lock: Locking "dcache_lock".
fs/libfs.c:156: def: Assigning: "p" = data that might be protected by the lock.
fs/libfs.c:162: unlock: Unlocking "dcache_lock". "p" might now be unreliable because other threads can now change the data that it depends on.
fs/libfs.c:168: lockagain: Locking "dcache_lock" again.
fs/libfs.c:170: use: Using an unreliable value of "p" inside the second locked section.  If the data that "p" depends on was changed by another thread, this use might be incorrect.

Error: ATOMICITY:
drivers/scsi/tmscsim.c:834: lock: Locking "*pACB->pScsiHost->host_lock".
drivers/scsi/tmscsim.c:831: def: Assigning: "dstate" = data that might be protected by the lock.
drivers/scsi/tmscsim.c:832: unlock: Unlocking "*pACB->pScsiHost->host_lock". "dstate" might now be unreliable because other threads can now change the data that it depends on.
drivers/scsi/tmscsim.c:834: lockagain: Locking "*pACB->pScsiHost->host_lock" again.
drivers/scsi/tmscsim.c:839: use: Using an unreliable value of "dstate" inside the second locked section.  If the data that "dstate" depends on was changed by another thread, this use might be incorrect.

Error: ATOMICITY:
drivers/infiniband/ulp/ipoib/ipoib_cm.c:1299: lock: Locking "priv->lock".
drivers/infiniband/ulp/ipoib/ipoib_cm.c:1302: def: Assigning: "p" = data that might be protected by the lock.
drivers/infiniband/ulp/ipoib/ipoib_cm.c:1308: unlock: Unlocking "priv->lock". "p" might now be unreliable because other threads can now change the data that it depends on.
drivers/infiniband/ulp/ipoib/ipoib_cm.c:1309: unlock: Unlocking "dev->tx_global_lock". "p" might now be unreliable because other threads can now change the data that it depends on.
drivers/infiniband/ulp/ipoib/ipoib_cm.c:1314: lockagain: Locking "priv->lock" again.
drivers/infiniband/ulp/ipoib/ipoib_cm.c:1326: use: Using an unreliable value of "p" inside the second locked section.  If the data that "p" depends on was changed by another thread, this use might be incorrect.

Error: ATOMICITY:
drivers/block/cciss_scsi.c:1440: lock: Locking "hba[ctlr]->lock".
drivers/block/cciss_scsi.c:1441: def: Assigning: "cp" = data that might be protected by the lock.
drivers/block/cciss_scsi.c:1442: unlock: Unlocking "hba[ctlr]->lock". "cp" might now be unreliable because other threads can now change the data that it depends on.
drivers/block/cciss_scsi.c:1504: lockagain: Locking "hba[ctlr]->lock" again.
drivers/block/cciss_scsi.c:1505: use: Using an unreliable value of "cp" inside the second locked section.  If the data that "cp" depends on was changed by another thread, this use might be incorrect.

Error: ATOMICITY:
drivers/usb/host/uhci-hcd.c:861: lock: Locking "uhci->lock".
drivers/usb/host/uhci-hcd.c:862: def: Assigning: "qh" = data that might be protected by the lock.
drivers/usb/host/uhci-hcd.c:868: unlock: Unlocking "uhci->lock". "qh" might now be unreliable because other threads can now change the data that it depends on.
drivers/usb/host/uhci-hcd.c:871: lockagain: Locking "uhci->lock" again.
drivers/usb/host/uhci-hcd.c:875: use: Using an unreliable value of "qh" inside the second locked section.  If the data that "qh" depends on was changed by another thread, this use might be incorrect.

Error: ATOMICITY:
fs/ocfs2/dlm/dlmmaster.c:1421: lock: Locking "dlm->spinlock".
fs/ocfs2/dlm/dlmmaster.c:1422: def: Assigning: "res" = data that might be protected by the lock.
fs/ocfs2/dlm/dlmmaster.c:1424: unlock: Unlocking "dlm->spinlock". "res" might now be unreliable because other threads can now change the data that it depends on.
fs/ocfs2/dlm/dlmmaster.c:1427: lockagain: Locking "res->spinlock" again.
fs/ocfs2/dlm/dlmmaster.c:1442: use: Using an unreliable value of "res" inside the second locked section.  If the data that "res" depends on was changed by another thread, this use might be incorrect.

Error: ATOMICITY:
fs/ocfs2/dlm/dlmmaster.c:1421: lock: Locking "dlm->spinlock".
fs/ocfs2/dlm/dlmmaster.c:1422: def: Assigning: "res" = data that might be protected by the lock.
fs/ocfs2/dlm/dlmmaster.c:1424: unlock: Unlocking "dlm->spinlock". "res" might now be unreliable because other threads can now change the data that it depends on.
fs/ocfs2/dlm/dlmmaster.c:1482: lockagain: Locking "tmpmle->spinlock" again.
fs/ocfs2/dlm/dlmmaster.c:1507: use: Using an unreliable value of "res" inside the second locked section.  If the data that "res" depends on was changed by another thread, this use might be incorrect.

Error: ATOMICITY:
fs/afs/flock.c:132: lock: Locking "vnode->lock".
fs/afs/flock.c:179: def: Assigning: "fl" = data that might be protected by the lock.
fs/afs/flock.c:184: unlock: Unlocking "vnode->lock". "fl" might now be unreliable because other threads can now change the data that it depends on.
fs/afs/flock.c:200: lockagain: Locking "vnode->lock" again.
fs/afs/flock.c:207: use: Using an unreliable value of "fl" inside the second locked section.  If the data that "fl" depends on was changed by another thread, this use might be incorrect.

Error: ATOMICITY:
sound/pci/au88x0/au88x0_core.c:2430: lock: Locking "vortex->lock".
sound/pci/au88x0/au88x0_core.c:2431: def: Assigning: "i" = data that might be protected by the lock.
sound/pci/au88x0/au88x0_core.c:2434: unlock: Unlocking "vortex->lock". "i" might now be unreliable because other threads can now change the data that it depends on.
sound/pci/au88x0/au88x0_core.c:2437: lockagain: Locking "vortex->lock" again.
sound/pci/au88x0/au88x0_core.c:2433: use: Using an unreliable value of "i" inside the second locked section.  If the data that "i" depends on was changed by another thread, this use might be incorrect.

Error: ATOMICITY:
drivers/net/irda/vlsi_ir.c:872: lock: Locking "idev->lock".
drivers/net/irda/vlsi_ir.c:923: def: Assigning: "rd" = data that might be protected by the lock.
drivers/net/irda/vlsi_ir.c:945: unlock: Unlocking "idev->lock". "rd" might now be unreliable because other threads can now change the data that it depends on.
drivers/net/irda/vlsi_ir.c:1021: lockagain: Locking "idev->lock" again.
drivers/net/irda/vlsi_ir.c:1023: use: Using an unreliable value of "rd" inside the second locked section.  If the data that "rd" depends on was changed by another thread, this use might be incorrect.

Error: ATOMICITY:
drivers/usb/serial/mct_u232.c:641: lock: Locking "priv->lock".
drivers/usb/serial/mct_u232.c:642: def: Assigning: "control_state" = data that might be protected by the lock.
drivers/usb/serial/mct_u232.c:643: unlock: Unlocking "priv->lock". "control_state" might now be unreliable because other threads can now change the data that it depends on.
drivers/usb/serial/mct_u232.c:706: lockagain: Locking "priv->lock" again.
drivers/usb/serial/mct_u232.c:707: use: Using an unreliable value of "control_state" inside the second locked section.  If the data that "control_state" depends on was changed by another thread, this use might be incorrect.

Error: ATOMICITY:
drivers/ieee1394/sbp2.c:1754: lock: Locking "sbp2_hi_logical_units_lock".
drivers/ieee1394/sbp2.c:1758: def: Assigning: "lu" = data that might be protected by the lock.
drivers/ieee1394/sbp2.c:1762: unlock: Unlocking "sbp2_hi_logical_units_lock". "lu" might now be unreliable because other threads can now change the data that it depends on.
drivers/ieee1394/sbp2.c:1790: lockagain: Locking "lu->cmd_orb_lock" again.
drivers/ieee1394/sbp2.c:1791: use: Using an unreliable value of "lu" inside the second locked section.  If the data that "lu" depends on was changed by another thread, this use might be incorrect.

Error: ATOMICITY:
drivers/isdn/gigaset/bas-gigaset.c:1138: lock: Locking "ubc->isooutlock".
drivers/isdn/gigaset/bas-gigaset.c:1139: def: Assigning: "next" = data that might be protected by the lock.
drivers/isdn/gigaset/bas-gigaset.c:1141: unlock: Unlocking "ubc->isooutlock". "next" might now be unreliable because other threads can now change the data that it depends on.
drivers/isdn/gigaset/bas-gigaset.c:1146: lockagain: Locking "ubc->isooutlock" again.
drivers/isdn/gigaset/bas-gigaset.c:1148: use: Using an unreliable value of "next" inside the second locked section.  If the data that "next" depends on was changed by another thread, this use might be incorrect.

Error: ATOMICITY:
drivers/isdn/gigaset/bas-gigaset.c:1146: lock: Locking "ubc->isooutlock".
drivers/isdn/gigaset/bas-gigaset.c:1148: def: Assigning: "ubc->isooutfree" = data that might be protected by the lock.
drivers/isdn/gigaset/bas-gigaset.c:1151: unlock: Unlocking "ubc->isooutlock". "ubc->isooutfree" might now be unreliable because other threads can now change the data that it depends on.
drivers/isdn/gigaset/bas-gigaset.c:1225: lockagain: Locking "ubc->isooutlock" again.
drivers/isdn/gigaset/bas-gigaset.c:1226: use: Using an unreliable value of "ubc->isooutfree" inside the second locked section.  If the data that "ubc->isooutfree" depends on was changed by another thread, this use might be incorrect.

Error: ATOMICITY:
drivers/isdn/gigaset/bas-gigaset.c:1225: lock: Locking "ubc->isooutlock".
drivers/isdn/gigaset/bas-gigaset.c:1227: def: Assigning: "ubc->isooutfree" = data that might be protected by the lock.
drivers/isdn/gigaset/bas-gigaset.c:1228: unlock: Unlocking "ubc->isooutlock". "ubc->isooutfree" might now be unreliable because other threads can now change the data that it depends on.
drivers/isdn/gigaset/bas-gigaset.c:1128: unlock: Unlocking "ubc->isooutlock". "ubc->isooutfree" might now be unreliable because other threads can now change the data that it depends on.
drivers/isdn/gigaset/bas-gigaset.c:1138: lockagain: Locking "ubc->isooutlock" again.
drivers/isdn/gigaset/bas-gigaset.c:1139: use: Using an unreliable value of "ubc->isooutfree" inside the second locked section.  If the data that "ubc->isooutfree" depends on was changed by another thread, this use might be incorrect.

Error: ATOMICITY:
drivers/isdn/gigaset/bas-gigaset.c:1123: lock: Locking "ubc->isooutlock".
drivers/isdn/gigaset/bas-gigaset.c:1124: def: Assigning: "done" = data that might be protected by the lock.
drivers/isdn/gigaset/bas-gigaset.c:1128: unlock: Unlocking "ubc->isooutlock". "done" might now be unreliable because other threads can now change the data that it depends on.
drivers/isdn/gigaset/bas-gigaset.c:1141: unlock: Unlocking "ubc->isooutlock". "done" might now be unreliable because other threads can now change the data that it depends on.
drivers/isdn/gigaset/bas-gigaset.c:1151: unlock: Unlocking "ubc->isooutlock". "done" might now be unreliable because other threads can now change the data that it depends on.
drivers/isdn/gigaset/bas-gigaset.c:1225: lockagain: Locking "ubc->isooutlock" again.
drivers/isdn/gigaset/bas-gigaset.c:1227: use: Using an unreliable value of "done" inside the second locked section.  If the data that "done" depends on was changed by another thread, this use might be incorrect.

Error: ATOMICITY:
drivers/isdn/gigaset/bas-gigaset.c:1123: lock: Locking "ubc->isooutlock".
drivers/isdn/gigaset/bas-gigaset.c:1125: def: Assigning: "ubc->isooutdone" = data that might be protected by the lock.
drivers/isdn/gigaset/bas-gigaset.c:1128: unlock: Unlocking "ubc->isooutlock". "ubc->isooutdone" might now be unreliable because other threads can now change the data that it depends on.
drivers/isdn/gigaset/bas-gigaset.c:1141: unlock: Unlocking "ubc->isooutlock". "ubc->isooutdone" might now be unreliable because other threads can now change the data that it depends on.
drivers/isdn/gigaset/bas-gigaset.c:1151: unlock: Unlocking "ubc->isooutlock". "ubc->isooutdone" might now be unreliable because other threads can now change the data that it depends on.
drivers/isdn/gigaset/bas-gigaset.c:1228: unlock: Unlocking "ubc->isooutlock". "ubc->isooutdone" might now be unreliable because other threads can now change the data that it depends on.
drivers/isdn/gigaset/bas-gigaset.c:1123: lockagain: Locking "ubc->isooutlock" again.
drivers/isdn/gigaset/bas-gigaset.c:1124: use: Using an unreliable value of "ubc->isooutdone" inside the second locked section.  If the data that "ubc->isooutdone" depends on was changed by another thread, this use might be incorrect.

Error: ATOMICITY:
drivers/isdn/gigaset/bas-gigaset.c:1123: lock: Locking "ubc->isooutlock".
drivers/isdn/gigaset/bas-gigaset.c:1127: def: Assigning: "ubc->isooutovfl" = data that might be protected by the lock.
drivers/isdn/gigaset/bas-gigaset.c:1128: unlock: Unlocking "ubc->isooutlock". "ubc->isooutovfl" might now be unreliable because other threads can now change the data that it depends on.
drivers/isdn/gigaset/bas-gigaset.c:1141: unlock: Unlocking "ubc->isooutlock". "ubc->isooutovfl" might now be unreliable because other threads can now change the data that it depends on.
drivers/isdn/gigaset/bas-gigaset.c:1151: unlock: Unlocking "ubc->isooutlock". "ubc->isooutovfl" might now be unreliable because other threads can now change the data that it depends on.
drivers/isdn/gigaset/bas-gigaset.c:1228: unlock: Unlocking "ubc->isooutlock". "ubc->isooutovfl" might now be unreliable because other threads can now change the data that it depends on.
drivers/isdn/gigaset/bas-gigaset.c:1123: lockagain: Locking "ubc->isooutlock" again.
drivers/isdn/gigaset/bas-gigaset.c:1126: use: Using an unreliable value of "ubc->isooutovfl" inside the second locked section.  If the data that "ubc->isooutovfl" depends on was changed by another thread, this use might be incorrect.

Error: ATOMICITY:
drivers/isdn/gigaset/bas-gigaset.c:1279: lock: Locking "ubc->isoinlock".
drivers/isdn/gigaset/bas-gigaset.c:1285: def: Assigning: "ubc->isoindone" = data that might be protected by the lock.
drivers/isdn/gigaset/bas-gigaset.c:1294: unlock: Unlocking "ubc->isoinlock". "ubc->isoindone" might now be unreliable because other threads can now change the data that it depends on.
drivers/isdn/gigaset/bas-gigaset.c:1279: lockagain: Locking "ubc->isoinlock" again.
drivers/isdn/gigaset/bas-gigaset.c:1280: use: Using an unreliable value of "ubc->isoindone" inside the second locked section.  If the data that "ubc->isoindone" depends on was changed by another thread, this use might be incorrect.

Error: ATOMICITY:
drivers/isdn/gigaset/bas-gigaset.c:1279: lock: Locking "ubc->isoinlock".
drivers/isdn/gigaset/bas-gigaset.c:1292: def: Assigning: "ubc->loststatus" = data that might be protected by the lock.
drivers/isdn/gigaset/bas-gigaset.c:1294: unlock: Unlocking "ubc->isoinlock". "ubc->loststatus" might now be unreliable because other threads can now change the data that it depends on.
drivers/isdn/gigaset/bas-gigaset.c:1279: lockagain: Locking "ubc->isoinlock" again.
drivers/isdn/gigaset/bas-gigaset.c:1287: use: Using an unreliable value of "ubc->loststatus" inside the second locked section.  If the data that "ubc->loststatus" depends on was changed by another thread, this use might be incorrect.

Error: ATOMICITY:
sound/pci/trident/trident_main.c:3735: lock: Locking "trident->reg_lock".
sound/pci/trident/trident_main.c:3742: def: Assigning: "chn_int" = data that might be protected by the lock.
sound/pci/trident/trident_main.c:3801: unlock: Unlocking "trident->reg_lock". "chn_int" might now be unreliable because other threads can now change the data that it depends on.
sound/pci/trident/trident_main.c:3803: lockagain: Locking "trident->reg_lock" again.
sound/pci/trident/trident_main.c:3805: use: Using an unreliable value of "chn_int" inside the second locked section.  If the data that "chn_int" depends on was changed by another thread, this use might be incorrect.

Error: ATOMICITY:
sound/pci/trident/trident_main.c:3735: lock: Locking "trident->reg_lock".
sound/pci/trident/trident_main.c:3736: def: Assigning: "stimer" = data that might be protected by the lock.
sound/pci/trident/trident_main.c:3801: unlock: Unlocking "trident->reg_lock". "stimer" might now be unreliable because other threads can now change the data that it depends on.
sound/pci/trident/trident_main.c:3803: lockagain: Locking "trident->reg_lock" again.
sound/pci/trident/trident_main.c:3764: use: Using an unreliable value of "stimer" inside the second locked section.  If the data that "stimer" depends on was changed by another thread, this use might be incorrect.

Error: ATOMICITY:
sound/pci/trident/trident_main.c:3735: lock: Locking "trident->reg_lock".
sound/pci/trident/trident_main.c:3742: def: Assigning: "chn_int" = data that might be protected by the lock.
sound/pci/trident/trident_main.c:3801: unlock: Unlocking "trident->reg_lock". "chn_int" might now be unreliable because other threads can now change the data that it depends on.
sound/pci/trident/trident_main.c:3801: unlock: Unlocking "trident->reg_lock". "chn_int" might now be unreliable because other threads can now change the data that it depends on.
sound/pci/trident/trident_main.c:3803: lockagain: Locking "trident->reg_lock" again.
sound/pci/trident/trident_main.c:3805: use: Using an unreliable value of "chn_int" inside the second locked section.  If the data that "chn_int" depends on was changed by another thread, this use might be incorrect.

Error: ATOMICITY:
drivers/mtd/ubi/wl.c:757: lock: Locking "ubi->wl_lock".
drivers/mtd/ubi/wl.c:784: def: Assigning: "e1" = data that might be protected by the lock.
drivers/mtd/ubi/wl.c:810: unlock: Unlocking "ubi->wl_lock". "e1" might now be unreliable because other threads can now change the data that it depends on.
drivers/mtd/ubi/wl.c:875: lockagain: Locking "ubi->wl_lock" again.
drivers/mtd/ubi/wl.c:877: use: Using an unreliable value of "e1" inside the second locked section.  If the data that "e1" depends on was changed by another thread, this use might be incorrect.

Error: ATOMICITY:
drivers/mtd/ubi/wl.c:757: lock: Locking "ubi->wl_lock".
drivers/mtd/ubi/wl.c:784: def: Assigning: "e1" = data that might be protected by the lock.
drivers/mtd/ubi/wl.c:810: unlock: Unlocking "ubi->wl_lock". "e1" might now be unreliable because other threads can now change the data that it depends on.
drivers/mtd/ubi/wl.c:915: lockagain: Locking "ubi->wl_lock" again.
drivers/mtd/ubi/wl.c:917: use: Using an unreliable value of "e1" inside the second locked section.  If the data that "e1" depends on was changed by another thread, this use might be incorrect.

Error: ATOMICITY:
drivers/mtd/ubi/wl.c:757: lock: Locking "ubi->wl_lock".
drivers/mtd/ubi/wl.c:784: def: Assigning: "e1" = data that might be protected by the lock.
drivers/mtd/ubi/wl.c:810: unlock: Unlocking "ubi->wl_lock". "e1" might now be unreliable because other threads can now change the data that it depends on.
drivers/mtd/ubi/wl.c:915: lockagain: Locking "ubi->wl_lock" again.
drivers/mtd/ubi/wl.c:919: use: Using an unreliable value of "e1" inside the second locked section.  If the data that "e1" depends on was changed by another thread, this use might be incorrect.

Error: ATOMICITY:
drivers/mtd/ubi/wl.c:757: lock: Locking "ubi->wl_lock".
drivers/mtd/ubi/wl.c:799: def: Assigning: "e1" = data that might be protected by the lock.
drivers/mtd/ubi/wl.c:810: unlock: Unlocking "ubi->wl_lock". "e1" might now be unreliable because other threads can now change the data that it depends on.
drivers/mtd/ubi/wl.c:875: lockagain: Locking "ubi->wl_lock" again.
drivers/mtd/ubi/wl.c:877: use: Using an unreliable value of "e1" inside the second locked section.  If the data that "e1" depends on was changed by another thread, this use might be incorrect.

Error: ATOMICITY:
drivers/mtd/ubi/wl.c:757: lock: Locking "ubi->wl_lock".
drivers/mtd/ubi/wl.c:799: def: Assigning: "e1" = data that might be protected by the lock.
drivers/mtd/ubi/wl.c:810: unlock: Unlocking "ubi->wl_lock". "e1" might now be unreliable because other threads can now change the data that it depends on.
drivers/mtd/ubi/wl.c:915: lockagain: Locking "ubi->wl_lock" again.
drivers/mtd/ubi/wl.c:917: use: Using an unreliable value of "e1" inside the second locked section.  If the data that "e1" depends on was changed by another thread, this use might be incorrect.

Error: ATOMICITY:
drivers/mtd/ubi/wl.c:757: lock: Locking "ubi->wl_lock".
drivers/mtd/ubi/wl.c:799: def: Assigning: "e1" = data that might be protected by the lock.
drivers/mtd/ubi/wl.c:810: unlock: Unlocking "ubi->wl_lock". "e1" might now be unreliable because other threads can now change the data that it depends on.
drivers/mtd/ubi/wl.c:915: lockagain: Locking "ubi->wl_lock" again.
drivers/mtd/ubi/wl.c:919: use: Using an unreliable value of "e1" inside the second locked section.  If the data that "e1" depends on was changed by another thread, this use might be incorrect.

Error: ATOMICITY:
drivers/mtd/ubi/wl.c:757: lock: Locking "ubi->wl_lock".
drivers/mtd/ubi/wl.c:785: def: Assigning: "e2" = data that might be protected by the lock.
drivers/mtd/ubi/wl.c:810: unlock: Unlocking "ubi->wl_lock". "e2" might now be unreliable because other threads can now change the data that it depends on.
drivers/mtd/ubi/wl.c:875: lockagain: Locking "ubi->wl_lock" again.
drivers/mtd/ubi/wl.c:879: use: Using an unreliable value of "e2" inside the second locked section.  If the data that "e2" depends on was changed by another thread, this use might be incorrect.

Error: ATOMICITY:
drivers/mtd/ubi/wl.c:757: lock: Locking "ubi->wl_lock".
drivers/mtd/ubi/wl.c:800: def: Assigning: "e2" = data that might be protected by the lock.
drivers/mtd/ubi/wl.c:810: unlock: Unlocking "ubi->wl_lock". "e2" might now be unreliable because other threads can now change the data that it depends on.
drivers/mtd/ubi/wl.c:875: lockagain: Locking "ubi->wl_lock" again.
drivers/mtd/ubi/wl.c:879: use: Using an unreliable value of "e2" inside the second locked section.  If the data that "e2" depends on was changed by another thread, this use might be incorrect.

Error: ATOMICITY:
drivers/net/wireless/b43legacy/main.c:2611: lock: Locking "wl->irq_lock".
drivers/net/wireless/b43legacy/main.c:2616: def: Assigning: "savedirqs" = data that might be protected by the lock.
drivers/net/wireless/b43legacy/main.c:2617: unlock: Unlocking "wl->irq_lock". "savedirqs" might now be unreliable because other threads can now change the data that it depends on.
drivers/net/wireless/b43legacy/main.c:2669: lockagain: Locking "wl->irq_lock" again.
drivers/net/wireless/b43legacy/main.c:2670: use: Using an unreliable value of "savedirqs" inside the second locked section.  If the data that "savedirqs" depends on was changed by another thread, this use might be incorrect.

Error: ATOMICITY:
drivers/scsi/scsi_lib.c:1691: lock: Locking "*q->queue_lock".
drivers/scsi/scsi_lib.c:1620: def: Assigning: "req" = data that might be protected by the lock.
drivers/scsi/scsi_lib.c:1639: unlock: Unlocking "*q->queue_lock". "req" might now be unreliable because other threads can now change the data that it depends on.
drivers/scsi/scsi_lib.c:1706: unlock: Unlocking "*shost->host_lock". "req" might now be unreliable because other threads can now change the data that it depends on.
drivers/scsi/scsi_lib.c:1716: lockagain: Locking "*q->queue_lock" again.
drivers/scsi/scsi_lib.c:1717: use: Using an unreliable value of "req" inside the second locked section.  If the data that "req" depends on was changed by another thread, this use might be incorrect.

Error: ATOMICITY:
drivers/md/raid5.c:3844: lock: Locking "conf->device_lock".
drivers/md/raid5.c:3849: def: Assigning: "seq" = data that might be protected by the lock.
drivers/md/raid5.c:3850: unlock: Unlocking "conf->device_lock". "seq" might now be unreliable because other threads can now change the data that it depends on.
drivers/md/raid5.c:3852: lockagain: Locking "conf->device_lock" again.
drivers/md/raid5.c:3853: use: Using an unreliable value of "seq" inside the second locked section.  If the data that "seq" depends on was changed by another thread, this use might be incorrect.

Error: ATOMICITY:
drivers/md/raid5.c:3877: lock: Locking "conf->device_lock".
drivers/md/raid5.c:3849: def: Assigning: "seq" = data that might be protected by the lock.
drivers/md/raid5.c:3850: unlock: Unlocking "conf->device_lock". "seq" might now be unreliable because other threads can now change the data that it depends on.
drivers/md/raid5.c:3852: lockagain: Locking "conf->device_lock" again.
drivers/md/raid5.c:3853: use: Using an unreliable value of "seq" inside the second locked section.  If the data that "seq" depends on was changed by another thread, this use might be incorrect.

Error: ATOMICITY:
drivers/usb/serial/whiteheat.c:806: lock: Locking "info->lock".
drivers/usb/serial/whiteheat.c:811: def: Assigning: "tmp" = data that might be protected by the lock.
drivers/usb/serial/whiteheat.c:813: unlock: Unlocking "info->lock". "tmp" might now be unreliable because other threads can now change the data that it depends on.
drivers/usb/serial/whiteheat.c:832: lockagain: Locking "info->lock" again.
drivers/usb/serial/whiteheat.c:833: use: Using an unreliable value of "tmp" inside the second locked section.  If the data that "tmp" depends on was changed by another thread, this use might be incorrect.

Error: ATOMICITY:
drivers/usb/serial/whiteheat.c:806: lock: Locking "info->lock".
drivers/usb/serial/whiteheat.c:811: def: Assigning: "tmp" = data that might be protected by the lock.
drivers/usb/serial/whiteheat.c:813: unlock: Unlocking "info->lock". "tmp" might now be unreliable because other threads can now change the data that it depends on.
drivers/usb/serial/whiteheat.c:839: lockagain: Locking "info->lock" again.
drivers/usb/serial/whiteheat.c:840: use: Using an unreliable value of "tmp" inside the second locked section.  If the data that "tmp" depends on was changed by another thread, this use might be incorrect.

Error: ATOMICITY:
sound/pci/ca0106/ca_midi.c:63: lock: Locking "midi->input_lock".
sound/pci/ca0106/ca_midi.c:68: def: Assigning: "byte" = data that might be protected by the lock.
sound/pci/ca0106/ca_midi.c:75: unlock: Unlocking "midi->input_lock". "byte" might now be unreliable because other threads can now change the data that it depends on.
sound/pci/ca0106/ca_midi.c:77: lockagain: Locking "midi->output_lock" again.
sound/pci/ca0106/ca_midi.c:81: use: Using an unreliable value of "byte" inside the second locked section.  If the data that "byte" depends on was changed by another thread, this use might be incorrect.

Error: ATOMICITY:
drivers/ide/ide-io.c:1367: lock: Locking "ide_lock".
drivers/ide/ide-io.c:1367: def: Assigning: "flags" = data that might be protected by the lock.
drivers/ide/ide-io.c:1441: unlock: Unlocking "ide_lock". "flags" might now be unreliable because other threads can now change the data that it depends on.
drivers/ide/ide-io.c:1452: lockagain: Locking "ide_lock" again.
drivers/ide/ide-io.c:1470: use: Using an unreliable value of "flags" inside the second locked section.  If the data that "flags" depends on was changed by another thread, this use might be incorrect.

Error: ATOMICITY:
drivers/infiniband/hw/ipath/ipath_fs.c:347: lock: Locking "ipath_devs_lock".
drivers/infiniband/hw/ipath/ipath_fs.c:349: def: Assigning: "tmp" = data that might be protected by the lock.
drivers/infiniband/hw/ipath/ipath_fs.c:350: unlock: Unlocking "ipath_devs_lock". "tmp" might now be unreliable because other threads can now change the data that it depends on.
drivers/infiniband/hw/ipath/ipath_fs.c:356: lockagain: Locking "ipath_devs_lock" again.
drivers/infiniband/hw/ipath/ipath_fs.c:349: use: Using an unreliable value of "tmp" inside the second locked section.  If the data that "tmp" depends on was changed by another thread, this use might be incorrect.

Error: ATOMICITY:
drivers/infiniband/hw/ipath/ipath_fs.c:356: lock: Locking "ipath_devs_lock".
drivers/infiniband/hw/ipath/ipath_fs.c:349: def: Assigning: "tmp" = data that might be protected by the lock.
drivers/infiniband/hw/ipath/ipath_fs.c:350: unlock: Unlocking "ipath_devs_lock". "tmp" might now be unreliable because other threads can now change the data that it depends on.
drivers/infiniband/hw/ipath/ipath_fs.c:356: lockagain: Locking "ipath_devs_lock" again.
drivers/infiniband/hw/ipath/ipath_fs.c:349: use: Using an unreliable value of "tmp" inside the second locked section.  If the data that "tmp" depends on was changed by another thread, this use might be incorrect.

Error: ATOMICITY:
drivers/usb/serial/oti6858.c:310: lock: Locking "priv->lock".
drivers/usb/serial/oti6858.c:319: def: Assigning: "count" = data that might be protected by the lock.
drivers/usb/serial/oti6858.c:320: unlock: Unlocking "priv->lock". "count" might now be unreliable because other threads can now change the data that it depends on.
drivers/usb/serial/oti6858.c:347: lockagain: Locking "priv->lock" again.
drivers/usb/serial/oti6858.c:348: use: Using an unreliable value of "count" inside the second locked section.  If the data that "count" depends on was changed by another thread, this use might be incorrect.

Error: ATOMICITY:
drivers/usb/host/isp1760-hcd.c:2117: lock: Locking "priv->lock".
drivers/usb/host/isp1760-hcd.c:2118: def: Assigning: "qh" = data that might be protected by the lock.
drivers/usb/host/isp1760-hcd.c:2133: unlock: Unlocking "priv->lock". "qh" might now be unreliable because other threads can now change the data that it depends on.
drivers/usb/host/isp1760-hcd.c:2135: lockagain: Locking "priv->lock" again.
drivers/usb/host/isp1760-hcd.c:2145: use: Using an unreliable value of "qh" inside the second locked section.  If the data that "qh" depends on was changed by another thread, this use might be incorrect.

Error: ATOMICITY:
drivers/usb/host/isp1760-hcd.c:2117: lock: Locking "priv->lock".
drivers/usb/host/isp1760-hcd.c:2118: def: Assigning: "qh" = data that might be protected by the lock.
drivers/usb/host/isp1760-hcd.c:2133: unlock: Unlocking "priv->lock". "qh" might now be unreliable because other threads can now change the data that it depends on.
drivers/usb/host/isp1760-hcd.c:2133: unlock: Unlocking "priv->lock". "qh" might now be unreliable because other threads can now change the data that it depends on.
drivers/usb/host/isp1760-hcd.c:2135: lockagain: Locking "priv->lock" again.
drivers/usb/host/isp1760-hcd.c:2145: use: Using an unreliable value of "qh" inside the second locked section.  If the data that "qh" depends on was changed by another thread, this use might be incorrect.

Error: ATOMICITY:
net/sunrpc/auth_gss/auth_gss.c:514: lock: Locking "inode->i_lock".
net/sunrpc/auth_gss/auth_gss.c:515: def: Assigning: "gss_msg" = data that might be protected by the lock.
net/sunrpc/auth_gss/auth_gss.c:521: unlock: Unlocking "inode->i_lock". "gss_msg" might now be unreliable because other threads can now change the data that it depends on.
net/sunrpc/auth_gss/auth_gss.c:533: lockagain: Locking "inode->i_lock" again.
net/sunrpc/auth_gss/auth_gss.c:534: use: Using an unreliable value of "gss_msg" inside the second locked section.  If the data that "gss_msg" depends on was changed by another thread, this use might be incorrect.

Error: ATOMICITY:
fs/dlm/lowcomms.c:817: lock: Locking "con->writequeue_lock".
fs/dlm/lowcomms.c:818: def: Assigning: "e" = data that might be protected by the lock.
fs/dlm/lowcomms.c:825: unlock: Unlocking "con->writequeue_lock". "e" might now be unreliable because other threads can now change the data that it depends on.
fs/dlm/lowcomms.c:851: lockagain: Locking "con->writequeue_lock" again.
fs/dlm/lowcomms.c:858: use: Using an unreliable value of "e" inside the second locked section.  If the data that "e" depends on was changed by another thread, this use might be incorrect.

Error: ATOMICITY:
drivers/infiniband/hw/ipath/ipath_ud.c:272: lock: Locking "qp->s_lock".
drivers/infiniband/hw/ipath/ipath_ud.c:293: def: Assigning: "wqe" = data that might be protected by the lock.
drivers/infiniband/hw/ipath/ipath_ud.c:321: unlock: Unlocking "qp->s_lock". "wqe" might now be unreliable because other threads can now change the data that it depends on.
drivers/infiniband/hw/ipath/ipath_ud.c:323: lockagain: Locking "qp->s_lock" again.
drivers/infiniband/hw/ipath/ipath_ud.c:324: use: Using an unreliable value of "wqe" inside the second locked section.  If the data that "wqe" depends on was changed by another thread, this use might be incorrect.

Error: ATOMICITY:
kernel/compat.c:834: lock: Locking "get_current()->sighand->siglock".
kernel/compat.c:842: def: Assigning: "get_current()->real_blocked" = data that might be protected by the lock.
kernel/compat.c:846: unlock: Unlocking "get_current()->sighand->siglock". "get_current()->real_blocked" might now be unreliable because other threads can now change the data that it depends on.
kernel/compat.c:850: lockagain: Locking "get_current()->sighand->siglock" again.
kernel/compat.c:852: use: Using an unreliable value of "get_current()->real_blocked" inside the second locked section.  If the data that "get_current()->real_blocked" depends on was changed by another thread, this use might be incorrect.

Error: ATOMICITY:
kernel/signal.c:2162: lock: Locking "get_current()->sighand->siglock".
kernel/signal.c:2174: def: Assigning: "get_current()->real_blocked" = data that might be protected by the lock.
kernel/signal.c:2177: unlock: Unlocking "get_current()->sighand->siglock". "get_current()->real_blocked" might now be unreliable because other threads can now change the data that it depends on.
kernel/signal.c:2181: lockagain: Locking "get_current()->sighand->siglock" again.
kernel/signal.c:2183: use: Using an unreliable value of "get_current()->real_blocked" inside the second locked section.  If the data that "get_current()->real_blocked" depends on was changed by another thread, this use might be incorrect.

Error: ATOMICITY:
fs/ntfs/mft.c:2434: lock: Locking "mft_ni->size_lock".
fs/ntfs/mft.c:2440: def: Assigning: "new_initialized_size" = data that might be protected by the lock.
fs/ntfs/mft.c:2445: unlock: Unlocking "mft_ni->size_lock". "new_initialized_size" might now be unreliable because other threads can now change the data that it depends on.
fs/ntfs/mft.c:2453: lockagain: Locking "mft_ni->size_lock" again.
fs/ntfs/mft.c:2454: use: Using an unreliable value of "new_initialized_size" inside the second locked section.  If the data that "new_initialized_size" depends on was changed by another thread, this use might be incorrect.

Error: ATOMICITY:
fs/ntfs/mft.c:2434: lock: Locking "mft_ni->size_lock".
fs/ntfs/mft.c:2435: def: Assigning: "old_data_initialized" = data that might be protected by the lock.
fs/ntfs/mft.c:2445: unlock: Unlocking "mft_ni->size_lock". "old_data_initialized" might now be unreliable because other threads can now change the data that it depends on.
fs/ntfs/mft.c:2738: lockagain: Locking "mft_ni->size_lock" again.
fs/ntfs/mft.c:2739: use: Using an unreliable value of "old_data_initialized" inside the second locked section.  If the data that "old_data_initialized" depends on was changed by another thread, this use might be incorrect.

Error: ATOMICITY:
fs/ntfs/mft.c:2434: lock: Locking "mft_ni->size_lock".
fs/ntfs/mft.c:2436: def: Assigning: "old_data_size" = data that might be protected by the lock.
fs/ntfs/mft.c:2445: unlock: Unlocking "mft_ni->size_lock". "old_data_size" might now be unreliable because other threads can now change the data that it depends on.
fs/ntfs/mft.c:2738: lockagain: Locking "mft_ni->size_lock" again.
fs/ntfs/mft.c:2740: use: Using an unreliable value of "old_data_size" inside the second locked section.  If the data that "old_data_size" depends on was changed by another thread, this use might be incorrect.

Error: ATOMICITY:
fs/ntfs/mft.c:2453: lock: Locking "mft_ni->size_lock".
fs/ntfs/mft.c:2454: def: Assigning: "mft_ni->initialized_size" = data that might be protected by the lock.
fs/ntfs/mft.c:2456: unlock: Unlocking "mft_ni->size_lock". "mft_ni->initialized_size" might now be unreliable because other threads can now change the data that it depends on.
fs/ntfs/mft.c:2482: lockagain: Locking "mft_ni->size_lock" again.
fs/ntfs/mft.c:2483: use: Using an unreliable value of "mft_ni->initialized_size" inside the second locked section.  If the data that "mft_ni->initialized_size" depends on was changed by another thread, this use might be incorrect.

Error: ATOMICITY:
fs/ntfs/mft.c:2453: lock: Locking "mft_ni->size_lock".
fs/ntfs/mft.c:2440: def: Assigning: "new_initialized_size" = data that might be protected by the lock.
fs/ntfs/mft.c:2445: unlock: Unlocking "mft_ni->size_lock". "new_initialized_size" might now be unreliable because other threads can now change the data that it depends on.
fs/ntfs/mft.c:2453: lockagain: Locking "mft_ni->size_lock" again.
fs/ntfs/mft.c:2454: use: Using an unreliable value of "new_initialized_size" inside the second locked section.  If the data that "new_initialized_size" depends on was changed by another thread, this use might be incorrect.

Error: ATOMICITY:
fs/ntfs/mft.c:2300: lock: Locking "mftbmp_ni->size_lock".
fs/ntfs/mft.c:2301: def: Assigning: "old_data_initialized" = data that might be protected by the lock.
fs/ntfs/mft.c:2302: unlock: Unlocking "mftbmp_ni->size_lock". "old_data_initialized" might now be unreliable because other threads can now change the data that it depends on.
fs/ntfs/mft.c:2321: lockagain: Locking "mftbmp_ni->size_lock" again.
fs/ntfs/mft.c:2323: use: Using an unreliable value of "old_data_initialized" inside the second locked section.  If the data that "old_data_initialized" depends on was changed by another thread, this use might be incorrect.

Error: ATOMICITY:
fs/ntfs/mft.c:2434: lock: Locking "mft_ni->size_lock".
fs/ntfs/mft.c:2435: def: Assigning: "old_data_initialized" = data that might be protected by the lock.
fs/ntfs/mft.c:2445: unlock: Unlocking "mft_ni->size_lock". "old_data_initialized" might now be unreliable because other threads can now change the data that it depends on.
fs/ntfs/mft.c:2445: unlock: Unlocking "mft_ni->size_lock". "old_data_initialized" might now be unreliable because other threads can now change the data that it depends on.
fs/ntfs/mft.c:2738: lockagain: Locking "mft_ni->size_lock" again.
fs/ntfs/mft.c:2739: use: Using an unreliable value of "old_data_initialized" inside the second locked section.  If the data that "old_data_initialized" depends on was changed by another thread, this use might be incorrect.

Error: ATOMICITY:
fs/ntfs/mft.c:2434: lock: Locking "mft_ni->size_lock".
fs/ntfs/mft.c:2436: def: Assigning: "old_data_size" = data that might be protected by the lock.
fs/ntfs/mft.c:2445: unlock: Unlocking "mft_ni->size_lock". "old_data_size" might now be unreliable because other threads can now change the data that it depends on.
fs/ntfs/mft.c:2445: unlock: Unlocking "mft_ni->size_lock". "old_data_size" might now be unreliable because other threads can now change the data that it depends on.
fs/ntfs/mft.c:2738: lockagain: Locking "mft_ni->size_lock" again.
fs/ntfs/mft.c:2740: use: Using an unreliable value of "old_data_size" inside the second locked section.  If the data that "old_data_size" depends on was changed by another thread, this use might be incorrect.

Error: ATOMICITY:
drivers/usb/core/hub.c:456: lock: Locking "hub->tt.lock".
drivers/usb/core/hub.c:464: def: Assigning: "clear" = data that might be protected by the lock.
drivers/usb/core/hub.c:468: unlock: Unlocking "hub->tt.lock". "clear" might now be unreliable because other threads can now change the data that it depends on.
drivers/usb/core/hub.c:470: lockagain: Locking "hub->tt.lock" again.
drivers/usb/core/hub.c:476: use: Using an unreliable value of "clear" inside the second locked section.  If the data that "clear" depends on was changed by another thread, this use might be incorrect.

Error: ATOMICITY:
drivers/md/raid5.c:4556: lock: Locking "conf->device_lock".
drivers/md/raid5.c:4557: def: Assigning: "conf->previous_raid_disks" = data that might be protected by the lock.
drivers/md/raid5.c:4561: unlock: Unlocking "conf->device_lock". "conf->previous_raid_disks" might now be unreliable because other threads can now change the data that it depends on.
drivers/md/raid5.c:4587: unlock: Unlocking "conf->device_lock". "conf->previous_raid_disks" might now be unreliable because other threads can now change the data that it depends on.
drivers/md/raid5.c:4600: lockagain: Locking "conf->device_lock" again.
drivers/md/raid5.c:4601: use: Using an unreliable value of "conf->previous_raid_disks" inside the second locked section.  If the data that "conf->previous_raid_disks" depends on was changed by another thread, this use might be incorrect.

Error: ATOMICITY:
sound/pci/mixart/mixart_core.c:511: lock: Locking "mgr->lock".
sound/pci/mixart/mixart_core.c:523: def: Assigning: "mixart_msg_data[i]" = data that might be protected by the lock.
sound/pci/mixart/mixart_core.c:509: unlock: Unlocking "mgr->lock". "mixart_msg_data[i]" might now be unreliable because other threads can now change the data that it depends on.
sound/pci/mixart/mixart_core.c:511: lockagain: Locking "mgr->lock" again.
sound/pci/mixart/mixart_core.c:523: use: Using an unreliable value of "mixart_msg_data[i]" inside the second locked section.  If the data that "mixart_msg_data[i]" depends on was changed by another thread, this use might be incorrect.

Error: ATOMICITY:
fs/ocfs2/cluster/heartbeat.c:1326: lock: Locking "o2hb_live_lock".
fs/ocfs2/cluster/heartbeat.c:1327: def: Assigning: "reg->hr_task" = data that might be protected by the lock.
fs/ocfs2/cluster/heartbeat.c:1328: unlock: Unlocking "o2hb_live_lock". "reg->hr_task" might now be unreliable because other threads can now change the data that it depends on.
fs/ocfs2/cluster/heartbeat.c:1334: lockagain: Locking "o2hb_live_lock" again.
fs/ocfs2/cluster/heartbeat.c:1335: use: Using an unreliable value of "reg->hr_task" inside the second locked section.  If the data that "reg->hr_task" depends on was changed by another thread, this use might be incorrect.

Error: ATOMICITY:
fs/ocfs2/cluster/heartbeat.c:1326: lock: Locking "o2hb_live_lock".
fs/ocfs2/cluster/heartbeat.c:1327: def: Assigning: "reg->hr_task" = data that might be protected by the lock.
fs/ocfs2/cluster/heartbeat.c:1328: unlock: Unlocking "o2hb_live_lock". "reg->hr_task" might now be unreliable because other threads can now change the data that it depends on.
fs/ocfs2/cluster/heartbeat.c:1345: lockagain: Locking "o2hb_live_lock" again.
fs/ocfs2/cluster/heartbeat.c:1346: use: Using an unreliable value of "reg->hr_task" inside the second locked section.  If the data that "reg->hr_task" depends on was changed by another thread, this use might be incorrect.

Error: ATOMICITY:
drivers/usb/serial/whiteheat.c:755: lock: Locking "info->lock".
drivers/usb/serial/whiteheat.c:756: def: Assigning: "tmp" = data that might be protected by the lock.
drivers/usb/serial/whiteheat.c:760: unlock: Unlocking "info->lock". "tmp" might now be unreliable because other threads can now change the data that it depends on.
drivers/usb/serial/whiteheat.c:762: lockagain: Locking "info->lock" again.
drivers/usb/serial/whiteheat.c:763: use: Using an unreliable value of "tmp" inside the second locked section.  If the data that "tmp" depends on was changed by another thread, this use might be incorrect.

Error: ATOMICITY:
drivers/usb/serial/whiteheat.c:755: lock: Locking "info->lock".
drivers/usb/serial/whiteheat.c:756: def: Assigning: "tmp2" = data that might be protected by the lock.
drivers/usb/serial/whiteheat.c:760: unlock: Unlocking "info->lock". "tmp2" might now be unreliable because other threads can now change the data that it depends on.
drivers/usb/serial/whiteheat.c:762: lockagain: Locking "info->lock" again.
drivers/usb/serial/whiteheat.c:756: use: Using an unreliable value of "tmp2" inside the second locked section.  If the data that "tmp2" depends on was changed by another thread, this use might be incorrect.

Error: ATOMICITY:
drivers/usb/serial/whiteheat.c:762: lock: Locking "info->lock".
drivers/usb/serial/whiteheat.c:767: def: Assigning: "tmp" = data that might be protected by the lock.
drivers/usb/serial/whiteheat.c:771: unlock: Unlocking "info->lock". "tmp" might now be unreliable because other threads can now change the data that it depends on.
drivers/usb/serial/whiteheat.c:773: lockagain: Locking "info->lock" again.
drivers/usb/serial/whiteheat.c:774: use: Using an unreliable value of "tmp" inside the second locked section.  If the data that "tmp" depends on was changed by another thread, this use might be incorrect.

Error: ATOMICITY:
drivers/usb/serial/whiteheat.c:762: lock: Locking "info->lock".
drivers/usb/serial/whiteheat.c:767: def: Assigning: "tmp2" = data that might be protected by the lock.
drivers/usb/serial/whiteheat.c:771: unlock: Unlocking "info->lock". "tmp2" might now be unreliable because other threads can now change the data that it depends on.
drivers/usb/serial/whiteheat.c:773: lockagain: Locking "info->lock" again.
drivers/usb/serial/whiteheat.c:767: use: Using an unreliable value of "tmp2" inside the second locked section.  If the data that "tmp2" depends on was changed by another thread, this use might be incorrect.

Error: ATOMICITY:
fs/ocfs2/dlm/dlmmaster.c:1889: lock: Locking "mle->spinlock".
fs/ocfs2/dlm/dlmmaster.c:1902: def: Assigning: "mle->master" = data that might be protected by the lock.
fs/ocfs2/dlm/dlmmaster.c:1905: unlock: Unlocking "mle->spinlock". "mle->master" might now be unreliable because other threads can now change the data that it depends on.
fs/ocfs2/dlm/dlmmaster.c:1909: lockagain: Locking "res->spinlock" again.
fs/ocfs2/dlm/dlmmaster.c:1920: use: Using an unreliable value of "mle->master" inside the second locked section.  If the data that "mle->master" depends on was changed by another thread, this use might be incorrect.

Error: ATOMICITY:
fs/ocfs2/dlm/dlmmaster.c:1889: lock: Locking "mle->spinlock".
fs/ocfs2/dlm/dlmmaster.c:1891: def: Assigning: "extra_ref" = data that might be protected by the lock.
fs/ocfs2/dlm/dlmmaster.c:1905: unlock: Unlocking "mle->spinlock". "extra_ref" might now be unreliable because other threads can now change the data that it depends on.
fs/ocfs2/dlm/dlmmaster.c:1922: unlock: Unlocking "res->spinlock". "extra_ref" might now be unreliable because other threads can now change the data that it depends on.
fs/ocfs2/dlm/dlmmaster.c:1932: lockagain: Locking "dlm->master_lock" again.
fs/ocfs2/dlm/dlmmaster.c:1947: use: Using an unreliable value of "extra_ref" inside the second locked section.  If the data that "extra_ref" depends on was changed by another thread, this use might be incorrect.

Error: ATOMICITY:
drivers/ide/ide-io.c:1195: lock: Locking "ide_lock".
drivers/ide/ide-io.c:1195: def: Assigning: "flags" = data that might be protected by the lock.
drivers/ide/ide-io.c:1238: unlock: Unlocking "ide_lock". "flags" might now be unreliable because other threads can now change the data that it depends on.
drivers/ide/ide-io.c:1262: lockagain: Locking "ide_lock" again.
drivers/ide/ide-io.c:1269: use: Using an unreliable value of "flags" inside the second locked section.  If the data that "flags" depends on was changed by another thread, this use might be incorrect.

Error: ATOMICITY:
drivers/usb/gadget/printer.c:571: lock: Locking "dev->lock".
drivers/usb/gadget/printer.c:583: def: Assigning: "current_rx_buf" = data that might be protected by the lock.
drivers/usb/gadget/printer.c:597: unlock: Unlocking "dev->lock". "current_rx_buf" might now be unreliable because other threads can now change the data that it depends on.
drivers/usb/gadget/printer.c:611: lockagain: Locking "dev->lock" again.
drivers/usb/gadget/printer.c:673: use: Using an unreliable value of "current_rx_buf" inside the second locked section.  If the data that "current_rx_buf" depends on was changed by another thread, this use might be incorrect.

Error: ATOMICITY:
drivers/usb/gadget/printer.c:571: lock: Locking "dev->lock".
drivers/usb/gadget/printer.c:582: def: Assigning: "current_rx_bytes" = data that might be protected by the lock.
drivers/usb/gadget/printer.c:597: unlock: Unlocking "dev->lock". "current_rx_bytes" might now be unreliable because other threads can now change the data that it depends on.
drivers/usb/gadget/printer.c:611: lockagain: Locking "dev->lock" again.
drivers/usb/gadget/printer.c:672: use: Using an unreliable value of "current_rx_bytes" inside the second locked section.  If the data that "current_rx_bytes" depends on was changed by another thread, this use might be incorrect.

Error: ATOMICITY:
drivers/usb/gadget/printer.c:571: lock: Locking "dev->lock".
drivers/usb/gadget/printer.c:581: def: Assigning: "current_rx_req" = data that might be protected by the lock.
drivers/usb/gadget/printer.c:597: unlock: Unlocking "dev->lock". "current_rx_req" might now be unreliable because other threads can now change the data that it depends on.
drivers/usb/gadget/printer.c:611: lockagain: Locking "dev->lock" again.
drivers/usb/gadget/printer.c:671: use: Using an unreliable value of "current_rx_req" inside the second locked section.  If the data that "current_rx_req" depends on was changed by another thread, this use might be incorrect.

Error: ATOMICITY:
drivers/usb/gadget/printer.c:611: lock: Locking "dev->lock".
drivers/usb/gadget/printer.c:625: def: Assigning: "current_rx_buf" = data that might be protected by the lock.
drivers/usb/gadget/printer.c:633: unlock: Unlocking "dev->lock". "current_rx_buf" might now be unreliable because other threads can now change the data that it depends on.
drivers/usb/gadget/printer.c:645: lockagain: Locking "dev->lock" again.
drivers/usb/gadget/printer.c:673: use: Using an unreliable value of "current_rx_buf" inside the second locked section.  If the data that "current_rx_buf" depends on was changed by another thread, this use might be incorrect.

Error: ATOMICITY:
drivers/usb/gadget/printer.c:611: lock: Locking "dev->lock".
drivers/usb/gadget/printer.c:624: def: Assigning: "current_rx_bytes" = data that might be protected by the lock.
drivers/usb/gadget/printer.c:633: unlock: Unlocking "dev->lock". "current_rx_bytes" might now be unreliable because other threads can now change the data that it depends on.
drivers/usb/gadget/printer.c:645: lockagain: Locking "dev->lock" again.
drivers/usb/gadget/printer.c:672: use: Using an unreliable value of "current_rx_bytes" inside the second locked section.  If the data that "current_rx_bytes" depends on was changed by another thread, this use might be incorrect.

Error: ATOMICITY:
drivers/usb/gadget/printer.c:611: lock: Locking "dev->lock".
drivers/usb/gadget/printer.c:623: def: Assigning: "current_rx_req" = data that might be protected by the lock.
drivers/usb/gadget/printer.c:633: unlock: Unlocking "dev->lock". "current_rx_req" might now be unreliable because other threads can now change the data that it depends on.
drivers/usb/gadget/printer.c:645: lockagain: Locking "dev->lock" again.
drivers/usb/gadget/printer.c:671: use: Using an unreliable value of "current_rx_req" inside the second locked section.  If the data that "current_rx_req" depends on was changed by another thread, this use might be incorrect.

Error: ATOMICITY:
sound/pci/ali5451/ali5451.c:1394: lock: Locking "codec->reg_lock".
sound/pci/ali5451/ali5451.c:1400: def: Assigning: "Delta" = data that might be protected by the lock.
sound/pci/ali5451/ali5451.c:1409: unlock: Unlocking "codec->reg_lock". "Delta" might now be unreliable because other threads can now change the data that it depends on.
sound/pci/ali5451/ali5451.c:1419: lockagain: Locking "codec->reg_lock" again.
sound/pci/ali5451/ali5451.c:1447: use: Using an unreliable value of "Delta" inside the second locked section.  If the data that "Delta" depends on was changed by another thread, this use might be incorrect.

Error: ATOMICITY:
sound/pci/au88x0/au88x0_core.c:2430: lock: Locking "vortex->lock".
sound/pci/au88x0/au88x0_core.c:2431: def: Assigning: "i" = data that might be protected by the lock.
sound/pci/au88x0/au88x0_core.c:2434: unlock: Unlocking "vortex->lock". "i" might now be unreliable because other threads can now change the data that it depends on.
sound/pci/au88x0/au88x0_core.c:2437: lockagain: Locking "vortex->lock" again.
sound/pci/au88x0/au88x0_core.c:2433: use: Using an unreliable value of "i" inside the second locked section.  If the data that "i" depends on was changed by another thread, this use might be incorrect.

Error: ATOMICITY:
sound/pci/au88x0/au88x0_core.c:2437: lock: Locking "vortex->lock".
sound/pci/au88x0/au88x0_core.c:2441: def: Assigning: "i" = data that might be protected by the lock.
sound/pci/au88x0/au88x0_core.c:2444: unlock: Unlocking "vortex->lock". "i" might now be unreliable because other threads can now change the data that it depends on.
sound/pci/au88x0/au88x0_core.c:2447: lockagain: Locking "vortex->lock" again.
sound/pci/au88x0/au88x0_core.c:2443: use: Using an unreliable value of "i" inside the second locked section.  If the data that "i" depends on was changed by another thread, this use might be incorrect.

Error: ATOMICITY:
drivers/net/wan/sbni.c:451: lock: Locking "nl->lock".
drivers/net/wan/sbni.c:453: def: Assigning: "p" = data that might be protected by the lock.
drivers/net/wan/sbni.c:454: unlock: Unlocking "nl->lock". "p" might now be unreliable because other threads can now change the data that it depends on.
drivers/net/wan/sbni.c:451: lockagain: Locking "nl->lock" again.
drivers/net/wan/sbni.c:457: use: Using an unreliable value of "p" inside the second locked section.  If the data that "p" depends on was changed by another thread, this use might be incorrect.

Error: ATOMICITY:
drivers/char/pcmcia/ipwireless/hardware.c:708: lock: Locking "hw->lock".
drivers/char/pcmcia/ipwireless/hardware.c:710: def: Assigning: "packet" = data that might be protected by the lock.
drivers/char/pcmcia/ipwireless/hardware.c:726: unlock: Unlocking "hw->lock". "packet" might now be unreliable because other threads can now change the data that it depends on.
drivers/char/pcmcia/ipwireless/hardware.c:737: lockagain: Locking "hw->lock" again.
drivers/char/pcmcia/ipwireless/hardware.c:751: use: Using an unreliable value of "packet" inside the second locked section.  If the data that "packet" depends on was changed by another thread, this use might be incorrect.

Error: ATOMICITY:
drivers/char/pcmcia/ipwireless/hardware.c:737: lock: Locking "hw->lock".
drivers/char/pcmcia/ipwireless/hardware.c:710: def: Assigning: "packet" = data that might be protected by the lock.
drivers/char/pcmcia/ipwireless/hardware.c:726: unlock: Unlocking "hw->lock". "packet" might now be unreliable because other threads can now change the data that it depends on.
drivers/char/pcmcia/ipwireless/hardware.c:737: lockagain: Locking "hw->lock" again.
drivers/char/pcmcia/ipwireless/hardware.c:751: use: Using an unreliable value of "packet" inside the second locked section.  If the data that "packet" depends on was changed by another thread, this use might be incorrect.

Error: ATOMICITY:
drivers/char/specialix.c:1485: lock: Locking "port->lock".
drivers/char/specialix.c:1493: def: Assigning: "bp" = data that might be protected by the lock.
drivers/char/specialix.c:1516: unlock: Unlocking "port->lock". "bp" might now be unreliable because other threads can now change the data that it depends on.
drivers/char/specialix.c:1531: lockagain: Locking "bp->lock" again.
drivers/char/specialix.c:1532: use: Using an unreliable value of "bp" inside the second locked section.  If the data that "bp" depends on was changed by another thread, this use might be incorrect.

Error: ATOMICITY:
drivers/mtd/mtd_blkdevs.c:107: lock: Locking "*rq->queue_lock".
drivers/mtd/mtd_blkdevs.c:101: def: Assigning: "req" = data that might be protected by the lock.
drivers/mtd/mtd_blkdevs.c:114: unlock: Unlocking "*rq->queue_lock". "req" might now be unreliable because other threads can now change the data that it depends on.
drivers/mtd/mtd_blkdevs.c:120: lockagain: Locking "*rq->queue_lock" again.
drivers/mtd/mtd_blkdevs.c:122: use: Using an unreliable value of "req" inside the second locked section.  If the data that "req" depends on was changed by another thread, this use might be incorrect.

Error: ATOMICITY:
fs/smbfs/smbiod.c:319: lock: Locking "servers_lock".
fs/smbfs/smbiod.c:326: def: Assigning: "n" = data that might be protected by the lock.
fs/smbfs/smbiod.c:331: unlock: Unlocking "servers_lock". "n" might now be unreliable because other threads can now change the data that it depends on.
fs/smbfs/smbiod.c:337: lockagain: Locking "servers_lock" again.
fs/smbfs/smbiod.c:326: use: Using an unreliable value of "n" inside the second locked section.  If the data that "n" depends on was changed by another thread, this use might be incorrect.

Error: ATOMICITY:
drivers/net/wireless/b43/main.c:3364: lock: Locking "wl->irq_lock".
drivers/net/wireless/b43/main.c:3369: def: Assigning: "savedirqs" = data that might be protected by the lock.
drivers/net/wireless/b43/main.c:3370: unlock: Unlocking "wl->irq_lock". "savedirqs" might now be unreliable because other threads can now change the data that it depends on.
drivers/net/wireless/b43/main.c:3398: unlock: Unlocking "wl->irq_lock". "savedirqs" might now be unreliable because other threads can now change the data that it depends on.
drivers/net/wireless/b43/main.c:3428: lockagain: Locking "wl->irq_lock" again.
drivers/net/wireless/b43/main.c:3429: use: Using an unreliable value of "savedirqs" inside the second locked section.  If the data that "savedirqs" depends on was changed by another thread, this use might be incorrect.

Error: ATOMICITY:
drivers/pcmcia/cs.c:667: lock: Locking "skt->thread_lock".
drivers/pcmcia/cs.c:669: def: Assigning: "skt->thread_events" = data that might be protected by the lock.
drivers/pcmcia/cs.c:670: unlock: Unlocking "skt->thread_lock". "skt->thread_events" might now be unreliable because other threads can now change the data that it depends on.
drivers/pcmcia/cs.c:667: lockagain: Locking "skt->thread_lock" again.
drivers/pcmcia/cs.c:668: use: Using an unreliable value of "skt->thread_events" inside the second locked section.  If the data that "skt->thread_events" depends on was changed by another thread, this use might be incorrect.

Error: ATOMICITY:
drivers/watchdog/it87_wdt.c:566: lock: Locking "spinlock".
drivers/watchdog/it87_wdt.c:581: def: Assigning: "gpact" = data that might be protected by the lock.
drivers/watchdog/it87_wdt.c:584: unlock: Unlocking "spinlock". "gpact" might now be unreliable because other threads can now change the data that it depends on.
drivers/watchdog/it87_wdt.c:609: lockagain: Locking "spinlock" again.
drivers/watchdog/it87_wdt.c:619: use: Using an unreliable value of "gpact" inside the second locked section.  If the data that "gpact" depends on was changed by another thread, this use might be incorrect.

Error: ATOMICITY:
drivers/watchdog/it87_wdt.c:566: lock: Locking "spinlock".
drivers/watchdog/it87_wdt.c:581: def: Assigning: "gpact" = data that might be protected by the lock.
drivers/watchdog/it87_wdt.c:584: unlock: Unlocking "spinlock". "gpact" might now be unreliable because other threads can now change the data that it depends on.
drivers/watchdog/it87_wdt.c:680: lockagain: Locking "spinlock" again.
drivers/watchdog/it87_wdt.c:683: use: Using an unreliable value of "gpact" inside the second locked section.  If the data that "gpact" depends on was changed by another thread, this use might be incorrect.

Error: ATOMICITY:
drivers/watchdog/it87_wdt.c:609: lock: Locking "spinlock".
drivers/watchdog/it87_wdt.c:615: def: Assigning: "ciract" = data that might be protected by the lock.
drivers/watchdog/it87_wdt.c:623: unlock: Unlocking "spinlock". "ciract" might now be unreliable because other threads can now change the data that it depends on.
drivers/watchdog/it87_wdt.c:671: lockagain: Locking "spinlock" again.
drivers/watchdog/it87_wdt.c:674: use: Using an unreliable value of "ciract" inside the second locked section.  If the data that "ciract" depends on was changed by another thread, this use might be incorrect.

Error: ATOMICITY:
drivers/firewire/fw-card.c:203: lock: Locking "card->lock".
drivers/firewire/fw-card.c:214: def: Assigning: "generation" = data that might be protected by the lock.
drivers/firewire/fw-card.c:246: unlock: Unlocking "card->lock". "generation" might now be unreliable because other threads can now change the data that it depends on.
drivers/firewire/fw-card.c:262: lockagain: Locking "card->lock" again.
drivers/firewire/fw-card.c:292: use: Using an unreliable value of "generation" inside the second locked section.  If the data that "generation" depends on was changed by another thread, this use might be incorrect.

Error: ATOMICITY:
drivers/firewire/fw-card.c:203: lock: Locking "card->lock".
drivers/firewire/fw-card.c:218: def: Assigning: "root_id" = data that might be protected by the lock.
drivers/firewire/fw-card.c:246: unlock: Unlocking "card->lock". "root_id" might now be unreliable because other threads can now change the data that it depends on.
drivers/firewire/fw-card.c:262: lockagain: Locking "card->lock" again.
drivers/firewire/fw-card.c:314: use: Using an unreliable value of "root_id" inside the second locked section.  If the data that "root_id" depends on was changed by another thread, this use might be incorrect.

Error: ATOMICITY:
fs/fuse/dev.c:747: lock: Locking "fc->lock".
fs/fuse/dev.c:767: def: Assigning: "req" = data that might be protected by the lock.
fs/fuse/dev.c:782: unlock: Unlocking "fc->lock". "req" might now be unreliable because other threads can now change the data that it depends on.
fs/fuse/dev.c:789: lockagain: Locking "fc->lock" again.
fs/fuse/dev.c:792: use: Using an unreliable value of "req" inside the second locked section.  If the data that "req" depends on was changed by another thread, this use might be incorrect.

Error: ATOMICITY:
fs/fuse/dev.c:747: lock: Locking "fc->lock".
fs/fuse/dev.c:767: def: Assigning: "req" = data that might be protected by the lock.
fs/fuse/dev.c:782: unlock: Unlocking "fc->lock". "req" might now be unreliable because other threads can now change the data that it depends on.
fs/fuse/dev.c:789: lockagain: Locking "fc->lock" again.
fs/fuse/dev.c:797: use: Using an unreliable value of "req" inside the second locked section.  If the data that "req" depends on was changed by another thread, this use might be incorrect.

Error: ATOMICITY:
fs/fuse/dev.c:747: lock: Locking "fc->lock".
fs/fuse/dev.c:767: def: Assigning: "req" = data that might be protected by the lock.
fs/fuse/dev.c:782: unlock: Unlocking "fc->lock". "req" might now be unreliable because other threads can now change the data that it depends on.
fs/fuse/dev.c:789: lockagain: Locking "fc->lock" again.
fs/fuse/dev.c:801: use: Using an unreliable value of "req" inside the second locked section.  If the data that "req" depends on was changed by another thread, this use might be incorrect.

Error: ATOMICITY:
fs/fuse/dev.c:747: lock: Locking "fc->lock".
fs/fuse/dev.c:767: def: Assigning: "req" = data that might be protected by the lock.
fs/fuse/dev.c:782: unlock: Unlocking "fc->lock". "req" might now be unreliable because other threads can now change the data that it depends on.
fs/fuse/dev.c:789: lockagain: Locking "fc->lock" again.
fs/fuse/dev.c:806: use: Using an unreliable value of "req" inside the second locked section.  If the data that "req" depends on was changed by another thread, this use might be incorrect.

Error: LOCK:
lib/dec_and_lock.c:28: lock: "_spin_lock" locks "lock".
lib/dec_and_lock.c:30: missing_unlock: Returning without unlocking "lock".

Error: LOCK:
kernel/sched.c:4463: lock: "_spin_lock_irq" locks "rq->lock".
kernel/sched.c:4509: missing_unlock: Returning without unlocking "rq->lock".

Error: LOCK:
kernel/sched.c:4463: lock: "_spin_lock_irq" locks "rq->lock".
kernel/sched.c:4463: double_lock: "_spin_lock_irq" locks "rq->lock" twice.

Error: LOCK:
fs/namespace.c:279: lock: "_spin_lock" locks "cpu_writer->lock".
fs/namespace.c:279: double_lock: "_spin_lock" locks "cpu_writer->lock" twice.

Error: LOCK:
fs/dcache.c:223: lock: "_atomic_dec_and_lock" locks "dcache_lock".
lib/dec_and_lock.c:28: lock: "_spin_lock" locks "*lock".
fs/dcache.c:259: missing_unlock: Returning without unlocking "dcache_lock".

Error: LOCK:
fs/dcache.c:223: lock: "_atomic_dec_and_lock" locks "dcache_lock".
lib/dec_and_lock.c:28: lock: "_spin_lock" locks "*lock".
fs/dcache.c:223: double_lock: "_atomic_dec_and_lock" locks "dcache_lock" twice.
lib/dec_and_lock.c:28: lock: "_spin_lock" locks "*lock".

Error: LOCK:
fs/dcache.c:432: lock: "_spin_lock" locks "dcache_lock".
fs/dcache.c:444: missing_unlock: Returning without unlocking "dcache_lock".

Error: LOCK:
fs/dcache.c:432: lock: "_spin_lock" locks "dcache_lock".
fs/dcache.c:442: double_lock: "_spin_lock" locks "dcache_lock" twice.

Error: LOCK:
kernel/semaphore.c:222: lock: "_spin_lock_irq" locks "sem->lock".
kernel/semaphore.c:233: missing_unlock: Returning without unlocking "sem->lock".

Error: LOCK:
arch/x86/mm/pageattr.c:469: lock: "_spin_lock" locks "cpa_lock".
arch/x86/mm/pageattr.c:471: missing_unlock: Returning without unlocking "cpa_lock".

Error: LOCK:
arch/x86/mm/pageattr.c:469: lock: "_spin_lock" locks "cpa_lock".
arch/x86/mm/pageattr.c:534: missing_unlock: Returning without unlocking "cpa_lock".

Error: LOCK:
net/xfrm/xfrm_state.c:1956: lock: "_read_lock" locks "xfrm_state_afinfo_lock".
net/xfrm/xfrm_state.c:1960: missing_unlock: Returning without unlocking "xfrm_state_afinfo_lock".

Error: LOCK:
fs/dcache.c:1528: lock: "_spin_lock" locks "dcache_lock".
fs/dcache.c:1534: missing_unlock: Returning without unlocking "dcache_lock".

Error: LOCK:
fs/fs-writeback.c:408: lock: "_spin_lock" locks "inode_lock".
fs/fs-writeback.c:405: unlock: "_spin_unlock" unlocks "inode_lock".
fs/fs-writeback.c:408: lock: "_spin_lock" locks "inode_lock".
fs/fs-writeback.c:411: missing_unlock: Returning without unlocking "inode_lock".

Error: LOCK:
fs/ext4/mballoc.c:4189: lock: "_spin_lock" locks "tmp_pa->pa_lock".
fs/ext4/mballoc.c:4218: missing_unlock: Returning without unlocking "tmp_pa->pa_lock".

Error: LOCK:
fs/ext4/mballoc.c:4189: lock: "_spin_lock" locks "tmp_pa->pa_lock".
fs/ext4/mballoc.c:4189: double_lock: "_spin_lock" locks "tmp_pa->pa_lock" twice.

Error: LOCK:
net/xfrm/xfrm_policy.c:2358: lock: "_read_lock" locks "xfrm_policy_afinfo_lock".
net/xfrm/xfrm_policy.c:2362: missing_unlock: Returning without unlocking "xfrm_policy_afinfo_lock".

Error: LOCK:
fs/mbcache.c:585: lock: "_spin_lock" locks "mb_cache_spinlock".
fs/mbcache.c:586: missing_unlock: Returning without unlocking "mb_cache_spinlock".

Error: LOCK:
fs/jbd/checkpoint.c:139: lock: "_spin_lock" locks "journal->j_state_lock".
fs/jbd/checkpoint.c:150: unlock: "_spin_unlock" unlocks "journal->j_state_lock".
fs/jbd/checkpoint.c:167: lock: "_spin_lock" locks "journal->j_state_lock".
fs/jbd/checkpoint.c:173: missing_unlock: Returning without unlocking "journal->j_state_lock".

Error: LOCK:
fs/mbcache.c:518: lock: "_spin_lock" locks "mb_cache_spinlock".
fs/mbcache.c:541: missing_unlock: Returning without unlocking "mb_cache_spinlock".

Error: LOCK:
block/blk-core.c:866: lock: "_spin_lock_irq" locks "q->queue_lock".
block/blk-core.c:872: missing_unlock: Returning without unlocking "q->queue_lock".

Error: LOCK:
fs/xfs/xfs_mru_cache.c:554: lock: "_spin_lock" locks "mru->lock".
fs/xfs/xfs_mru_cache.c:563: missing_unlock: Returning without unlocking "mru->lock".

Error: LOCK:
mm/mmap.c:553: lock: "_spin_lock" locks "mapping->i_mmap_lock".
mm/mmap.c:660: missing_unlock: Returning without unlocking "mapping->i_mmap_lock".

Error: LOCK:
mm/mmap.c:553: lock: "_spin_lock" locks "mapping->i_mmap_lock".
mm/mmap.c:553: double_lock: "_spin_lock" locks "mapping->i_mmap_lock" twice.

Error: LOCK:
fs/xfs/xfs_filestream.c:282: lock: "xfs_mru_cache_lookup" locks "cache->lock".
fs/xfs/xfs_mru_cache.c:554: lock: "_spin_lock" locks "mru->lock".
fs/xfs/xfs_filestream.c:316: missing_unlock: Returning without unlocking "cache->lock".

Error: LOCK:
fs/xfs/xfs_filestream.c:282: lock: "xfs_mru_cache_lookup" locks "cache->lock".
fs/xfs/xfs_mru_cache.c:554: lock: "_spin_lock" locks "mru->lock".
fs/xfs/xfs_filestream.c:325: missing_unlock: Returning without unlocking "cache->lock".

Error: LOCK:
fs/xfs/xfs_filestream.c:282: lock: "xfs_mru_cache_lookup" locks "cache->lock".
fs/xfs/xfs_mru_cache.c:554: lock: "_spin_lock" locks "mru->lock".
fs/xfs/xfs_filestream.c:347: missing_unlock: Returning without unlocking "cache->lock".

Error: LOCK:
include/linux/netdevice.h:1555: lock: "_spin_lock" locks "dev->tx_global_lock".
include/linux/netdevice.h:1570: missing_unlock: Returning without unlocking "dev->tx_global_lock".

Error: LOCK:
fs/xfs/xfs_filestream.c:656: lock: "xfs_mru_cache_lookup" locks "cache->lock".
fs/xfs/xfs_mru_cache.c:554: lock: "_spin_lock" locks "mru->lock".
fs/xfs/xfs_filestream.c:683: missing_unlock: Returning without unlocking "cache->lock".

Error: LOCK:
fs/xfs/xfs_filestream.c:495: lock: "xfs_mru_cache_lookup" locks "cache->lock".
fs/xfs/xfs_mru_cache.c:554: lock: "_spin_lock" locks "mru->lock".
fs/xfs/xfs_filestream.c:498: missing_unlock: Returning without unlocking "cache->lock".

Error: LOCK:
sound/core/pcm_native.c:708: lock: "_spin_lock" locks "s->self_group.lock".
sound/core/pcm_native.c:708: double_lock: "_spin_lock" locks "s->self_group.lock" twice.

Error: LOCK:
fs/inotify.c:442: lock: "_spin_lock" locks "inode_lock".
fs/inotify.c:444: missing_unlock: Returning without unlocking "inode_lock".

Error: LOCK:
fs/jfs/jfs_logmgr.c:2099: lock: "_spin_lock_irq" locks "log->gclock".
fs/jfs/jfs_logmgr.c:2101: missing_unlock: Returning without unlocking "log->gclock".

Error: LOCK:
sound/core/pcm_native.c:777: lock: "_spin_lock" locks "substream->self_group.lock".
sound/core/pcm_native.c:784: missing_unlock: Returning without unlocking "substream->self_group.lock".

Error: LOCK:
kernel/futex.c:908: lock: "double_lock_hb" locks "hb2->lock".
kernel/futex.c:711: lock: "_spin_lock" locks "hb2->lock".
kernel/futex.c:978: missing_unlock: Returning without unlocking "hb2->lock".

Error: LOCK:
kernel/futex.c:908: lock: "double_lock_hb" locks "hb2->lock".
kernel/futex.c:711: lock: "_spin_lock" locks "hb2->lock".
kernel/futex.c:908: double_lock: "double_lock_hb" locks "hb2->lock" twice.
kernel/futex.c:711: lock: "_spin_lock" locks "hb2->lock".

Error: LOCK:
kernel/futex.c:908: lock: "double_lock_hb" locks "hb2->lock".
kernel/futex.c:711: lock: "_spin_lock" locks "hb2->lock".
kernel/futex.c:953: transfer: Assigning: "this->lock_ptr" = "hb2->lock"; both now point to the same lock.
kernel/futex.c:978: missing_unlock: Returning without unlocking "this->lock_ptr".

Error: LOCK:
kernel/futex.c:908: lock: "double_lock_hb" locks "hb2->lock".
kernel/futex.c:711: lock: "_spin_lock" locks "hb2->lock".
kernel/futex.c:953: transfer: Assigning: "this->lock_ptr" = "hb2->lock"; both now point to the same lock.
kernel/futex.c:978: missing_unlock: Returning without unlocking "this->lock_ptr".
kernel/futex.c:978: missing_unlock: Returning without unlocking "hb2->lock".

Error: LOCK:
kernel/futex.c:796: lock: "double_lock_hb" locks "hb2->lock".
kernel/futex.c:711: lock: "_spin_lock" locks "hb2->lock".
kernel/futex.c:878: missing_unlock: Returning without unlocking "hb2->lock".

Error: LOCK:
kernel/signal.c:1580: lock: "_spin_lock_irq" locks "get_current()->sighand->siglock".
kernel/signal.c:1589: missing_unlock: Returning without unlocking "get_current()->sighand->siglock".

Error: LOCK:
drivers/scsi/qla2xxx/qla_iocb.c:534: lock: "_spin_lock_irq" locks "ha->hardware_lock".
drivers/scsi/qla2xxx/qla_iocb.c:540: missing_unlock: Returning without unlocking "ha->hardware_lock".

Error: LOCK:
drivers/scsi/qla2xxx/qla_iocb.c:534: lock: "_spin_lock_irq" locks "ha->hardware_lock".
drivers/scsi/qla2xxx/qla_iocb.c:525: unlock: "_spin_unlock" unlocks "ha->hardware_lock".
drivers/scsi/qla2xxx/qla_iocb.c:534: lock: "_spin_lock_irq" locks "ha->hardware_lock".
drivers/scsi/qla2xxx/qla_iocb.c:540: missing_unlock: Returning without unlocking "ha->hardware_lock".

Error: LOCK:
fs/jfs/jfs_txnmgr.c:204: lock: "_spin_lock" locks "jfsTxnLock".
fs/jfs/jfs_txnmgr.c:204: double_lock: "_spin_lock" locks "jfsTxnLock" twice.

Error: LOCK:
fs/jbd2/checkpoint.c:140: lock: "_spin_lock" locks "journal->j_state_lock".
fs/jbd2/checkpoint.c:151: unlock: "_spin_unlock" unlocks "journal->j_state_lock".
fs/jbd2/checkpoint.c:169: lock: "_spin_lock" locks "journal->j_state_lock".
fs/jbd2/checkpoint.c:175: missing_unlock: Returning without unlocking "journal->j_state_lock".

Error: LOCK:
fs/jfs/jfs_txnmgr.c:604: lock: "_spin_lock" locks "jfsTxnLock".
fs/jfs/jfs_txnmgr.c:846: unlock: "_spin_unlock" unlocks "jfsTxnLock".
fs/jfs/jfs_txnmgr.c:848: lock: "_spin_lock" locks "jfsTxnLock".
fs/jfs/jfs_txnmgr.c:861: missing_unlock: Returning without unlocking "jfsTxnLock".

Error: LOCK:
include/linux/netdevice.h:1555: lock: "_spin_lock" locks "dev->tx_global_lock".
include/linux/netdevice.h:1570: missing_unlock: Returning without unlocking "dev->tx_global_lock".

Error: LOCK:
mm/memory.c:567: lock: "_spin_lock" locks "__ptl".
mm/memory.c:569: missing_unlock: Returning without unlocking "__ptl".

Error: LOCK:
mm/memory.c:567: lock: "_spin_lock" locks "__ptl".
mm/memory.c:602: missing_unlock: Returning without unlocking "__ptl".

Error: LOCK:
mm/memory.c:567: lock: "_spin_lock" locks "__ptl".
mm/memory.c:567: transfer: Assigning: "dst_ptl" = "__ptl"; both now point to the same lock.
mm/memory.c:567: double_lock: "_spin_lock" locks "__ptl" twice.

Error: LOCK:
mm/memory.c:567: lock: "_spin_lock" locks "__ptl".
mm/memory.c:567: transfer: Assigning: "dst_ptl" = "__ptl"; both now point to the same lock.
mm/memory.c:567: double_lock: "_spin_lock" locks "__ptl" twice.
mm/memory.c:567: transfer: Assigning: "dst_ptl" = "__ptl"; both now point to the same lock.
mm/memory.c:567: lock: "_spin_lock" locks "__ptl".
mm/memory.c:569: missing_unlock: Returning without unlocking "__ptl".

Error: LOCK:
mm/memory.c:567: lock: "_spin_lock" locks "__ptl".
mm/memory.c:567: transfer: Assigning: "dst_ptl" = "__ptl"; both now point to the same lock.
mm/memory.c:567: double_lock: "_spin_lock" locks "__ptl" twice.
mm/memory.c:567: transfer: Assigning: "dst_ptl" = "__ptl"; both now point to the same lock.
mm/memory.c:567: lock: "_spin_lock" locks "__ptl".
mm/memory.c:569: missing_unlock: Returning without unlocking "__ptl".
mm/memory.c:569: missing_unlock: Returning without unlocking "dst_ptl".

Error: LOCK:
fs/jfs/jfs_txnmgr.c:371: lock: "_spin_lock" locks "jfsTxnLock".
fs/jfs/jfs_txnmgr.c:383: double_lock: "_spin_lock" locks "jfsTxnLock" twice.

Error: LOCK:
fs/jfs/jfs_txnmgr.c:371: lock: "_spin_lock" locks "jfsTxnLock".
fs/jfs/jfs_txnmgr.c:395: double_lock: "_spin_lock" locks "jfsTxnLock" twice.

Error: LOCK:
fs/jfs/jfs_txnmgr.c:371: lock: "_spin_lock" locks "jfsTxnLock".
fs/jfs/jfs_txnmgr.c:406: double_lock: "_spin_lock" locks "jfsTxnLock" twice.

Error: LOCK:
fs/jfs/jfs_txnmgr.c:371: lock: "_spin_lock" locks "jfsTxnLock".
fs/jfs/jfs_txnmgr.c:416: double_lock: "_spin_lock" locks "jfsTxnLock" twice.

Error: LOCK:
include/linux/netdevice.h:1555: lock: "_spin_lock" locks "dev->tx_global_lock".
include/linux/netdevice.h:1570: missing_unlock: Returning without unlocking "dev->tx_global_lock".

Error: LOCK:
net/netlink/af_netlink.c:176: lock: "_write_lock_irq" locks "nl_table_lock".
net/netlink/af_netlink.c:194: missing_unlock: Returning without unlocking "nl_table_lock".

Error: LOCK:
drivers/block/cciss.c:2970: lock: "_spin_lock_irqsave" locks "hba[h->ctlr]->lock".
drivers/block/cciss.c:2981: missing_unlock: Returning without unlocking "hba[h->ctlr]->lock".

Error: LOCK:
mm/mmap.c:2405: lock: "vm_lock_anon_vma" locks "vma->anon_vma->lock".
mm/mmap.c:2319: lock: "_spin_lock" locks "anon_vma->lock".
mm/mmap.c:2405: double_lock: "vm_lock_anon_vma" locks "vma->anon_vma->lock" twice.
mm/mmap.c:2319: lock: "_spin_lock" locks "anon_vma->lock".

Error: LOCK:
mm/mmap.c:2398: lock: "vm_lock_mapping" locks "vma->vm_file->f_mapping->i_mmap_lock".
mm/mmap.c:2349: lock: "_spin_lock" locks "mapping->i_mmap_lock".
mm/mmap.c:2398: double_lock: "vm_lock_mapping" locks "vma->vm_file->f_mapping->i_mmap_lock" twice.
mm/mmap.c:2349: lock: "_spin_lock" locks "mapping->i_mmap_lock".

Error: LOCK:
drivers/net/wireless/ath9k/xmit.c:1835: lock: "_spin_lock" locks "txq->axq_lock".
drivers/net/wireless/ath9k/xmit.c:1846: missing_unlock: Returning without unlocking "txq->axq_lock".

Error: LOCK:
kernel/audit_tree.c:318: lock: "_spin_lock" locks "hash_lock".
kernel/audit_tree.c:319: missing_unlock: Returning without unlocking "hash_lock".

Error: LOCK:
kernel/audit_tree.c:250: lock: "_spin_lock" locks "hash_lock".
kernel/audit_tree.c:256: unlock: "_spin_unlock" unlocks "hash_lock".
kernel/audit_tree.c:318: lock: "_spin_lock" locks "hash_lock".
kernel/audit_tree.c:319: missing_unlock: Returning without unlocking "hash_lock".

Error: LOCK:
kernel/audit_tree.c:272: lock: "_spin_lock" locks "hash_lock".
kernel/audit_tree.c:298: unlock: "_spin_unlock" unlocks "hash_lock".
kernel/audit_tree.c:318: lock: "_spin_lock" locks "hash_lock".
kernel/audit_tree.c:319: missing_unlock: Returning without unlocking "hash_lock".

Error: LOCK:
kernel/audit_tree.c:306: lock: "_spin_lock" locks "hash_lock".
kernel/audit_tree.c:314: unlock: "_spin_unlock" unlocks "hash_lock".
kernel/audit_tree.c:318: lock: "_spin_lock" locks "hash_lock".
kernel/audit_tree.c:319: missing_unlock: Returning without unlocking "hash_lock".

Error: LOCK:
fs/ocfs2/dlm/dlmthread.c:75: lock: "_spin_lock" locks "res->spinlock".
fs/ocfs2/dlm/dlmthread.c:80: missing_unlock: Returning without unlocking "res->spinlock".

Error: LOCK:
drivers/scsi/dpt_i2o.c:1332: lock: "_spin_lock_irq" locks "pHba->host->host_lock".
drivers/scsi/dpt_i2o.c:1362: missing_unlock: Returning without unlocking "pHba->host->host_lock".

Error: LOCK:
net/sctp/socket.c:5575: lock: "_spin_lock" locks "head->lock".
net/sctp/socket.c:5689: missing_unlock: Returning without unlocking "head->lock".

Error: LOCK:
drivers/ide/ide.c:145: lock: "_spin_lock_irq" locks "ide_lock".
drivers/ide/ide.c:142: unlock: "_spin_unlock_irq" unlocks "ide_lock".
drivers/ide/ide.c:145: lock: "_spin_lock_irq" locks "ide_lock".
drivers/ide/ide.c:148: missing_unlock: Returning without unlocking "ide_lock".

Error: LOCK:
net/mac80211/scan.c:44: lock: "ieee80211_rx_bss_put" locks "local->bss_lock".
net/mac80211/scan.c:210: lock: "_atomic_dec_and_lock" locks "local->bss_lock".
lib/dec_and_lock.c:28: lock: "_spin_lock" locks "*lock".
net/mac80211/scan.c:44: double_lock: "ieee80211_rx_bss_put" locks "local->bss_lock" twice.
net/mac80211/scan.c:210: lock: "_atomic_dec_and_lock" locks "local->bss_lock".
lib/dec_and_lock.c:28: lock: "_spin_lock" locks "*lock".

Error: LOCK:
drivers/infiniband/hw/cxgb3/iwch_qp.c:811: lock: "_spin_lock" locks "qhp->lock".
drivers/infiniband/hw/cxgb3/iwch_qp.c:815: unlock: "_spin_unlock" unlocks "qhp->lock".
drivers/infiniband/hw/cxgb3/iwch_qp.c:822: lock: "_spin_lock" locks "qhp->lock".
drivers/infiniband/hw/cxgb3/iwch_qp.c:826: unlock: "_spin_unlock" unlocks "qhp->lock".
drivers/infiniband/hw/cxgb3/iwch_qp.c:835: lock: "_spin_lock_irqsave" locks "qhp->lock".
drivers/infiniband/hw/cxgb3/iwch_qp.c:836: missing_unlock: Returning without unlocking "qhp->lock".

Error: LOCK:
include/linux/netdevice.h:1555: lock: "_spin_lock" locks "dev->tx_global_lock".
include/linux/netdevice.h:1570: missing_unlock: Returning without unlocking "dev->tx_global_lock".

Error: LOCK:
mm/mremap.c:103: lock: "_spin_lock" locks "__ptl".
mm/mremap.c:127: missing_unlock: Returning without unlocking "__ptl".

Error: LOCK:
mm/mremap.c:93: lock: "_spin_lock" locks "mapping->i_mmap_lock".
mm/mremap.c:127: missing_unlock: Returning without unlocking "mapping->i_mmap_lock".

Error: LOCK:
drivers/char/ip2/i2lib.c:622: lock: "_write_lock_irqsave" locks "lock_var_p".
drivers/char/ip2/i2lib.c:770: missing_unlock: Returning without unlocking "lock_var_p".

Error: LOCK:
drivers/char/ip2/i2lib.c:628: lock: "_write_lock_irqsave" locks "lock_var_p".
drivers/char/ip2/i2lib.c:770: missing_unlock: Returning without unlocking "lock_var_p".

Error: LOCK:
drivers/char/ip2/i2lib.c:622: lock: "_write_lock_irqsave" locks "lock_var_p".
drivers/char/ip2/i2lib.c:647: unlock: "_write_unlock_irqrestore" unlocks "lock_var_p".
drivers/char/ip2/i2lib.c:622: lock: "_write_lock_irqsave" locks "lock_var_p".
drivers/char/ip2/i2lib.c:770: missing_unlock: Returning without unlocking "lock_var_p".

Error: LOCK:
fs/ocfs2/dlm/dlmmaster.c:2718: lock: "_spin_lock" locks "dlm->spinlock".
fs/ocfs2/dlm/dlmmaster.c:2720: missing_unlock: Returning without unlocking "dlm->spinlock".

Error: LOCK:
fs/super.c:343: lock: "_spin_lock" locks "sb_lock".
fs/super.c:343: double_lock: "_spin_lock" locks "sb_lock" twice.

Error: LOCK:
fs/super.c:343: lock: "_spin_lock" locks "sb_lock".
fs/super.c:356: unlock: "_spin_unlock" unlocks "sb_lock".
fs/super.c:343: lock: "_spin_lock" locks "sb_lock".
fs/super.c:343: double_lock: "_spin_lock" locks "sb_lock" twice.

Error: LOCK:
drivers/mtd/chips/cfi_cmdset_0001.c:944: lock: "_spin_lock" locks "chip->mutex".
drivers/mtd/chips/cfi_cmdset_0001.c:947: missing_unlock: Returning without unlocking "chip->mutex".

Error: LOCK:
fs/jfs/jfs_txnmgr.c:467: lock: "_spin_lock" locks "jfsTxnLock".
fs/jfs/jfs_txnmgr.c:477: double_lock: "_spin_lock" locks "jfsTxnLock" twice.

Error: LOCK:
fs/jfs/jfs_txnmgr.c:467: lock: "_spin_lock" locks "jfsTxnLock".
fs/jfs/jfs_txnmgr.c:486: double_lock: "_spin_lock" locks "jfsTxnLock" twice.

Error: LOCK:
drivers/mtd/chips/cfi_cmdset_0002.c:571: lock: "_spin_lock" locks "chip->mutex".
drivers/mtd/chips/cfi_cmdset_0002.c:579: missing_unlock: Returning without unlocking "chip->mutex".

Error: LOCK:
drivers/mtd/chips/cfi_cmdset_0002.c:623: lock: "_spin_lock" locks "chip->mutex".
drivers/mtd/chips/cfi_cmdset_0002.c:618: missing_unlock: Returning without unlocking "chip->mutex".

Error: LOCK:
drivers/mtd/chips/cfi_cmdset_0002.c:623: lock: "_spin_lock" locks "chip->mutex".
drivers/mtd/chips/cfi_cmdset_0002.c:628: missing_unlock: Returning without unlocking "chip->mutex".

Error: LOCK:
drivers/pci/access.c:88: lock: "_spin_lock_irq" locks "pci_lock".
drivers/pci/access.c:91: missing_unlock: Returning without unlocking "pci_lock".

Error: LOCK:
drivers/mtd/chips/cfi_cmdset_0001.c:1192: lock: "_spin_lock" locks "chip->mutex".
drivers/mtd/chips/cfi_cmdset_0001.c:1249: missing_unlock: Returning without unlocking "chip->mutex".

Error: LOCK:
drivers/mtd/chips/cfi_cmdset_0001.c:1192: lock: "_spin_lock" locks "chip->mutex".
drivers/mtd/chips/cfi_cmdset_0001.c:1212: unlock: "_spin_unlock" unlocks "chip->mutex".
drivers/mtd/chips/cfi_cmdset_0001.c:1227: lock: "_spin_lock" locks "chip->mutex".
drivers/mtd/chips/cfi_cmdset_0001.c:1234: unlock: "_spin_unlock" unlocks "chip->mutex".
drivers/mtd/chips/cfi_cmdset_0001.c:1237: lock: "_spin_lock" locks "chip->mutex".
drivers/mtd/chips/cfi_cmdset_0001.c:1249: missing_unlock: Returning without unlocking "chip->mutex".

Error: LOCK:
drivers/mtd/chips/cfi_cmdset_0001.c:1192: lock: "_spin_lock" locks "chip->mutex".
drivers/mtd/chips/cfi_cmdset_0001.c:1212: unlock: "_spin_unlock" unlocks "chip->mutex".
drivers/mtd/chips/cfi_cmdset_0001.c:1227: lock: "_spin_lock" locks "chip->mutex".
drivers/mtd/chips/cfi_cmdset_0001.c:1234: unlock: "_spin_unlock" unlocks "chip->mutex".
drivers/mtd/chips/cfi_cmdset_0001.c:1237: lock: "_spin_lock" locks "chip->mutex".
drivers/mtd/chips/cfi_cmdset_0001.c:1212: unlock: "_spin_unlock" unlocks "chip->mutex".
drivers/mtd/chips/cfi_cmdset_0001.c:1227: lock: "_spin_lock" locks "chip->mutex".
drivers/mtd/chips/cfi_cmdset_0001.c:1234: unlock: "_spin_unlock" unlocks "chip->mutex".
drivers/mtd/chips/cfi_cmdset_0001.c:1237: lock: "_spin_lock" locks "chip->mutex".
drivers/mtd/chips/cfi_cmdset_0001.c:1208: missing_unlock: Returning without unlocking "chip->mutex".

Error: LOCK:
drivers/mtd/chips/cfi_cmdset_0001.c:1192: lock: "_spin_lock" locks "chip->mutex".
drivers/mtd/chips/cfi_cmdset_0001.c:1212: unlock: "_spin_unlock" unlocks "chip->mutex".
drivers/mtd/chips/cfi_cmdset_0001.c:1227: lock: "_spin_lock" locks "chip->mutex".
drivers/mtd/chips/cfi_cmdset_0001.c:1234: unlock: "_spin_unlock" unlocks "chip->mutex".
drivers/mtd/chips/cfi_cmdset_0001.c:1237: lock: "_spin_lock" locks "chip->mutex".
drivers/mtd/chips/cfi_cmdset_0001.c:1212: unlock: "_spin_unlock" unlocks "chip->mutex".
drivers/mtd/chips/cfi_cmdset_0001.c:1227: lock: "_spin_lock" locks "chip->mutex".
drivers/mtd/chips/cfi_cmdset_0001.c:1234: unlock: "_spin_unlock" unlocks "chip->mutex".
drivers/mtd/chips/cfi_cmdset_0001.c:1237: lock: "_spin_lock" locks "chip->mutex".
drivers/mtd/chips/cfi_cmdset_0001.c:1249: missing_unlock: Returning without unlocking "chip->mutex".

Error: LOCK:
include/linux/netdevice.h:1555: lock: "_spin_lock" locks "dev->tx_global_lock".
include/linux/netdevice.h:1570: missing_unlock: Returning without unlocking "dev->tx_global_lock".

Error: LOCK:
net/atm/lec.c:1079: lock: "_spin_lock_irqsave" locks "priv->lec_arp_lock".
net/atm/lec.c:1087: missing_unlock: Returning without unlocking "priv->lec_arp_lock".

Error: LOCK:
drivers/isdn/i4l/isdn_net.h:81: lock: "_spin_lock" locks "nd->queue->xmit_lock".
drivers/isdn/i4l/isdn_net.h:83: unlock: "_spin_unlock" unlocks "nd->queue->xmit_lock".
drivers/isdn/i4l/isdn_net.h:89: lock: "_spin_lock" locks "nd->queue->xmit_lock".
drivers/isdn/i4l/isdn_net.h:96: missing_unlock: Returning without unlocking "nd->queue->xmit_lock".

Error: LOCK:
drivers/mtd/chips/cfi_cmdset_0001.c:878: lock: "_spin_lock" locks "chip->mutex".
drivers/mtd/chips/cfi_cmdset_0001.c:886: missing_unlock: Returning without unlocking "chip->mutex".

Error: LOCK:
drivers/mtd/chips/cfi_cmdset_0001.c:878: lock: "_spin_lock" locks "chip->mutex".
drivers/mtd/chips/cfi_cmdset_0001.c:924: missing_unlock: Returning without unlocking "chip->mutex".

Error: LOCK:
drivers/mtd/chips/cfi_cmdset_0001.c:878: lock: "_spin_lock" locks "chip->mutex".
drivers/mtd/chips/cfi_cmdset_0001.c:907: unlock: "_spin_unlock" unlocks "chip->mutex".
drivers/mtd/chips/cfi_cmdset_0001.c:910: lock: "_spin_lock" locks "chip->mutex".
drivers/mtd/chips/cfi_cmdset_0001.c:924: missing_unlock: Returning without unlocking "chip->mutex".

Error: LOCK:
fs/fuse/dev.c:975: lock: "_spin_lock" locks "fc->lock".
fs/fuse/dev.c:977: missing_unlock: Returning without unlocking "fc->lock".

Error: LOCK:
fs/ocfs2/dlm/dlmthread.c:196: lock: "_spin_lock" locks "dlm->spinlock".
fs/ocfs2/dlm/dlmthread.c:217: missing_unlock: Returning without unlocking "dlm->spinlock".

Error: LOCK:
net/ipv4/igmp.c:2295: lock: "_read_lock" locks "in_dev->mc_list_lock".
net/ipv4/igmp.c:2304: missing_unlock: Returning without unlocking "in_dev->mc_list_lock".

Error: LOCK:
net/ipv4/igmp.c:2444: lock: "_read_lock" locks "idev->mc_list_lock".
net/ipv4/igmp.c:2459: missing_unlock: Returning without unlocking "idev->mc_list_lock".

Error: LOCK:
net/dccp/ccid.c:27: lock: "_spin_lock" locks "ccids_lock".
net/dccp/ccid.c:33: missing_unlock: Returning without unlocking "ccids_lock".

Error: LOCK:
net/dccp/ccid.c:27: lock: "_spin_lock" locks "ccids_lock".
net/dccp/ccid.c:29: unlock: "_spin_unlock" unlocks "ccids_lock".
net/dccp/ccid.c:31: lock: "_spin_lock" locks "ccids_lock".
net/dccp/ccid.c:33: missing_unlock: Returning without unlocking "ccids_lock".

Error: LOCK:
drivers/scsi/aacraid/commsup.c:1270: lock: "_spin_lock_irq" locks "host->host_lock".
drivers/scsi/aacraid/commsup.c:1272: missing_unlock: Returning without unlocking "host->host_lock".

Error: LOCK:
drivers/net/wireless/orinoco.h:197: lock: "_spin_lock_irqsave" locks "priv->lock".
drivers/net/wireless/orinoco.h:204: missing_unlock: Returning without unlocking "priv->lock".

Error: LOCK:
fs/fuse/dev.c:1010: lock: "_spin_lock" locks "fc->lock".
fs/fuse/dev.c:1013: missing_unlock: Returning without unlocking "fc->lock".

Error: LOCK:
kernel/signal.c:1741: lock: "_spin_lock_irq" locks "sighand->siglock".
kernel/signal.c:1751: unlock: "_spin_unlock_irq" unlocks "sighand->siglock".
kernel/signal.c:1741: lock: "_spin_lock_irq" locks "sighand->siglock".
kernel/signal.c:1741: double_lock: "_spin_lock_irq" locks "sighand->siglock" twice.

Error: LOCK:
include/linux/netdevice.h:1555: lock: "_spin_lock" locks "dev->tx_global_lock".
include/linux/netdevice.h:1570: missing_unlock: Returning without unlocking "dev->tx_global_lock".

Error: LOCK:
include/linux/netdevice.h:1555: lock: "_spin_lock" locks "dev->tx_global_lock".
include/linux/netdevice.h:1570: missing_unlock: Returning without unlocking "dev->tx_global_lock".

Error: LOCK:
include/linux/netdevice.h:1555: lock: "_spin_lock" locks "dev->tx_global_lock".
include/linux/netdevice.h:1570: missing_unlock: Returning without unlocking "dev->tx_global_lock".

Error: LOCK:
net/ipv4/igmp.c:2324: lock: "_read_lock" locks "state->in_dev->mc_list_lock".
net/ipv4/igmp.c:2327: missing_unlock: Returning without unlocking "state->in_dev->mc_list_lock".

Error: LOCK:
net/ipv4/igmp.c:2483: lock: "_read_lock" locks "state->idev->mc_list_lock".
net/ipv4/igmp.c:2492: missing_unlock: Returning without unlocking "state->idev->mc_list_lock".

Error: LOCK:
ipc/namespace.c:80: lock: "ipc_lock_by_ptr" locks "perm->lock".
ipc/util.h:144: lock: "_spin_lock" locks "perm->lock".
ipc/namespace.c:80: double_lock: "ipc_lock_by_ptr" locks "perm->lock" twice.
ipc/util.h:144: lock: "_spin_lock" locks "perm->lock".

Error: LOCK:
fs/ocfs2/dlm/dlmdomain.c:1670: lock: "_spin_lock" locks "dlm_domain_lock".
fs/ocfs2/dlm/dlmdomain.c:1675: unlock: "_spin_unlock" unlocks "dlm_domain_lock".
fs/ocfs2/dlm/dlmdomain.c:1670: lock: "_spin_lock" locks "dlm_domain_lock".
fs/ocfs2/dlm/dlmdomain.c:1748: missing_unlock: Returning without unlocking "dlm_domain_lock".

Error: LOCK:
net/irda/irlmp.c:1867: lock: "_spin_lock_irq" locks "iter->hashbin->hb_spinlock".
net/irda/irlmp.c:1873: missing_unlock: Returning without unlocking "iter->hashbin->hb_spinlock".

Error: LOCK:
drivers/net/pcnet32.c:1133: lock: "_spin_lock_irqsave" locks "lp->lock".
drivers/net/pcnet32.c:1143: missing_unlock: Returning without unlocking "lp->lock".

Error: LOCK:
drivers/net/pcnet32.c:1133: lock: "_spin_lock_irqsave" locks "lp->lock".
drivers/net/pcnet32.c:1128: unlock: "_spin_unlock_irqrestore" unlocks "lp->lock".
drivers/net/pcnet32.c:1133: lock: "_spin_lock_irqsave" locks "lp->lock".
drivers/net/pcnet32.c:1143: missing_unlock: Returning without unlocking "lp->lock".

Error: LOCK:
drivers/net/pcnet32.c:1133: lock: "_spin_lock_irqsave" locks "lp->lock".
drivers/net/pcnet32.c:1128: unlock: "_spin_unlock_irqrestore" unlocks "lp->lock".
drivers/net/pcnet32.c:1133: lock: "_spin_lock_irqsave" locks "lp->lock".
drivers/net/pcnet32.c:1128: unlock: "_spin_unlock_irqrestore" unlocks "lp->lock".
drivers/net/pcnet32.c:1133: lock: "_spin_lock_irqsave" locks "lp->lock".
drivers/net/pcnet32.c:1140: missing_unlock: Returning without unlocking "lp->lock".

Error: LOCK:
drivers/net/wireless/orinoco.h:197: lock: "_spin_lock_irqsave" locks "priv->lock".
drivers/net/wireless/orinoco.h:204: missing_unlock: Returning without unlocking "priv->lock".

Error: LOCK:
fs/fuse/dev.c:678: lock: "_spin_lock" locks "fc->lock".
fs/fuse/dev.c:682: missing_unlock: Returning without unlocking "fc->lock".

Error: LOCK:
include/linux/netdevice.h:1555: lock: "_spin_lock" locks "dev->tx_global_lock".
include/linux/netdevice.h:1570: missing_unlock: Returning without unlocking "dev->tx_global_lock".

Error: LOCK:
kernel/rtmutex.c:580: lock: "_spin_lock" locks "lock->wait_lock".
kernel/rtmutex.c:581: missing_unlock: Returning without unlocking "lock->wait_lock".

Error: LOCK:
drivers/atm/he.c:1821: lock: "_spin_lock" locks "he_dev->global_lock".
drivers/atm/he.c:1857: missing_unlock: Returning without unlocking "he_dev->global_lock".

Error: LOCK:
drivers/scsi/scsi_lib.c:1530: lock: "_spin_lock" locks "sdev->request_queue->queue_lock".
drivers/scsi/scsi_lib.c:1533: missing_unlock: Returning without unlocking "sdev->request_queue->queue_lock".

Error: LOCK:
block/blk-core.c:1157: lock: "_spin_lock_irq" locks "q->queue_lock".
block/blk-core.c:1241: double_lock: "_spin_lock_irq" locks "q->queue_lock" twice.

Error: LOCK:
kernel/cgroup.c:2506: lock: "_spin_lock" locks "cgrp->dentry->d_lock".
kernel/cgroup.c:2517: missing_unlock: Returning without unlocking "cgrp->dentry->d_lock".

Error: LOCK:
net/ipv4/inet_connection_sock.c:110: lock: "_spin_lock" locks "head->lock".
net/ipv4/inet_connection_sock.c:179: missing_unlock: Returning without unlocking "head->lock".

Error: LOCK:
drivers/block/nbd.c:556: lock: "_spin_lock_irq" locks "q->queue_lock".
drivers/block/nbd.c:558: missing_unlock: Returning without unlocking "q->queue_lock".

Error: LOCK:
drivers/isdn/hisax/icc.c:468: lock: "_spin_lock_irqsave" locks "cs->lock".
drivers/isdn/hisax/icc.c:566: missing_unlock: Returning without unlocking "cs->lock".

Error: LOCK:
drivers/ata/libata-scsi.c:3048: lock: "_spin_lock" locks "shost->host_lock".
drivers/ata/libata-scsi.c:3049: missing_unlock: Returning without unlocking "shost->host_lock".

Error: LOCK:
drivers/isdn/hisax/amd7930_fn.c:594: lock: "_spin_lock_irqsave" locks "cs->lock".
drivers/isdn/hisax/amd7930_fn.c:667: missing_unlock: Returning without unlocking "cs->lock".

Error: LOCK:
net/bluetooth/rfcomm/sock.c:120: lock: "_spin_lock" locks "d->lock".
net/bluetooth/rfcomm/sock.c:122: missing_unlock: Returning without unlocking "d->lock".

Error: LOCK:
fs/xfs/xfs_mru_cache.c:585: lock: "_spin_lock" locks "mru->lock".
fs/xfs/xfs_mru_cache.c:592: missing_unlock: Returning without unlocking "mru->lock".

Error: LOCK:
drivers/net/qlge/qlge_main.c:3537: lock: "_spin_lock" locks "qdev->hw_lock".
drivers/net/qlge/qlge_main.c:3541: missing_unlock: Returning without unlocking "qdev->hw_lock".

Error: LOCK:
drivers/block/cciss.c:2898: lock: "_spin_lock_irq" locks "q->queue_lock".
drivers/block/cciss.c:2913: missing_unlock: Returning without unlocking "q->queue_lock".

Error: LOCK:
drivers/block/cciss.c:2898: lock: "_spin_lock_irq" locks "q->queue_lock".
drivers/block/cciss.c:2803: unlock: "_spin_unlock_irq" unlocks "q->queue_lock".
drivers/block/cciss.c:2898: lock: "_spin_lock_irq" locks "q->queue_lock".
drivers/block/cciss.c:2913: missing_unlock: Returning without unlocking "q->queue_lock".

Error: LOCK:
kernel/sched.c:9342: lock: "_spin_lock_irq" locks "({...})->lock".
kernel/sched.c:9342: double_lock: "_spin_lock_irq" locks "({...})->lock" twice.

Error: LOCK:
include/linux/netdevice.h:1555: lock: "_spin_lock" locks "dev->tx_global_lock".
include/linux/netdevice.h:1570: missing_unlock: Returning without unlocking "dev->tx_global_lock".

Error: LOCK:
include/linux/netdevice.h:1555: lock: "_spin_lock" locks "dev->tx_global_lock".
include/linux/netdevice.h:1570: missing_unlock: Returning without unlocking "dev->tx_global_lock".

Error: LOCK:
fs/cifs/file.c:188: lock: "_read_lock" locks "GlobalSMBSeslock".
fs/cifs/file.c:203: unlock: "_read_unlock" unlocks "GlobalSMBSeslock".
fs/cifs/file.c:297: lock: "_write_lock" locks "GlobalSMBSeslock".
fs/cifs/file.c:333: missing_unlock: Returning without unlocking "GlobalSMBSeslock".

Error: LOCK:
include/linux/netdevice.h:1555: lock: "_spin_lock" locks "dev->tx_global_lock".
include/linux/netdevice.h:1570: missing_unlock: Returning without unlocking "dev->tx_global_lock".

Error: LOCK:
include/linux/netdevice.h:1555: lock: "_spin_lock" locks "dev->tx_global_lock".
include/linux/netdevice.h:1570: missing_unlock: Returning without unlocking "dev->tx_global_lock".

Error: LOCK:
drivers/scsi/libiscsi.c:1317: lock: "_spin_lock" locks "host->host_lock".
drivers/scsi/libiscsi.c:1318: missing_unlock: Returning without unlocking "host->host_lock".

Error: LOCK:
drivers/scsi/libiscsi.c:1323: lock: "_spin_lock" locks "host->host_lock".
drivers/scsi/libiscsi.c:1324: missing_unlock: Returning without unlocking "host->host_lock".

Error: LOCK:
drivers/scsi/libiscsi.c:1336: lock: "_spin_lock" locks "host->host_lock".
drivers/scsi/libiscsi.c:1337: missing_unlock: Returning without unlocking "host->host_lock".

Error: LOCK:
ipc/sem.c:266: lock: "ipc_addid" locks "sma->sem_perm.lock".
ipc/util.c:272: lock: "_spin_lock" locks "new->lock".
ipc/sem.c:270: missing_unlock: Returning without unlocking "sma->sem_perm.lock".

Error: LOCK:
drivers/scsi/scsi_lib.c:1726: lock: "_spin_lock_irq" locks "q->queue_lock".
drivers/scsi/scsi_lib.c:1727: missing_unlock: Returning without unlocking "q->queue_lock".

Error: LOCK:
drivers/scsi/scsi_lib.c:1691: lock: "_spin_lock_irq" locks "q->queue_lock".
drivers/scsi/scsi_lib.c:1724: unlock: "_spin_unlock_irq" unlocks "q->queue_lock".
drivers/scsi/scsi_lib.c:1726: lock: "_spin_lock_irq" locks "q->queue_lock".
drivers/scsi/scsi_lib.c:1727: missing_unlock: Returning without unlocking "q->queue_lock".

Error: LOCK:
drivers/scsi/scsi_lib.c:1716: lock: "_spin_lock_irq" locks "q->queue_lock".
drivers/scsi/scsi_lib.c:1724: unlock: "_spin_unlock_irq" unlocks "q->queue_lock".
drivers/scsi/scsi_lib.c:1726: lock: "_spin_lock_irq" locks "q->queue_lock".
drivers/scsi/scsi_lib.c:1727: missing_unlock: Returning without unlocking "q->queue_lock".

Error: LOCK:
include/linux/netdevice.h:1555: lock: "_spin_lock" locks "dev->tx_global_lock".
include/linux/netdevice.h:1570: missing_unlock: Returning without unlocking "dev->tx_global_lock".

Error: LOCK:
net/core/dev.c:2403: lock: "netpoll_poll_lock" locks "n->poll_lock".
include/linux/netpoll.h:79: lock: "_spin_lock" locks "napi->poll_lock".
net/core/dev.c:2403: double_lock: "netpoll_poll_lock" locks "n->poll_lock" twice.
include/linux/netpoll.h:79: lock: "_spin_lock" locks "napi->poll_lock".

Error: LOCK:
ipc/shm.c:385: lock: "ipc_addid" locks "shp->shm_perm.lock".
ipc/util.c:272: lock: "_spin_lock" locks "new->lock".
ipc/shm.c:414: missing_unlock: Returning without unlocking "shp->shm_perm.lock".

Error: LOCK:
kernel/sched.c:9319: lock: "_spin_lock_irq" locks "({...})->lock".
kernel/sched.c:9319: double_lock: "_spin_lock_irq" locks "({...})->lock" twice.

Error: LOCK:
include/linux/netdevice.h:1555: lock: "_spin_lock" locks "dev->tx_global_lock".
include/linux/netdevice.h:1570: missing_unlock: Returning without unlocking "dev->tx_global_lock".

Error: LOCK:
drivers/char/generic_serial.c:519: lock: "_spin_lock_irqsave" locks "port->driver_lock".
drivers/char/generic_serial.c:563: unlock: "_spin_unlock_irqrestore" unlocks "port->driver_lock".
drivers/char/generic_serial.c:585: lock: "_spin_lock_irqsave" locks "port->driver_lock".
drivers/char/generic_serial.c:593: missing_unlock: Returning without unlocking "port->driver_lock".

Error: LOCK:
ipc/msg.c:204: lock: "ipc_addid" locks "msq->q_perm.lock".
ipc/util.c:272: lock: "_spin_lock" locks "new->lock".
ipc/msg.c:208: missing_unlock: Returning without unlocking "msq->q_perm.lock".

Error: MISSING_LOCK:
mm/swapfile.c:183: example_lock: Locking "swap_lock".
mm/swapfile.c:186: example_access: nr_swap_pages is being accessed with lock "swap_lock" held.
mm/swapfile.c:183: example_lock: Locking "swap_lock".
mm/swapfile.c:211: example_access: nr_swap_pages is being accessed with lock "swap_lock" held.
mm/swapfile.c:222: example_lock: Locking "swap_lock".
mm/swapfile.c:225: example_access: nr_swap_pages is being accessed with lock "swap_lock" held.
mm/swapfile.c:222: example_lock: Locking "swap_lock".
mm/swapfile.c:231: example_access: nr_swap_pages is being accessed with lock "swap_lock" held.
mm/swapfile.c:1253: example_lock: Locking "swap_lock".
mm/swapfile.c:1288: example_access: nr_swap_pages is being accessed with lock "swap_lock" held.
mm/swapfile.c:287: missing_lock: Accessing variable "nr_swap_pages" (nr_swap_pages) requires the swap_lock lock.

Error: MISSING_LOCK:
mm/swapfile.c:183: example_lock: Locking "swap_lock".
mm/swapfile.c:202: example_access: swap_list_t.next is being accessed with lock "swap_lock" held.
mm/swapfile.c:1253: example_lock: Locking "swap_lock".
mm/swapfile.c:1281: example_access: swap_list_t.next is being accessed with lock "swap_lock" held.
mm/swapfile.c:1299: example_lock: Locking "swap_lock".
mm/swapfile.c:1310: example_access: swap_list_t.next is being accessed with lock "swap_lock" held.
mm/swapfile.c:1692: example_lock: Locking "swap_lock".
mm/swapfile.c:1718: example_access: swap_list_t.next is being accessed with lock "swap_lock" held.
mm/swapfile.c:286: missing_lock: Accessing variable "swap_list.next" (swap_list_t.next) requires the swap_lock lock.

Error: MISSING_LOCK:
lib/rwsem-spinlock.c:199: example_lock: Locking "sem->wait_lock".
lib/rwsem-spinlock.c:203: example_access: rw_semaphore.activity is being accessed with lock "sem->wait_lock" held.
lib/rwsem-spinlock.c:247: example_lock: Locking "sem->wait_lock".
lib/rwsem-spinlock.c:251: example_access: rw_semaphore.activity is being accessed with lock "sem->wait_lock" held.
lib/rwsem-spinlock.c:282: example_lock: Locking "sem->wait_lock".
lib/rwsem-spinlock.c:284: example_access: rw_semaphore.activity is being accessed with lock "sem->wait_lock" held.
lib/rwsem-spinlock.c:177: example_lock: Locking "sem->wait_lock".
lib/rwsem-spinlock.c:181: example_access: rw_semaphore.activity is being accessed with lock "sem->wait_lock" held.
lib/rwsem-spinlock.c:267: example_lock: Locking "sem->wait_lock".
lib/rwsem-spinlock.c:269: example_access: rw_semaphore.activity is being accessed with lock "sem->wait_lock" held.
lib/rwsem-spinlock.c:33: missing_lock: Accessing variable "sem->activity" (rw_semaphore.activity) requires the rw_semaphore.wait_lock lock.

Error: MISSING_LOCK:
fs/namei.c:536: example_lock: Locking "fs->lock".
fs/namei.c:537: example_access: nameidata.path is being accessed with lock "fs->lock" held.
fs/namei.c:1045: example_lock: Locking "fs->lock".
fs/namei.c:1046: example_access: nameidata.path is being accessed with lock "fs->lock" held.
fs/namei.c:1050: example_lock: Locking "fs->lock".
fs/namei.c:1051: example_access: nameidata.path is being accessed with lock "fs->lock" held.
fs/namei.c:560: missing_lock: Accessing variable "nd->path" (nameidata.path) requires the fs_struct.lock lock.

Error: MISSING_LOCK:
fs/sysfs/dir.c:788: example_lock: Locking "sysfs_assoc_lock".
fs/sysfs/dir.c:789: example_access: kobject.sd is being accessed with lock "sysfs_assoc_lock" held.
fs/sysfs/dir.c:691: missing_lock: Accessing variable "kobj->sd" (kobject.sd) requires the sysfs_assoc_lock lock.

Error: MISSING_LOCK:
lib/percpu_counter.c:40: example_lock: Locking "fbc->lock".
lib/percpu_counter.c:41: example_access: percpu_counter.count is being accessed with lock "fbc->lock" held.
lib/percpu_counter.c:21: example_lock: Locking "fbc->lock".
lib/percpu_counter.c:26: example_access: percpu_counter.count is being accessed with lock "fbc->lock" held.
lib/percpu_counter.c:130: example_lock: Locking "fbc->lock".
lib/percpu_counter.c:132: example_access: percpu_counter.count is being accessed with lock "fbc->lock" held.
lib/percpu_counter.c:76: missing_lock: Accessing variable "fbc->count" (percpu_counter.count) requires the percpu_counter.lock lock.

Error: MISSING_LOCK:
mm/mempool.c:128: example_lock: Locking "pool->lock".
mm/mempool.c:130: example_access: mempool_s.min_nr is being accessed with lock "pool->lock" held.
mm/mempool.c:140: example_lock: Locking "pool->lock".
mm/mempool.c:151: example_access: mempool_s.min_nr is being accessed with lock "pool->lock" held.
mm/mempool.c:75: missing_lock: Accessing variable "pool->min_nr" (mempool_s.min_nr) requires the mempool_s.lock lock.

Error: MISSING_LOCK:
fs/ocfs2/dlmglue.c:1021: example_lock: Locking "lockres->l_lock".
fs/ocfs2/dlmglue.c:1024: example_access: ocfs2_lock_res.l_action is being accessed with lock "lockres->l_lock" held.
fs/ocfs2/dlmglue.c:1216: example_lock: Locking "lockres->l_lock".
fs/ocfs2/dlmglue.c:1256: example_access: ocfs2_lock_res.l_action is being accessed with lock "lockres->l_lock" held.
fs/ocfs2/dlmglue.c:1216: example_lock: Locking "lockres->l_lock".
fs/ocfs2/dlmglue.c:1259: example_access: ocfs2_lock_res.l_action is being accessed with lock "lockres->l_lock" held.
fs/ocfs2/dlmglue.c:1051: example_lock: Locking "lockres->l_lock".
fs/ocfs2/dlmglue.c:1058: example_access: ocfs2_lock_res.l_action is being accessed with lock "lockres->l_lock" held.
fs/ocfs2/dlmglue.c:1673: example_lock: Locking "lockres->l_lock".
fs/ocfs2/dlmglue.c:1676: example_access: ocfs2_lock_res.l_action is being accessed with lock "lockres->l_lock" held.
fs/ocfs2/dlmglue.c:455: missing_lock: Accessing variable "res->l_action" (ocfs2_lock_res.l_action) requires the ocfs2_lock_res.l_lock lock.

Error: MISSING_LOCK:
fs/ocfs2/alloc.c:6353: example_lock: Locking "OCFS2_I(inode)->ip_lock".
fs/ocfs2/alloc.c:6354: example_access: ocfs2_inode_info.ip_clusters is being accessed with lock "OCFS2_I(inode)->ip_lock" held.
fs/ocfs2/alloc.c:163: example_lock: Locking "OCFS2_I(inode)->ip_lock".
fs/ocfs2/alloc.c:164: example_access: ocfs2_inode_info.ip_clusters is being accessed with lock "OCFS2_I(inode)->ip_lock" held.
fs/ocfs2/dlmglue.c:1887: example_lock: Locking "oi->ip_lock".
fs/ocfs2/dlmglue.c:1888: example_access: ocfs2_inode_info.ip_clusters is being accessed with lock "oi->ip_lock" held.
fs/ocfs2/inode.c:1243: example_lock: Locking "OCFS2_I(inode)->ip_lock".
fs/ocfs2/inode.c:1245: example_access: ocfs2_inode_info.ip_clusters is being accessed with lock "OCFS2_I(inode)->ip_lock" held.
fs/ocfs2/resize.c:610: example_lock: Locking "OCFS2_I(main_bm_inode)->ip_lock".
fs/ocfs2/resize.c:611: example_access: ocfs2_inode_info.ip_clusters is being accessed with lock "OCFS2_I(main_bm_inode)->ip_lock" held.
fs/ocfs2/inode.c:255: missing_lock: Accessing variable "OCFS2_I(inode)->ip_clusters" (ocfs2_inode_info.ip_clusters) requires the ocfs2_inode_info.ip_lock lock.

Error: MISSING_LOCK:
fs/ocfs2/alloc.c:6750: example_lock: Locking "oi->ip_lock".
fs/ocfs2/alloc.c:6751: example_access: ocfs2_inode_info.ip_dyn_features is being accessed with lock "oi->ip_lock" held.
fs/ocfs2/alloc.c:6638: example_lock: Locking "oi->ip_lock".
fs/ocfs2/alloc.c:6639: example_access: ocfs2_inode_info.ip_dyn_features is being accessed with lock "oi->ip_lock" held.
fs/ocfs2/dir.c:1327: example_lock: Locking "oi->ip_lock".
fs/ocfs2/dir.c:1328: example_access: ocfs2_inode_info.ip_dyn_features is being accessed with lock "oi->ip_lock" held.
fs/ocfs2/dlmglue.c:1887: example_lock: Locking "oi->ip_lock".
fs/ocfs2/dlmglue.c:1892: example_access: ocfs2_inode_info.ip_dyn_features is being accessed with lock "oi->ip_lock" held.
fs/ocfs2/inode.c:1243: example_lock: Locking "OCFS2_I(inode)->ip_lock".
fs/ocfs2/inode.c:1247: example_access: ocfs2_inode_info.ip_dyn_features is being accessed with lock "OCFS2_I(inode)->ip_lock" held.
fs/ocfs2/inode.c:257: missing_lock: Accessing variable "OCFS2_I(inode)->ip_dyn_features" (ocfs2_inode_info.ip_dyn_features) requires the ocfs2_inode_info.ip_lock lock.

Error: MISSING_LOCK:
drivers/ata/libata-core.c:5940: example_lock: Locking "ap->lock".
drivers/ata/libata-core.c:5946: example_access: ata_port.pflags is being accessed with lock "ap->lock" held.
drivers/ata/libata-core.c:5940: example_lock: Locking "ap->lock".
drivers/ata/libata-core.c:5947: example_access: ata_port.pflags is being accessed with lock "ap->lock" held.
drivers/ata/libata-core.c:5212: example_lock: Locking "ap->lock".
drivers/ata/libata-core.c:5220: example_access: ata_port.pflags is being accessed with lock "ap->lock" held.
drivers/ata/libata-core.c:6057: example_lock: Locking "ap->lock".
drivers/ata/libata-core.c:6058: example_access: ata_port.pflags is being accessed with lock "ap->lock" held.
drivers/ata/libata-eh.c:1169: example_lock: Locking "ap->lock".
drivers/ata/libata-eh.c:1175: example_access: ata_port.pflags is being accessed with lock "ap->lock" held.
drivers/ata/libata-eh.c:796: missing_lock: Accessing variable "ap->pflags" (ata_port.pflags) requires the ata_port.lock lock.

Error: MISSING_LOCK:
fs/cifs/cifsencrypt.c:71: example_lock: Locking "GlobalMid_Lock".
fs/cifs/cifsencrypt.c:72: example_access: smb_hdr.Signature.Sequence.SequenceNumber is being accessed with lock "GlobalMid_Lock" held.
fs/cifs/cifsencrypt.c:138: example_lock: Locking "GlobalMid_Lock".
fs/cifs/cifsencrypt.c:139: example_access: smb_hdr.Signature.Sequence.SequenceNumber is being accessed with lock "GlobalMid_Lock" held.
fs/cifs/cifsencrypt.c:190: missing_lock: Accessing variable "cifs_pdu->Signature.Sequence.SequenceNumber" (smb_hdr.Signature.Sequence.SequenceNumber) requires the GlobalMid_Lock lock.

Error: MISSING_LOCK:
fs/cifs/connect.c:171: example_lock: Locking "GlobalMid_Lock".
fs/cifs/connect.c:181: example_access: mid_q_entry.midState is being accessed with lock "GlobalMid_Lock" held.
fs/cifs/connect.c:577: example_lock: Locking "GlobalMid_Lock".
fs/cifs/connect.c:620: example_access: mid_q_entry.midState is being accessed with lock "GlobalMid_Lock" held.
fs/cifs/transport.c:83: example_lock: Locking "GlobalMid_Lock".
fs/cifs/transport.c:84: example_access: mid_q_entry.midState is being accessed with lock "GlobalMid_Lock" held.
fs/cifs/transport.c:69: example_lock: Locking "GlobalMid_Lock".
fs/cifs/transport.c:72: example_access: mid_q_entry.midState is being accessed with lock "GlobalMid_Lock" held.
fs/cifs/transport.c:774: example_lock: Locking "GlobalMid_Lock".
fs/cifs/transport.c:786: example_access: mid_q_entry.midState is being accessed with lock "GlobalMid_Lock" held.
fs/cifs/transport.c:730: missing_lock: Accessing variable "midQ->midState" (mid_q_entry.midState) requires the GlobalMid_Lock lock.

Error: MISSING_LOCK:
drivers/scsi/qla2xxx/qla_attr.c:986: example_lock: Locking "host->host_lock".
drivers/scsi/qla2xxx/qla_attr.c:987: example_access: fc_port.rport is being accessed with lock "host->host_lock" held.
drivers/scsi/qla2xxx/qla_init.c:2260: missing_lock: Accessing variable "fcport->rport" (fc_port.rport) requires the Scsi_Host.host_lock lock.

Error: MISSING_LOCK:
fs/afs/dir.c:668: example_lock: Locking "dentry->d_lock".
fs/afs/dir.c:669: example_access: dentry.d_flags is being accessed with lock "dentry->d_lock" held.
fs/autofs4/root.c:129: example_lock: Locking "dentry->d_lock".
fs/autofs4/root.c:130: example_access: dentry.d_flags is being accessed with lock "dentry->d_lock" held.
fs/autofs4/root.c:144: example_lock: Locking "dentry->d_lock".
fs/autofs4/root.c:145: example_access: dentry.d_flags is being accessed with lock "dentry->d_lock" held.
fs/autofs4/root.c:152: example_lock: Locking "dentry->d_lock".
fs/autofs4/root.c:153: example_access: dentry.d_flags is being accessed with lock "dentry->d_lock" held.
fs/autofs4/root.c:163: example_lock: Locking "dentry->d_lock".
fs/autofs4/root.c:164: example_access: dentry.d_flags is being accessed with lock "dentry->d_lock" held.
fs/inotify.c:287: missing_lock: Accessing variable "entry->d_flags" (dentry.d_flags) requires the dentry.d_lock lock.

Error: MISSING_LOCK:
fs/afs/dir.c:668: example_lock: Locking "dentry->d_lock".
fs/afs/dir.c:669: example_access: dentry.d_flags is being accessed with lock "dentry->d_lock" held.
fs/autofs4/root.c:129: example_lock: Locking "dentry->d_lock".
fs/autofs4/root.c:130: example_access: dentry.d_flags is being accessed with lock "dentry->d_lock" held.
fs/autofs4/root.c:144: example_lock: Locking "dentry->d_lock".
fs/autofs4/root.c:145: example_access: dentry.d_flags is being accessed with lock "dentry->d_lock" held.
fs/autofs4/root.c:152: example_lock: Locking "dentry->d_lock".
fs/autofs4/root.c:153: example_access: dentry.d_flags is being accessed with lock "dentry->d_lock" held.
fs/autofs4/root.c:163: example_lock: Locking "dentry->d_lock".
fs/autofs4/root.c:164: example_access: dentry.d_flags is being accessed with lock "dentry->d_lock" held.
fs/inotify.c:289: missing_lock: Accessing variable "entry->d_flags" (dentry.d_flags) requires the dentry.d_lock lock.

Error: MISSING_LOCK:
fs/aio.c:281: example_lock: Locking "mm->ioctx_list_lock".
fs/aio.c:282: example_access: kioctx.next is being accessed with lock "mm->ioctx_list_lock" held.
fs/aio.c:382: missing_lock: Accessing variable "ctx->next" (kioctx.next) requires the mm_struct.ioctx_list_lock lock.

Error: MISSING_LOCK:
fs/ntfs/attrib.c:1712: example_lock: Locking "ni->size_lock".
fs/ntfs/attrib.c:1713: example_access: _ntfs_inode.allocated_size is being accessed with lock "ni->size_lock" held.
fs/ntfs/attrib.c:1813: example_lock: Locking "ni->size_lock".
fs/ntfs/attrib.c:1814: example_access: _ntfs_inode.allocated_size is being accessed with lock "ni->size_lock" held.
fs/ntfs/attrib.c:2055: example_lock: Locking "ni->size_lock".
fs/ntfs/attrib.c:2056: example_access: _ntfs_inode.allocated_size is being accessed with lock "ni->size_lock" held.
fs/ntfs/attrib.c:2337: example_lock: Locking "ni->size_lock".
fs/ntfs/attrib.c:2338: example_access: _ntfs_inode.allocated_size is being accessed with lock "ni->size_lock" held.
fs/ntfs/attrib.c:2391: example_lock: Locking "ni->size_lock".
fs/ntfs/attrib.c:2392: example_access: _ntfs_inode.allocated_size is being accessed with lock "ni->size_lock" held.
fs/ntfs/inode.c:390: missing_lock: Accessing variable "ni->allocated_size" (_ntfs_inode.allocated_size) requires the _ntfs_inode.size_lock lock.

Error: MISSING_LOCK:
fs/ntfs/attrib.c:1794: example_lock: Locking "ni->size_lock".
fs/ntfs/attrib.c:1795: example_access: _ntfs_inode.initialized_size is being accessed with lock "ni->size_lock" held.
fs/ntfs/file.c:181: example_lock: Locking "ni->size_lock".
fs/ntfs/file.c:183: example_access: _ntfs_inode.initialized_size is being accessed with lock "ni->size_lock" held.
fs/ntfs/file.c:248: example_lock: Locking "ni->size_lock".
fs/ntfs/file.c:249: example_access: _ntfs_inode.initialized_size is being accessed with lock "ni->size_lock" held.
fs/ntfs/file.c:248: example_lock: Locking "ni->size_lock".
fs/ntfs/file.c:251: example_access: _ntfs_inode.initialized_size is being accessed with lock "ni->size_lock" held.
fs/ntfs/file.c:323: example_lock: Locking "ni->size_lock".
fs/ntfs/file.c:324: example_access: _ntfs_inode.initialized_size is being accessed with lock "ni->size_lock" held.
fs/ntfs/inode.c:390: missing_lock: Accessing variable "ni->initialized_size" (_ntfs_inode.initialized_size) requires the _ntfs_inode.size_lock lock.

Error: MISSING_LOCK:
fs/cifs/connect.c:3647: example_lock: Locking "GlobalMid_Lock".
fs/cifs/connect.c:3649: example_access: TCP_Server_Info.tcpStatus is being accessed with lock "GlobalMid_Lock" held.
fs/cifs/connect.c:1411: example_lock: Locking "GlobalMid_Lock".
fs/cifs/connect.c:1412: example_access: TCP_Server_Info.tcpStatus is being accessed with lock "GlobalMid_Lock" held.
fs/cifs/connect.c:132: example_lock: Locking "GlobalMid_Lock".
fs/cifs/connect.c:139: example_access: TCP_Server_Info.tcpStatus is being accessed with lock "GlobalMid_Lock" held.
fs/cifs/connect.c:205: example_lock: Locking "GlobalMid_Lock".
fs/cifs/connect.c:207: example_access: TCP_Server_Info.tcpStatus is being accessed with lock "GlobalMid_Lock" held.
fs/cifs/connect.c:661: example_lock: Locking "GlobalMid_Lock".
fs/cifs/connect.c:662: example_access: TCP_Server_Info.tcpStatus is being accessed with lock "GlobalMid_Lock" held.
fs/cifs/transport.c:332: missing_lock: Accessing variable "server->tcpStatus" (TCP_Server_Info.tcpStatus) requires the GlobalMid_Lock lock.

Error: MISSING_LOCK:
drivers/scsi/lpfc/lpfc_els.c:1817: example_lock: Locking "shost->host_lock".
drivers/scsi/lpfc/lpfc_els.c:1818: example_access: lpfc_nodelist.nlp_flag is being accessed with lock "shost->host_lock" held.
drivers/scsi/lpfc/lpfc_els.c:1821: example_lock: Locking "shost->host_lock".
drivers/scsi/lpfc/lpfc_els.c:1822: example_access: lpfc_nodelist.nlp_flag is being accessed with lock "shost->host_lock" held.
drivers/scsi/lpfc/lpfc_els.c:2253: example_lock: Locking "shost->host_lock".
drivers/scsi/lpfc/lpfc_els.c:2254: example_access: lpfc_nodelist.nlp_flag is being accessed with lock "shost->host_lock" held.
drivers/scsi/lpfc/lpfc_els.c:2265: example_lock: Locking "shost->host_lock".
drivers/scsi/lpfc/lpfc_els.c:2266: example_access: lpfc_nodelist.nlp_flag is being accessed with lock "shost->host_lock" held.
drivers/scsi/lpfc/lpfc_els.c:3656: example_lock: Locking "shost->host_lock".
drivers/scsi/lpfc/lpfc_els.c:3657: example_access: lpfc_nodelist.nlp_flag is being accessed with lock "shost->host_lock" held.
drivers/scsi/lpfc/lpfc_els.c:2817: missing_lock: Accessing variable "ndlp->nlp_flag" (lpfc_nodelist.nlp_flag) requires the Scsi_Host.host_lock lock.

Error: MISSING_LOCK:
drivers/scsi/aic94xx/aic94xx_scb.c:530: example_lock: Locking "last_dev_task->task_state_lock".
drivers/scsi/aic94xx/aic94xx_scb.c:531: example_access: sas_task.task_state_flags is being accessed with lock "last_dev_task->task_state_lock" held.
drivers/scsi/aic94xx/aic94xx_task.c:597: example_lock: Locking "t->task_state_lock".
drivers/scsi/aic94xx/aic94xx_task.c:598: example_access: sas_task.task_state_flags is being accessed with lock "t->task_state_lock" held.
drivers/scsi/aic94xx/aic94xx_task.c:618: example_lock: Locking "t->task_state_lock".
drivers/scsi/aic94xx/aic94xx_task.c:619: example_access: sas_task.task_state_flags is being accessed with lock "t->task_state_lock" held.
drivers/scsi/aic94xx/aic94xx_task.c:341: example_lock: Locking "task->task_state_lock".
drivers/scsi/aic94xx/aic94xx_task.c:342: example_access: sas_task.task_state_flags is being accessed with lock "task->task_state_lock" held.
drivers/scsi/aic94xx/aic94xx_task.c:341: example_lock: Locking "task->task_state_lock".
drivers/scsi/aic94xx/aic94xx_task.c:343: example_access: sas_task.task_state_flags is being accessed with lock "task->task_state_lock" held.
drivers/scsi/libsas/sas_ata.c:478: missing_lock: Accessing variable "task->task_state_flags" (sas_task.task_state_flags) requires the sas_task.task_state_lock lock.

Error: MISSING_LOCK:
fs/cifs/connect.c:171: example_lock: Locking "GlobalMid_Lock".
fs/cifs/connect.c:181: example_access: mid_q_entry.midState is being accessed with lock "GlobalMid_Lock" held.
fs/cifs/connect.c:577: example_lock: Locking "GlobalMid_Lock".
fs/cifs/connect.c:620: example_access: mid_q_entry.midState is being accessed with lock "GlobalMid_Lock" held.
fs/cifs/transport.c:83: example_lock: Locking "GlobalMid_Lock".
fs/cifs/transport.c:84: example_access: mid_q_entry.midState is being accessed with lock "GlobalMid_Lock" held.
fs/cifs/transport.c:69: example_lock: Locking "GlobalMid_Lock".
fs/cifs/transport.c:72: example_access: mid_q_entry.midState is being accessed with lock "GlobalMid_Lock" held.
fs/cifs/transport.c:774: example_lock: Locking "GlobalMid_Lock".
fs/cifs/transport.c:786: example_access: mid_q_entry.midState is being accessed with lock "GlobalMid_Lock" held.
fs/cifs/transport.c:537: missing_lock: Accessing variable "midQ->midState" (mid_q_entry.midState) requires the GlobalMid_Lock lock.

Error: MISSING_LOCK:
kernel/sched_rt.c:337: example_lock: Locking "iter->rt_runtime_lock".
kernel/sched_rt.c:340: example_access: rt_rq.rt_runtime is being accessed with lock "iter->rt_runtime_lock" held.
kernel/sched_rt.c:337: example_lock: Locking "iter->rt_runtime_lock".
kernel/sched_rt.c:343: example_access: rt_rq.rt_runtime is being accessed with lock "iter->rt_runtime_lock" held.
kernel/sched_rt.c:306: example_lock: Locking "rt_rq->rt_runtime_lock".
kernel/sched_rt.c:363: example_access: rt_rq.rt_runtime is being accessed with lock "rt_rq->rt_runtime_lock" held.
kernel/sched_rt.c:392: example_lock: Locking "rt_rq->rt_runtime_lock".
kernel/sched_rt.c:393: example_access: rt_rq.rt_runtime is being accessed with lock "rt_rq->rt_runtime_lock" held.
kernel/sched_rt.c:255: example_lock: Locking "iter->rt_runtime_lock".
kernel/sched_rt.c:273: example_access: rt_rq.rt_runtime is being accessed with lock "iter->rt_runtime_lock" held.
kernel/sched.c:8071: missing_lock: Accessing variable "rt_rq->rt_runtime" (rt_rq.rt_runtime) requires the rt_rq.rt_runtime_lock lock.

Error: MISSING_LOCK:
drivers/scsi/lpfc/lpfc_hbadisc.c:1143: example_lock: Locking "phba->hbalock".
drivers/scsi/lpfc/lpfc_hbadisc.c:1144: example_access: lpfc_sli.sli_flag is being accessed with lock "phba->hbalock" held.
drivers/scsi/lpfc/lpfc_hbadisc.c:874: example_lock: Locking "phba->hbalock".
drivers/scsi/lpfc/lpfc_hbadisc.c:875: example_access: lpfc_sli.sli_flag is being accessed with lock "phba->hbalock" held.
drivers/scsi/lpfc/lpfc_hbadisc.c:898: example_lock: Locking "phba->hbalock".
drivers/scsi/lpfc/lpfc_hbadisc.c:899: example_access: lpfc_sli.sli_flag is being accessed with lock "phba->hbalock" held.
drivers/scsi/lpfc/lpfc_init.c:1719: example_lock: Locking "phba->hbalock".
drivers/scsi/lpfc/lpfc_init.c:1720: example_access: lpfc_sli.sli_flag is being accessed with lock "phba->hbalock" held.
drivers/scsi/lpfc/lpfc_init.c:1797: example_lock: Locking "phba->hbalock".
drivers/scsi/lpfc/lpfc_init.c:1798: example_access: lpfc_sli.sli_flag is being accessed with lock "phba->hbalock" held.
drivers/scsi/lpfc/lpfc_sli.c:2749: missing_lock: Accessing variable "psli->sli_flag" (lpfc_sli.sli_flag) requires the lpfc_hba.hbalock lock.

Error: MISSING_LOCK:
drivers/scsi/lpfc/lpfc_attr.c:2655: example_lock: Locking "shost->host_lock".
drivers/scsi/lpfc/lpfc_attr.c:2661: example_access: lpfc_nodelist.cmd_qdepth is being accessed with lock "shost->host_lock" held.
drivers/scsi/lpfc/lpfc_scsi.c:938: example_lock: Locking "sdev->host->host_lock".
drivers/scsi/lpfc/lpfc_scsi.c:942: example_access: lpfc_nodelist.cmd_qdepth is being accessed with lock "sdev->host->host_lock" held.
drivers/scsi/lpfc/lpfc_scsi.c:949: example_lock: Locking "sdev->host->host_lock".
drivers/scsi/lpfc/lpfc_scsi.c:950: example_access: lpfc_nodelist.cmd_qdepth is being accessed with lock "sdev->host->host_lock" held.
drivers/scsi/lpfc/lpfc_scsi.c:949: example_lock: Locking "sdev->host->host_lock".
drivers/scsi/lpfc/lpfc_scsi.c:953: example_access: lpfc_nodelist.cmd_qdepth is being accessed with lock "sdev->host->host_lock" held.
drivers/scsi/lpfc/lpfc_hbadisc.c:3131: missing_lock: Accessing variable "ndlp->cmd_qdepth" (lpfc_nodelist.cmd_qdepth) requires the Scsi_Host.host_lock lock.

Error: MISSING_LOCK:
drivers/scsi/lpfc/lpfc_els.c:1144: example_lock: Locking "phba->ndlp_lock".
drivers/scsi/lpfc/lpfc_els.c:1145: example_access: lpfc_nodelist.nlp_usg_map is being accessed with lock "phba->ndlp_lock" held.
drivers/scsi/lpfc/lpfc_hbadisc.c:3233: example_lock: Locking "phba->ndlp_lock".
drivers/scsi/lpfc/lpfc_hbadisc.c:3267: example_access: lpfc_nodelist.nlp_usg_map is being accessed with lock "phba->ndlp_lock" held.
drivers/scsi/lpfc/lpfc_hbadisc.c:3233: example_lock: Locking "phba->ndlp_lock".
drivers/scsi/lpfc/lpfc_hbadisc.c:3270: example_access: lpfc_nodelist.nlp_usg_map is being accessed with lock "phba->ndlp_lock" held.
drivers/scsi/lpfc/lpfc_hbadisc.c:1867: example_lock: Locking "phba->ndlp_lock".
drivers/scsi/lpfc/lpfc_hbadisc.c:1905: example_access: lpfc_nodelist.nlp_usg_map is being accessed with lock "phba->ndlp_lock" held.
drivers/scsi/lpfc/lpfc_hbadisc.c:3166: example_lock: Locking "phba->ndlp_lock".
drivers/scsi/lpfc/lpfc_hbadisc.c:3167: example_access: lpfc_nodelist.nlp_usg_map is being accessed with lock "phba->ndlp_lock" held.
drivers/scsi/lpfc/lpfc_hbadisc.c:3129: missing_lock: Accessing variable "ndlp->nlp_usg_map" (lpfc_nodelist.nlp_usg_map) requires the lpfc_hba.ndlp_lock lock.

Error: MISSING_LOCK:
fs/namei.c:536: example_lock: Locking "fs->lock".
fs/namei.c:537: example_access: nameidata.path is being accessed with lock "fs->lock" held.
fs/namei.c:1045: example_lock: Locking "fs->lock".
fs/namei.c:1046: example_access: nameidata.path is being accessed with lock "fs->lock" held.
fs/namei.c:1050: example_lock: Locking "fs->lock".
fs/namei.c:1051: example_access: nameidata.path is being accessed with lock "fs->lock" held.
fs/namei.c:1072: missing_lock: Accessing variable "nd->path" (nameidata.path) requires the fs_struct.lock lock.

Error: MISSING_LOCK:
kernel/sched_rt.c:337: example_lock: Locking "iter->rt_runtime_lock".
kernel/sched_rt.c:340: example_access: rt_rq.rt_runtime is being accessed with lock "iter->rt_runtime_lock" held.
kernel/sched_rt.c:337: example_lock: Locking "iter->rt_runtime_lock".
kernel/sched_rt.c:343: example_access: rt_rq.rt_runtime is being accessed with lock "iter->rt_runtime_lock" held.
kernel/sched_rt.c:306: example_lock: Locking "rt_rq->rt_runtime_lock".
kernel/sched_rt.c:363: example_access: rt_rq.rt_runtime is being accessed with lock "rt_rq->rt_runtime_lock" held.
kernel/sched_rt.c:392: example_lock: Locking "rt_rq->rt_runtime_lock".
kernel/sched_rt.c:393: example_access: rt_rq.rt_runtime is being accessed with lock "rt_rq->rt_runtime_lock" held.
kernel/sched_rt.c:255: example_lock: Locking "iter->rt_runtime_lock".
kernel/sched_rt.c:273: example_access: rt_rq.rt_runtime is being accessed with lock "iter->rt_runtime_lock" held.
kernel/sched.c:8120: missing_lock: Accessing variable "rt_rq->rt_runtime" (rt_rq.rt_runtime) requires the rt_rq.rt_runtime_lock lock.

Error: MISSING_LOCK:
mm/shmem.c:1475: example_lock: Locking "info->lock".
mm/shmem.c:1479: example_access: shmem_inode_info.flags is being accessed with lock "info->lock" held.
mm/shmem.c:1475: example_lock: Locking "info->lock".
mm/shmem.c:1484: example_access: shmem_inode_info.flags is being accessed with lock "info->lock" held.
mm/shmem.c:1223: example_lock: Locking "info->lock".
mm/shmem.c:1304: example_access: shmem_inode_info.flags is being accessed with lock "info->lock" held.
mm/shmem.c:1383: example_lock: Locking "info->lock".
mm/shmem.c:1411: example_access: shmem_inode_info.flags is being accessed with lock "info->lock" held.
mm/shmem.c:543: example_lock: Locking "info->lock".
mm/shmem.c:544: example_access: shmem_inode_info.flags is being accessed with lock "info->lock" held.
mm/shmem.c:2572: missing_lock: Accessing variable "SHMEM_I(inode)->flags" (shmem_inode_info.flags) requires the shmem_inode_info.lock lock.

Error: MISSING_LOCK:
fs/jfs/jfs_logmgr.c:829: example_lock: Locking "log->gclock".
fs/jfs/jfs_logmgr.c:845: example_access: tblock.flag is being accessed with lock "log->gclock" held.
fs/jfs/jfs_logmgr.c:829: example_lock: Locking "log->gclock".
fs/jfs/jfs_logmgr.c:849: example_access: tblock.flag is being accessed with lock "log->gclock" held.
fs/jfs/jfs_logmgr.c:829: example_lock: Locking "log->gclock".
fs/jfs/jfs_logmgr.c:867: example_access: tblock.flag is being accessed with lock "log->gclock" held.
fs/jfs/jfs_logmgr.c:586: example_lock: Locking "log->gclock".
fs/jfs/jfs_logmgr.c:609: example_access: tblock.flag is being accessed with lock "log->gclock" held.
fs/jfs/jfs_logmgr.c:525: example_lock: Locking "log->gclock".
fs/jfs/jfs_logmgr.c:528: example_access: tblock.flag is being accessed with lock "log->gclock" held.
fs/jfs/jfs_txnmgr.c:432: missing_lock: Accessing variable "tblk->flag" (tblock.flag) requires the jfs_log.gclock lock.

Error: MISSING_LOCK:
kernel/sched_cpupri.c:124: example_lock: Locking "vec->lock".
kernel/sched_cpupri.c:126: example_access: cpupri_vec.count is being accessed with lock "vec->lock" held.
kernel/sched_cpupri.c:137: example_lock: Locking "vec->lock".
kernel/sched_cpupri.c:140: example_access: cpupri_vec.count is being accessed with lock "vec->lock" held.
kernel/sched_cpupri.c:166: missing_lock: Accessing variable "vec->count" (cpupri_vec.count) requires the cpupri_vec.lock lock.

Error: MISSING_LOCK:
net/9p/client.c:153: example_lock: Locking "c->lock".
net/9p/client.c:166: example_access: p9_req_t.status is being accessed with lock "c->lock" held.
net/9p/client.c:572: example_lock: Locking "c->lock".
net/9p/client.c:574: example_access: p9_req_t.status is being accessed with lock "c->lock" held.
net/9p/client.c:337: example_lock: Locking "c->lock".
net/9p/client.c:342: example_access: p9_req_t.status is being accessed with lock "c->lock" held.
net/9p/client.c:349: example_lock: Locking "c->lock".
net/9p/client.c:351: example_access: p9_req_t.status is being accessed with lock "c->lock" held.
net/9p/trans_fd.c:192: example_lock: Locking "m->client->lock".
net/9p/trans_fd.c:202: example_access: p9_req_t.status is being accessed with lock "m->client->lock" held.
net/9p/client.c:314: missing_lock: Accessing variable "r->status" (p9_req_t.status) requires the p9_client.lock lock.

Error: MISSING_LOCK:
net/bluetooth/hci_event.c:1033: example_lock: Locking "hdev->lock".
net/bluetooth/hci_event.c:1038: example_access: hci_conn.link_mode is being accessed with lock "hdev->lock" held.
net/bluetooth/hci_event.c:1124: example_lock: Locking "hdev->lock".
net/bluetooth/hci_event.c:1129: example_access: hci_conn.link_mode is being accessed with lock "hdev->lock" held.
net/bluetooth/hci_event.c:100: example_lock: Locking "hdev->lock".
net/bluetooth/hci_event.c:105: example_access: hci_conn.link_mode is being accessed with lock "hdev->lock" held.
net/bluetooth/hci_event.c:100: example_lock: Locking "hdev->lock".
net/bluetooth/hci_event.c:107: example_access: hci_conn.link_mode is being accessed with lock "hdev->lock" held.
net/bluetooth/hci_event.c:561: example_lock: Locking "hdev->lock".
net/bluetooth/hci_event.c:581: example_access: hci_conn.link_mode is being accessed with lock "hdev->lock" held.
net/bluetooth/hci_conn.c:400: missing_lock: Accessing variable "conn->link_mode" (hci_conn.link_mode) requires the hci_dev.lock lock.

Error: MISSING_LOCK:
drivers/scsi/lpfc/lpfc_hbadisc.c:1143: example_lock: Locking "phba->hbalock".
drivers/scsi/lpfc/lpfc_hbadisc.c:1144: example_access: lpfc_sli.sli_flag is being accessed with lock "phba->hbalock" held.
drivers/scsi/lpfc/lpfc_hbadisc.c:874: example_lock: Locking "phba->hbalock".
drivers/scsi/lpfc/lpfc_hbadisc.c:875: example_access: lpfc_sli.sli_flag is being accessed with lock "phba->hbalock" held.
drivers/scsi/lpfc/lpfc_hbadisc.c:898: example_lock: Locking "phba->hbalock".
drivers/scsi/lpfc/lpfc_hbadisc.c:899: example_access: lpfc_sli.sli_flag is being accessed with lock "phba->hbalock" held.
drivers/scsi/lpfc/lpfc_init.c:1719: example_lock: Locking "phba->hbalock".
drivers/scsi/lpfc/lpfc_init.c:1720: example_access: lpfc_sli.sli_flag is being accessed with lock "phba->hbalock" held.
drivers/scsi/lpfc/lpfc_init.c:1797: example_lock: Locking "phba->hbalock".
drivers/scsi/lpfc/lpfc_init.c:1798: example_access: lpfc_sli.sli_flag is being accessed with lock "phba->hbalock" held.
drivers/scsi/lpfc/lpfc_sli.c:3245: missing_lock: Accessing variable "phba->sli.sli_flag" (lpfc_sli.sli_flag) requires the lpfc_hba.hbalock lock.

Error: MISSING_LOCK:
net/9p/client.c:153: example_lock: Locking "c->lock".
net/9p/client.c:166: example_access: p9_req_t.status is being accessed with lock "c->lock" held.
net/9p/client.c:572: example_lock: Locking "c->lock".
net/9p/client.c:574: example_access: p9_req_t.status is being accessed with lock "c->lock" held.
net/9p/client.c:337: example_lock: Locking "c->lock".
net/9p/client.c:342: example_access: p9_req_t.status is being accessed with lock "c->lock" held.
net/9p/client.c:349: example_lock: Locking "c->lock".
net/9p/client.c:351: example_access: p9_req_t.status is being accessed with lock "c->lock" held.
net/9p/trans_fd.c:192: example_lock: Locking "m->client->lock".
net/9p/trans_fd.c:202: example_access: p9_req_t.status is being accessed with lock "m->client->lock" held.
net/9p/client.c:208: missing_lock: Accessing variable "req->status" (p9_req_t.status) requires the p9_client.lock lock.

Error: MISSING_LOCK:
sound/core/seq/seq_timer.c:259: example_lock: Locking "tmr->lock".
sound/core/seq/seq_timer.c:260: example_access: snd_seq_timer.skew is being accessed with lock "tmr->lock" held.
sound/core/seq/seq_timer.c:110: missing_lock: Accessing variable "tmr->skew" (snd_seq_timer.skew) requires the snd_seq_timer.lock lock.

Error: MISSING_LOCK:
arch/x86/kernel/io_apic.c:2184: example_lock: Locking "desc->lock".
arch/x86/kernel/io_apic.c:2187: example_access: irq_desc.status is being accessed with lock "desc->lock" held.
kernel/irq/autoprobe.c:169: example_lock: Locking "desc->lock".
kernel/irq/autoprobe.c:178: example_access: irq_desc.status is being accessed with lock "desc->lock" held.
kernel/irq/autoprobe.c:71: example_lock: Locking "desc->lock".
kernel/irq/autoprobe.c:73: example_access: irq_desc.status is being accessed with lock "desc->lock" held.
kernel/irq/autoprobe.c:71: example_lock: Locking "desc->lock".
kernel/irq/autoprobe.c:75: example_access: irq_desc.status is being accessed with lock "desc->lock" held.
kernel/irq/autoprobe.c:89: example_lock: Locking "desc->lock".
kernel/irq/autoprobe.c:95: example_access: irq_desc.status is being accessed with lock "desc->lock" held.
arch/x86/kernel/io_apic.c:1226: missing_lock: Accessing variable "desc->status" (irq_desc.status) requires the irq_desc.lock lock.

Error: MISSING_LOCK:
arch/x86/kernel/io_apic.c:2184: example_lock: Locking "desc->lock".
arch/x86/kernel/io_apic.c:2187: example_access: irq_desc.status is being accessed with lock "desc->lock" held.
kernel/irq/autoprobe.c:169: example_lock: Locking "desc->lock".
kernel/irq/autoprobe.c:178: example_access: irq_desc.status is being accessed with lock "desc->lock" held.
kernel/irq/autoprobe.c:71: example_lock: Locking "desc->lock".
kernel/irq/autoprobe.c:73: example_access: irq_desc.status is being accessed with lock "desc->lock" held.
kernel/irq/autoprobe.c:71: example_lock: Locking "desc->lock".
kernel/irq/autoprobe.c:75: example_access: irq_desc.status is being accessed with lock "desc->lock" held.
kernel/irq/autoprobe.c:89: example_lock: Locking "desc->lock".
kernel/irq/autoprobe.c:95: example_access: irq_desc.status is being accessed with lock "desc->lock" held.
arch/x86/kernel/io_apic.c:1228: missing_lock: Accessing variable "desc->status" (irq_desc.status) requires the irq_desc.lock lock.

Error: MISSING_LOCK:
arch/x86/kernel/io_apic.c:2184: example_lock: Locking "desc->lock".
arch/x86/kernel/io_apic.c:2187: example_access: irq_desc.status is being accessed with lock "desc->lock" held.
kernel/irq/autoprobe.c:169: example_lock: Locking "desc->lock".
kernel/irq/autoprobe.c:178: example_access: irq_desc.status is being accessed with lock "desc->lock" held.
kernel/irq/autoprobe.c:71: example_lock: Locking "desc->lock".
kernel/irq/autoprobe.c:73: example_access: irq_desc.status is being accessed with lock "desc->lock" held.
kernel/irq/autoprobe.c:71: example_lock: Locking "desc->lock".
kernel/irq/autoprobe.c:75: example_access: irq_desc.status is being accessed with lock "desc->lock" held.
kernel/irq/autoprobe.c:89: example_lock: Locking "desc->lock".
kernel/irq/autoprobe.c:95: example_access: irq_desc.status is being accessed with lock "desc->lock" held.
arch/x86/kernel/io_apic.c:1232: missing_lock: Accessing variable "desc->status" (irq_desc.status) requires the irq_desc.lock lock.

Error: MISSING_LOCK:
net/ipv6/addrconf.c:3102: example_lock: Locking "ifp->lock".
net/ipv6/addrconf.c:3151: example_access: inet6_ifaddr.regen_count is being accessed with lock "ifp->lock" held.
net/ipv6/addrconf.c:3156: example_lock: Locking "ifpub->lock".
net/ipv6/addrconf.c:3157: example_access: inet6_ifaddr.regen_count is being accessed with lock "ifpub->lock" held.
net/ipv6/addrconf.c:855: missing_lock: Accessing variable "ifp->regen_count" (inet6_ifaddr.regen_count) requires the inet6_ifaddr.lock lock.

Error: MISSING_LOCK:
drivers/block/cciss.c:1487: example_lock: Locking "hba[h->ctlr]->lock".
drivers/block/cciss.c:1488: example_access: _drive_info_struct.busy_configuring is being accessed with lock "hba[h->ctlr]->lock" held.
drivers/block/cciss.c:1711: example_lock: Locking "hba[h->ctlr]->lock".
drivers/block/cciss.c:1712: example_access: _drive_info_struct.busy_configuring is being accessed with lock "hba[h->ctlr]->lock" held.
drivers/block/cciss.c:1592: missing_lock: Accessing variable "h->drv[drv_index].busy_configuring" (_drive_info_struct.busy_configuring) requires the ctlr_info.lock lock.

Error: MISSING_LOCK:
fs/ocfs2/dlm/dlmconvert.c:507: example_lock: Locking "res->spinlock".
fs/ocfs2/dlm/dlmconvert.c:512: example_access: dlm_lock_resource.state is being accessed with lock "res->spinlock" held.
fs/ocfs2/dlm/dlmconvert.c:507: example_lock: Locking "res->spinlock".
fs/ocfs2/dlm/dlmconvert.c:516: example_access: dlm_lock_resource.state is being accessed with lock "res->spinlock" held.
fs/ocfs2/dlm/dlmconvert.c:85: example_lock: Locking "res->spinlock".
fs/ocfs2/dlm/dlmconvert.c:89: example_access: dlm_lock_resource.state is being accessed with lock "res->spinlock" held.
fs/ocfs2/dlm/dlmconvert.c:85: example_lock: Locking "res->spinlock".
fs/ocfs2/dlm/dlmconvert.c:94: example_access: dlm_lock_resource.state is being accessed with lock "res->spinlock" held.
fs/ocfs2/dlm/dlmconvert.c:274: example_lock: Locking "res->spinlock".
fs/ocfs2/dlm/dlmconvert.c:295: example_access: dlm_lock_resource.state is being accessed with lock "res->spinlock" held.
fs/ocfs2/dlm/dlmmaster.c:605: missing_lock: Accessing variable "res->state" (dlm_lock_resource.state) requires the dlm_lock_resource.spinlock lock.

Error: MISSING_LOCK:
fs/ntfs/attrib.c:2337: example_lock: Locking "ni->size_lock".
fs/ntfs/attrib.c:2339: example_access: ATTR_RECORD.data.non_resident.allocated_size is being accessed with lock "ni->size_lock" held.
fs/ntfs/inode.c:2768: example_lock: Locking "ni->size_lock".
fs/ntfs/inode.c:2770: example_access: ATTR_RECORD.data.non_resident.allocated_size is being accessed with lock "ni->size_lock" held.
fs/ntfs/mft.c:1484: example_lock: Locking "mftbmp_ni->size_lock".
fs/ntfs/mft.c:1486: example_access: ATTR_RECORD.data.non_resident.allocated_size is being accessed with lock "mftbmp_ni->size_lock" held.
fs/ntfs/mft.c:1923: example_lock: Locking "mft_ni->size_lock".
fs/ntfs/mft.c:1925: example_access: ATTR_RECORD.data.non_resident.allocated_size is being accessed with lock "mft_ni->size_lock" held.
fs/ntfs/attrib.c:1690: missing_lock: Accessing variable "a->data.non_resident.allocated_size" (ATTR_RECORD.data.non_resident.allocated_size) requires the _ntfs_inode.size_lock lock.

Error: MISSING_LOCK:
fs/ntfs/file.c:1571: example_lock: Locking "ni->size_lock".
fs/ntfs/file.c:1574: example_access: ATTR_RECORD.data.non_resident.initialized_size is being accessed with lock "ni->size_lock" held.
fs/ntfs/inode.c:2646: example_lock: Locking "ni->size_lock".
fs/ntfs/inode.c:2649: example_access: ATTR_RECORD.data.non_resident.initialized_size is being accessed with lock "ni->size_lock" held.
fs/ntfs/mft.c:1614: example_lock: Locking "mftbmp_ni->size_lock".
fs/ntfs/mft.c:1623: example_access: ATTR_RECORD.data.non_resident.initialized_size is being accessed with lock "mftbmp_ni->size_lock" held.
fs/ntfs/mft.c:1669: example_lock: Locking "mftbmp_ni->size_lock".
fs/ntfs/mft.c:1671: example_access: ATTR_RECORD.data.non_resident.initialized_size is being accessed with lock "mftbmp_ni->size_lock" held.
fs/ntfs/mft.c:2482: example_lock: Locking "mft_ni->size_lock".
fs/ntfs/mft.c:2483: example_access: ATTR_RECORD.data.non_resident.initialized_size is being accessed with lock "mft_ni->size_lock" held.
fs/ntfs/attrib.c:1691: missing_lock: Accessing variable "a->data.non_resident.initialized_size" (ATTR_RECORD.data.non_resident.initialized_size) requires the _ntfs_inode.size_lock lock.

Error: MISSING_LOCK:
drivers/media/dvb/dvb-core/dvb_demux.c:422: example_lock: Locking "demux->lock".
drivers/media/dvb/dvb-core/dvb_demux.c:429: example_access: dvb_demux.tsbufp is being accessed with lock "demux->lock" held.
drivers/media/dvb/dvb-core/dvb_demux.c:422: example_lock: Locking "demux->lock".
drivers/media/dvb/dvb-core/dvb_demux.c:435: example_access: dvb_demux.tsbufp is being accessed with lock "demux->lock" held.
drivers/media/dvb/dvb-core/dvb_demux.c:422: example_lock: Locking "demux->lock".
drivers/media/dvb/dvb-core/dvb_demux.c:447: example_access: dvb_demux.tsbufp is being accessed with lock "demux->lock" held.
drivers/media/dvb/dvb-core/dvb_demux.c:466: example_lock: Locking "demux->lock".
drivers/media/dvb/dvb-core/dvb_demux.c:473: example_access: dvb_demux.tsbufp is being accessed with lock "demux->lock" held.
drivers/media/dvb/dvb-core/dvb_demux.c:466: example_lock: Locking "demux->lock".
drivers/media/dvb/dvb-core/dvb_demux.c:483: example_access: dvb_demux.tsbufp is being accessed with lock "demux->lock" held.
drivers/media/dvb/dvb-core/dvb_demux.c:1198: missing_lock: Accessing variable "dvbdemux->tsbufp" (dvb_demux.tsbufp) requires the dvb_demux.lock lock.

Error: MISSING_LOCK:
drivers/ide/ide-probe.c:1005: example_lock: Locking "ide_lock".
drivers/ide/ide-probe.c:1022: example_access: hwif_s.next is being accessed with lock "ide_lock" held.
drivers/ide/ide-probe.c:1095: example_lock: Locking "ide_lock".
drivers/ide/ide-probe.c:1096: example_access: hwif_s.next is being accessed with lock "ide_lock" held.
drivers/ide/ide-probe.c:1095: example_lock: Locking "ide_lock".
drivers/ide/ide-probe.c:1097: example_access: hwif_s.next is being accessed with lock "ide_lock" held.
drivers/ide/ide-probe.c:1107: missing_lock: Accessing variable "hwif->next" (hwif_s.next) requires the ide_lock lock.

Error: MISSING_LOCK:
fs/afs/dir.c:668: example_lock: Locking "dentry->d_lock".
fs/afs/dir.c:669: example_access: dentry.d_flags is being accessed with lock "dentry->d_lock" held.
fs/autofs4/root.c:129: example_lock: Locking "dentry->d_lock".
fs/autofs4/root.c:130: example_access: dentry.d_flags is being accessed with lock "dentry->d_lock" held.
fs/autofs4/root.c:144: example_lock: Locking "dentry->d_lock".
fs/autofs4/root.c:145: example_access: dentry.d_flags is being accessed with lock "dentry->d_lock" held.
fs/autofs4/root.c:152: example_lock: Locking "dentry->d_lock".
fs/autofs4/root.c:153: example_access: dentry.d_flags is being accessed with lock "dentry->d_lock" held.
fs/autofs4/root.c:163: example_lock: Locking "dentry->d_lock".
fs/autofs4/root.c:164: example_access: dentry.d_flags is being accessed with lock "dentry->d_lock" held.
fs/pipe.c:939: missing_lock: Accessing variable "dentry->d_flags" (dentry.d_flags) requires the dentry.d_lock lock.

Error: MISSING_LOCK:
drivers/scsi/lpfc/lpfc_els.c:1817: example_lock: Locking "shost->host_lock".
drivers/scsi/lpfc/lpfc_els.c:1818: example_access: lpfc_nodelist.nlp_flag is being accessed with lock "shost->host_lock" held.
drivers/scsi/lpfc/lpfc_els.c:1821: example_lock: Locking "shost->host_lock".
drivers/scsi/lpfc/lpfc_els.c:1822: example_access: lpfc_nodelist.nlp_flag is being accessed with lock "shost->host_lock" held.
drivers/scsi/lpfc/lpfc_els.c:2253: example_lock: Locking "shost->host_lock".
drivers/scsi/lpfc/lpfc_els.c:2254: example_access: lpfc_nodelist.nlp_flag is being accessed with lock "shost->host_lock" held.
drivers/scsi/lpfc/lpfc_els.c:2265: example_lock: Locking "shost->host_lock".
drivers/scsi/lpfc/lpfc_els.c:2266: example_access: lpfc_nodelist.nlp_flag is being accessed with lock "shost->host_lock" held.
drivers/scsi/lpfc/lpfc_els.c:3656: example_lock: Locking "shost->host_lock".
drivers/scsi/lpfc/lpfc_els.c:3657: example_access: lpfc_nodelist.nlp_flag is being accessed with lock "shost->host_lock" held.
drivers/scsi/lpfc/lpfc_hbadisc.c:1702: missing_lock: Accessing variable "ndlp->nlp_flag" (lpfc_nodelist.nlp_flag) requires the Scsi_Host.host_lock lock.

Error: MISSING_LOCK:
drivers/scsi/lpfc/lpfc_els.c:1817: example_lock: Locking "shost->host_lock".
drivers/scsi/lpfc/lpfc_els.c:1818: example_access: lpfc_nodelist.nlp_flag is being accessed with lock "shost->host_lock" held.
drivers/scsi/lpfc/lpfc_els.c:1821: example_lock: Locking "shost->host_lock".
drivers/scsi/lpfc/lpfc_els.c:1822: example_access: lpfc_nodelist.nlp_flag is being accessed with lock "shost->host_lock" held.
drivers/scsi/lpfc/lpfc_els.c:2253: example_lock: Locking "shost->host_lock".
drivers/scsi/lpfc/lpfc_els.c:2254: example_access: lpfc_nodelist.nlp_flag is being accessed with lock "shost->host_lock" held.
drivers/scsi/lpfc/lpfc_els.c:2265: example_lock: Locking "shost->host_lock".
drivers/scsi/lpfc/lpfc_els.c:2266: example_access: lpfc_nodelist.nlp_flag is being accessed with lock "shost->host_lock" held.
drivers/scsi/lpfc/lpfc_els.c:3656: example_lock: Locking "shost->host_lock".
drivers/scsi/lpfc/lpfc_els.c:3657: example_access: lpfc_nodelist.nlp_flag is being accessed with lock "shost->host_lock" held.
drivers/scsi/lpfc/lpfc_hbadisc.c:1706: missing_lock: Accessing variable "ndlp->nlp_flag" (lpfc_nodelist.nlp_flag) requires the Scsi_Host.host_lock lock.

Error: MISSING_LOCK:
drivers/scsi/lpfc/lpfc_els.c:1817: example_lock: Locking "shost->host_lock".
drivers/scsi/lpfc/lpfc_els.c:1818: example_access: lpfc_nodelist.nlp_flag is being accessed with lock "shost->host_lock" held.
drivers/scsi/lpfc/lpfc_els.c:1821: example_lock: Locking "shost->host_lock".
drivers/scsi/lpfc/lpfc_els.c:1822: example_access: lpfc_nodelist.nlp_flag is being accessed with lock "shost->host_lock" held.
drivers/scsi/lpfc/lpfc_els.c:2253: example_lock: Locking "shost->host_lock".
drivers/scsi/lpfc/lpfc_els.c:2254: example_access: lpfc_nodelist.nlp_flag is being accessed with lock "shost->host_lock" held.
drivers/scsi/lpfc/lpfc_els.c:2265: example_lock: Locking "shost->host_lock".
drivers/scsi/lpfc/lpfc_els.c:2266: example_access: lpfc_nodelist.nlp_flag is being accessed with lock "shost->host_lock" held.
drivers/scsi/lpfc/lpfc_els.c:3656: example_lock: Locking "shost->host_lock".
drivers/scsi/lpfc/lpfc_els.c:3657: example_access: lpfc_nodelist.nlp_flag is being accessed with lock "shost->host_lock" held.
drivers/scsi/lpfc/lpfc_hbadisc.c:1708: missing_lock: Accessing variable "ndlp->nlp_flag" (lpfc_nodelist.nlp_flag) requires the Scsi_Host.host_lock lock.

Error: MISSING_LOCK:
drivers/scsi/aic94xx/aic94xx_hwi.c:1067: example_lock: Locking "seq->tc_index_lock".
drivers/scsi/aic94xx/aic94xx_hwi.c:1068: example_access: asd_ascb.tc_index is being accessed with lock "seq->tc_index_lock" held.
drivers/scsi/aic94xx/aic94xx_hwi.h:296: missing_lock: Accessing variable "ascb->tc_index" (asd_ascb.tc_index) requires the asd_seq_data.tc_index_lock lock.

Error: MISSING_LOCK:
fs/ntfs/attrib.c:1712: example_lock: Locking "ni->size_lock".
fs/ntfs/attrib.c:1713: example_access: _ntfs_inode.allocated_size is being accessed with lock "ni->size_lock" held.
fs/ntfs/attrib.c:1813: example_lock: Locking "ni->size_lock".
fs/ntfs/attrib.c:1814: example_access: _ntfs_inode.allocated_size is being accessed with lock "ni->size_lock" held.
fs/ntfs/attrib.c:2055: example_lock: Locking "ni->size_lock".
fs/ntfs/attrib.c:2056: example_access: _ntfs_inode.allocated_size is being accessed with lock "ni->size_lock" held.
fs/ntfs/attrib.c:2337: example_lock: Locking "ni->size_lock".
fs/ntfs/attrib.c:2338: example_access: _ntfs_inode.allocated_size is being accessed with lock "ni->size_lock" held.
fs/ntfs/attrib.c:2391: example_lock: Locking "ni->size_lock".
fs/ntfs/attrib.c:2392: example_access: _ntfs_inode.allocated_size is being accessed with lock "ni->size_lock" held.
fs/ntfs/inode.c:1348: missing_lock: Accessing variable "ni->allocated_size" (_ntfs_inode.allocated_size) requires the _ntfs_inode.size_lock lock.

Error: MISSING_LOCK:
fs/ntfs/attrib.c:1712: example_lock: Locking "ni->size_lock".
fs/ntfs/attrib.c:1713: example_access: _ntfs_inode.allocated_size is being accessed with lock "ni->size_lock" held.
fs/ntfs/attrib.c:1813: example_lock: Locking "ni->size_lock".
fs/ntfs/attrib.c:1814: example_access: _ntfs_inode.allocated_size is being accessed with lock "ni->size_lock" held.
fs/ntfs/attrib.c:2055: example_lock: Locking "ni->size_lock".
fs/ntfs/attrib.c:2056: example_access: _ntfs_inode.allocated_size is being accessed with lock "ni->size_lock" held.
fs/ntfs/attrib.c:2337: example_lock: Locking "ni->size_lock".
fs/ntfs/attrib.c:2338: example_access: _ntfs_inode.allocated_size is being accessed with lock "ni->size_lock" held.
fs/ntfs/attrib.c:2391: example_lock: Locking "ni->size_lock".
fs/ntfs/attrib.c:2392: example_access: _ntfs_inode.allocated_size is being accessed with lock "ni->size_lock" held.
fs/ntfs/inode.c:1406: missing_lock: Accessing variable "ni->allocated_size" (_ntfs_inode.allocated_size) requires the _ntfs_inode.size_lock lock.

Error: MISSING_LOCK:
fs/ntfs/attrib.c:1794: example_lock: Locking "ni->size_lock".
fs/ntfs/attrib.c:1795: example_access: _ntfs_inode.initialized_size is being accessed with lock "ni->size_lock" held.
fs/ntfs/file.c:181: example_lock: Locking "ni->size_lock".
fs/ntfs/file.c:183: example_access: _ntfs_inode.initialized_size is being accessed with lock "ni->size_lock" held.
fs/ntfs/file.c:248: example_lock: Locking "ni->size_lock".
fs/ntfs/file.c:249: example_access: _ntfs_inode.initialized_size is being accessed with lock "ni->size_lock" held.
fs/ntfs/file.c:248: example_lock: Locking "ni->size_lock".
fs/ntfs/file.c:251: example_access: _ntfs_inode.initialized_size is being accessed with lock "ni->size_lock" held.
fs/ntfs/file.c:323: example_lock: Locking "ni->size_lock".
fs/ntfs/file.c:324: example_access: _ntfs_inode.initialized_size is being accessed with lock "ni->size_lock" held.
fs/ntfs/inode.c:1346: missing_lock: Accessing variable "ni->initialized_size" (_ntfs_inode.initialized_size) requires the _ntfs_inode.size_lock lock.

Error: MISSING_LOCK:
fs/ntfs/attrib.c:1794: example_lock: Locking "ni->size_lock".
fs/ntfs/attrib.c:1795: example_access: _ntfs_inode.initialized_size is being accessed with lock "ni->size_lock" held.
fs/ntfs/file.c:181: example_lock: Locking "ni->size_lock".
fs/ntfs/file.c:183: example_access: _ntfs_inode.initialized_size is being accessed with lock "ni->size_lock" held.
fs/ntfs/file.c:248: example_lock: Locking "ni->size_lock".
fs/ntfs/file.c:249: example_access: _ntfs_inode.initialized_size is being accessed with lock "ni->size_lock" held.
fs/ntfs/file.c:248: example_lock: Locking "ni->size_lock".
fs/ntfs/file.c:251: example_access: _ntfs_inode.initialized_size is being accessed with lock "ni->size_lock" held.
fs/ntfs/file.c:323: example_lock: Locking "ni->size_lock".
fs/ntfs/file.c:324: example_access: _ntfs_inode.initialized_size is being accessed with lock "ni->size_lock" held.
fs/ntfs/inode.c:1404: missing_lock: Accessing variable "ni->initialized_size" (_ntfs_inode.initialized_size) requires the _ntfs_inode.size_lock lock.

Error: MISSING_LOCK:
fs/ntfs/attrib.c:1712: example_lock: Locking "ni->size_lock".
fs/ntfs/attrib.c:1715: example_access: _ntfs_inode.itype.compressed.size is being accessed with lock "ni->size_lock" held.
fs/ntfs/attrib.c:2337: example_lock: Locking "ni->size_lock".
fs/ntfs/attrib.c:2351: example_access: _ntfs_inode.itype.compressed.size is being accessed with lock "ni->size_lock" held.
fs/ntfs/attrib.c:2391: example_lock: Locking "ni->size_lock".
fs/ntfs/attrib.c:2399: example_access: _ntfs_inode.itype.compressed.size is being accessed with lock "ni->size_lock" held.
fs/ntfs/file.c:1064: example_lock: Locking "ni->size_lock".
fs/ntfs/file.c:1065: example_access: _ntfs_inode.itype.compressed.size is being accessed with lock "ni->size_lock" held.
fs/ntfs/file.c:1157: example_lock: Locking "ni->size_lock".
fs/ntfs/file.c:1158: example_access: _ntfs_inode.itype.compressed.size is being accessed with lock "ni->size_lock" held.
fs/ntfs/inode.c:1395: missing_lock: Accessing variable "ni->itype.compressed.size" (_ntfs_inode.itype.compressed.size) requires the _ntfs_inode.size_lock lock.

Error: MISSING_LOCK:
net/core/pktgen.c:2424: example_lock: Locking "x->lock".
net/core/pktgen.c:2434: example_access: xfrm_lifetime_cur.bytes is being accessed with lock "x->lock" held.
net/ipv6/xfrm6_input.c:132: example_lock: Locking "x->lock".
net/ipv6/xfrm6_input.c:134: example_access: xfrm_lifetime_cur.bytes is being accessed with lock "x->lock" held.
net/xfrm/xfrm_input.c:194: example_lock: Locking "x->lock".
net/xfrm/xfrm_input.c:211: example_access: xfrm_lifetime_cur.bytes is being accessed with lock "x->lock" held.
net/xfrm/xfrm_output.c:81: missing_lock: Accessing variable "x->curlft.bytes" (xfrm_lifetime_cur.bytes) requires the xfrm_state.lock lock.

Error: MISSING_LOCK:
net/bluetooth/hci_event.c:1033: example_lock: Locking "hdev->lock".
net/bluetooth/hci_event.c:1038: example_access: hci_conn.link_mode is being accessed with lock "hdev->lock" held.
net/bluetooth/hci_event.c:1124: example_lock: Locking "hdev->lock".
net/bluetooth/hci_event.c:1129: example_access: hci_conn.link_mode is being accessed with lock "hdev->lock" held.
net/bluetooth/hci_event.c:100: example_lock: Locking "hdev->lock".
net/bluetooth/hci_event.c:105: example_access: hci_conn.link_mode is being accessed with lock "hdev->lock" held.
net/bluetooth/hci_event.c:100: example_lock: Locking "hdev->lock".
net/bluetooth/hci_event.c:107: example_access: hci_conn.link_mode is being accessed with lock "hdev->lock" held.
net/bluetooth/hci_event.c:561: example_lock: Locking "hdev->lock".
net/bluetooth/hci_event.c:581: example_access: hci_conn.link_mode is being accessed with lock "hdev->lock" held.
net/bluetooth/hci_conn.c:64: missing_lock: Accessing variable "conn->link_mode" (hci_conn.link_mode) requires the hci_dev.lock lock.

Error: MISSING_LOCK:
drivers/scsi/lpfc/lpfc_els.c:1817: example_lock: Locking "shost->host_lock".
drivers/scsi/lpfc/lpfc_els.c:1818: example_access: lpfc_nodelist.nlp_flag is being accessed with lock "shost->host_lock" held.
drivers/scsi/lpfc/lpfc_els.c:1821: example_lock: Locking "shost->host_lock".
drivers/scsi/lpfc/lpfc_els.c:1822: example_access: lpfc_nodelist.nlp_flag is being accessed with lock "shost->host_lock" held.
drivers/scsi/lpfc/lpfc_els.c:2253: example_lock: Locking "shost->host_lock".
drivers/scsi/lpfc/lpfc_els.c:2254: example_access: lpfc_nodelist.nlp_flag is being accessed with lock "shost->host_lock" held.
drivers/scsi/lpfc/lpfc_els.c:2265: example_lock: Locking "shost->host_lock".
drivers/scsi/lpfc/lpfc_els.c:2266: example_access: lpfc_nodelist.nlp_flag is being accessed with lock "shost->host_lock" held.
drivers/scsi/lpfc/lpfc_els.c:3656: example_lock: Locking "shost->host_lock".
drivers/scsi/lpfc/lpfc_els.c:3657: example_access: lpfc_nodelist.nlp_flag is being accessed with lock "shost->host_lock" held.
drivers/scsi/lpfc/lpfc_hbadisc.c:1803: missing_lock: Accessing variable "ndlp->nlp_flag" (lpfc_nodelist.nlp_flag) requires the Scsi_Host.host_lock lock.

Error: MISSING_LOCK:
drivers/isdn/i4l/isdn_net.h:133: example_lock: Locking "master_lp->netdev->queue_lock".
drivers/isdn/i4l/isdn_net.h:134: example_access: isdn_net_local_s.next is being accessed with lock "master_lp->netdev->queue_lock" held.
drivers/isdn/i4l/isdn_net.h:133: example_lock: Locking "master_lp->netdev->queue_lock".
drivers/isdn/i4l/isdn_net.h:142: example_access: isdn_net_local_s.next is being accessed with lock "master_lp->netdev->queue_lock" held.
drivers/isdn/i4l/isdn_net.h:107: example_lock: Locking "nd->queue_lock".
drivers/isdn/i4l/isdn_net.h:113: example_access: isdn_net_local_s.next is being accessed with lock "nd->queue_lock" held.
drivers/isdn/i4l/isdn_net.h:107: example_lock: Locking "nd->queue_lock".
drivers/isdn/i4l/isdn_net.h:115: example_access: isdn_net_local_s.next is being accessed with lock "nd->queue_lock" held.
drivers/isdn/i4l/isdn_ppp.c:1571: missing_lock: Accessing variable "lp->next" (isdn_net_local_s.next) requires the isdn_net_dev_s.queue_lock lock.

Error: MISSING_LOCK:
fs/xfs/quota/xfs_qm.c:1402: example_lock: Locking "mp->m_sb_lock".
fs/xfs/quota/xfs_qm.c:1418: example_access: xfs_sb.sb_qflags is being accessed with lock "mp->m_sb_lock" held.
fs/xfs/quota/xfs_qm.c:370: example_lock: Locking "mp->m_sb_lock".
fs/xfs/quota/xfs_qm.c:372: example_access: xfs_sb.sb_qflags is being accessed with lock "mp->m_sb_lock" held.
fs/xfs/quota/xfs_qm_syscalls.c:840: example_lock: Locking "mp->m_sb_lock".
fs/xfs/quota/xfs_qm_syscalls.c:842: example_access: xfs_sb.sb_qflags is being accessed with lock "mp->m_sb_lock" held.
fs/xfs/quota/xfs_qm_syscalls.c:862: example_lock: Locking "mp->m_sb_lock".
fs/xfs/quota/xfs_qm_syscalls.c:863: example_access: xfs_sb.sb_qflags is being accessed with lock "mp->m_sb_lock" held.
fs/xfs/quota/xfs_qm_syscalls.c:239: example_lock: Locking "mp->m_sb_lock".
fs/xfs/quota/xfs_qm_syscalls.c:240: example_access: xfs_sb.sb_qflags is being accessed with lock "mp->m_sb_lock" held.
fs/xfs/xfs_mount.c:400: missing_lock: Accessing variable "to->sb_qflags" (xfs_sb.sb_qflags) requires the xfs_mount.m_sb_lock lock.

Error: MISSING_LOCK:
drivers/isdn/gigaset/ev-layer.c:732: example_lock: Locking "cs->lock".
drivers/isdn/gigaset/ev-layer.c:733: example_access: at_state_t.seq_index is being accessed with lock "cs->lock" held.
drivers/isdn/gigaset/common.c:480: missing_lock: Accessing variable "at_state->seq_index" (at_state_t.seq_index) requires the cardstate.lock lock.

Error: MISSING_LOCK:
drivers/isdn/gigaset/common.c:772: example_lock: Locking "cs->lock".
drivers/isdn/gigaset/common.c:775: example_access: at_state_t.timer_active is being accessed with lock "cs->lock" held.
drivers/isdn/gigaset/ev-layer.c:1289: example_lock: Locking "cs->lock".
drivers/isdn/gigaset/ev-layer.c:1291: example_access: at_state_t.timer_active is being accessed with lock "cs->lock" held.
drivers/isdn/gigaset/ev-layer.c:1695: example_lock: Locking "cs->lock".
drivers/isdn/gigaset/ev-layer.c:1697: example_access: at_state_t.timer_active is being accessed with lock "cs->lock" held.
drivers/isdn/gigaset/ev-layer.c:1713: example_lock: Locking "cs->lock".
drivers/isdn/gigaset/ev-layer.c:1716: example_access: at_state_t.timer_active is being accessed with lock "cs->lock" held.
drivers/isdn/gigaset/ev-layer.c:1713: example_lock: Locking "cs->lock".
drivers/isdn/gigaset/ev-layer.c:1719: example_access: at_state_t.timer_active is being accessed with lock "cs->lock" held.
drivers/isdn/gigaset/common.c:478: missing_lock: Accessing variable "at_state->timer_active" (at_state_t.timer_active) requires the cardstate.lock lock.

Error: MISSING_LOCK:
drivers/isdn/gigaset/common.c:772: example_lock: Locking "cs->lock".
drivers/isdn/gigaset/common.c:776: example_access: at_state_t.timer_expires is being accessed with lock "cs->lock" held.
drivers/isdn/gigaset/ev-layer.c:1289: example_lock: Locking "cs->lock".
drivers/isdn/gigaset/ev-layer.c:1290: example_access: at_state_t.timer_expires is being accessed with lock "cs->lock" held.
drivers/isdn/gigaset/ev-layer.c:1695: example_lock: Locking "cs->lock".
drivers/isdn/gigaset/ev-layer.c:1696: example_access: at_state_t.timer_expires is being accessed with lock "cs->lock" held.
drivers/isdn/gigaset/ev-layer.c:1713: example_lock: Locking "cs->lock".
drivers/isdn/gigaset/ev-layer.c:1715: example_access: at_state_t.timer_expires is being accessed with lock "cs->lock" held.
drivers/isdn/gigaset/ev-layer.c:1713: example_lock: Locking "cs->lock".
drivers/isdn/gigaset/ev-layer.c:1718: example_access: at_state_t.timer_expires is being accessed with lock "cs->lock" held.
drivers/isdn/gigaset/common.c:477: missing_lock: Accessing variable "at_state->timer_expires" (at_state_t.timer_expires) requires the cardstate.lock lock.

Error: MISSING_LOCK:
arch/x86/kernel/io_apic.c:2184: example_lock: Locking "desc->lock".
arch/x86/kernel/io_apic.c:2187: example_access: irq_desc.status is being accessed with lock "desc->lock" held.
kernel/irq/autoprobe.c:169: example_lock: Locking "desc->lock".
kernel/irq/autoprobe.c:178: example_access: irq_desc.status is being accessed with lock "desc->lock" held.
kernel/irq/autoprobe.c:71: example_lock: Locking "desc->lock".
kernel/irq/autoprobe.c:73: example_access: irq_desc.status is being accessed with lock "desc->lock" held.
kernel/irq/autoprobe.c:71: example_lock: Locking "desc->lock".
kernel/irq/autoprobe.c:75: example_access: irq_desc.status is being accessed with lock "desc->lock" held.
kernel/irq/autoprobe.c:89: example_lock: Locking "desc->lock".
kernel/irq/autoprobe.c:95: example_access: irq_desc.status is being accessed with lock "desc->lock" held.
arch/x86/kernel/io_apic.c:2488: missing_lock: Accessing variable "desc->status" (irq_desc.status) requires the irq_desc.lock lock.

Error: MISSING_LOCK:
drivers/net/wireless/libertas/main.c:863: example_lock: Locking "priv->driver_lock".
drivers/net/wireless/libertas/main.c:872: example_access: lbs_private.tx_pending_len is being accessed with lock "priv->driver_lock" held.
drivers/net/wireless/libertas/tx.c:75: example_lock: Locking "priv->driver_lock".
drivers/net/wireless/libertas/tx.c:104: example_access: lbs_private.tx_pending_len is being accessed with lock "priv->driver_lock" held.
drivers/net/wireless/libertas/tx.c:144: example_lock: Locking "priv->driver_lock".
drivers/net/wireless/libertas/tx.c:145: example_access: lbs_private.tx_pending_len is being accessed with lock "priv->driver_lock" held.
drivers/net/wireless/libertas/cmdresp.c:53: missing_lock: Accessing variable "priv->tx_pending_len" (lbs_private.tx_pending_len) requires the lbs_private.driver_lock lock.

Error: MISSING_LOCK:
fs/ocfs2/alloc.c:6353: example_lock: Locking "OCFS2_I(inode)->ip_lock".
fs/ocfs2/alloc.c:6354: example_access: ocfs2_inode_info.ip_clusters is being accessed with lock "OCFS2_I(inode)->ip_lock" held.
fs/ocfs2/alloc.c:163: example_lock: Locking "OCFS2_I(inode)->ip_lock".
fs/ocfs2/alloc.c:164: example_access: ocfs2_inode_info.ip_clusters is being accessed with lock "OCFS2_I(inode)->ip_lock" held.
fs/ocfs2/dlmglue.c:1887: example_lock: Locking "oi->ip_lock".
fs/ocfs2/dlmglue.c:1888: example_access: ocfs2_inode_info.ip_clusters is being accessed with lock "oi->ip_lock" held.
fs/ocfs2/inode.c:1243: example_lock: Locking "OCFS2_I(inode)->ip_lock".
fs/ocfs2/inode.c:1245: example_access: ocfs2_inode_info.ip_clusters is being accessed with lock "OCFS2_I(inode)->ip_lock" held.
fs/ocfs2/resize.c:610: example_lock: Locking "OCFS2_I(main_bm_inode)->ip_lock".
fs/ocfs2/resize.c:611: example_access: ocfs2_inode_info.ip_clusters is being accessed with lock "OCFS2_I(main_bm_inode)->ip_lock" held.
fs/ocfs2/file.c:1282: missing_lock: Accessing variable "OCFS2_I(inode)->ip_clusters" (ocfs2_inode_info.ip_clusters) requires the ocfs2_inode_info.ip_lock lock.

Error: MISSING_LOCK:
fs/ocfs2/inode.c:1205: example_lock: Locking "OCFS2_I(inode)->ip_lock".
fs/ocfs2/inode.c:1206: example_access: ocfs2_dinode.i_clusters is being accessed with lock "OCFS2_I(inode)->ip_lock" held.
fs/ocfs2/file.c:1283: missing_lock: Accessing variable "di->i_clusters" (ocfs2_dinode.i_clusters) requires the ocfs2_inode_info.ip_lock lock.

Error: MISSING_LOCK:
drivers/net/mlx4/alloc.c:47: example_lock: Locking "bitmap->lock".
drivers/net/mlx4/alloc.c:58: example_access: mlx4_bitmap.last is being accessed with lock "bitmap->lock" held.
drivers/net/mlx4/alloc.c:47: example_lock: Locking "bitmap->lock".
drivers/net/mlx4/alloc.c:60: example_access: mlx4_bitmap.last is being accessed with lock "bitmap->lock" held.
drivers/net/mlx4/alloc.c:145: example_lock: Locking "bitmap->lock".
drivers/net/mlx4/alloc.c:148: example_access: mlx4_bitmap.last is being accessed with lock "bitmap->lock" held.
drivers/net/mlx4/alloc.c:111: example_lock: Locking "bitmap->lock".
drivers/net/mlx4/alloc.c:126: example_access: mlx4_bitmap.last is being accessed with lock "bitmap->lock" held.
drivers/net/mlx4/alloc.c:111: example_lock: Locking "bitmap->lock".
drivers/net/mlx4/alloc.c:128: example_access: mlx4_bitmap.last is being accessed with lock "bitmap->lock" held.
drivers/net/mlx4/alloc.c:163: missing_lock: Accessing variable "bitmap->last" (mlx4_bitmap.last) requires the mlx4_bitmap.lock lock.

Error: MISSING_LOCK:
fs/jbd/transaction.c:115: example_lock: Locking "journal->j_state_lock".
fs/jbd/transaction.c:221: example_access: transaction_s.t_outstanding_credits is being accessed with lock "journal->j_state_lock" held.
fs/jbd/transaction.c:1417: example_lock: Locking "journal->j_state_lock".
fs/jbd/transaction.c:1419: example_access: transaction_s.t_outstanding_credits is being accessed with lock "journal->j_state_lock" held.
fs/jbd/transaction.c:404: example_lock: Locking "journal->j_state_lock".
fs/jbd/transaction.c:406: example_access: transaction_s.t_outstanding_credits is being accessed with lock "journal->j_state_lock" held.
fs/jbd/transaction.c:333: example_lock: Locking "journal->j_state_lock".
fs/jbd/transaction.c:358: example_access: transaction_s.t_outstanding_credits is being accessed with lock "journal->j_state_lock" held.
fs/jbd2/transaction.c:119: example_lock: Locking "journal->j_state_lock".
fs/jbd2/transaction.c:231: example_access: transaction_s.t_outstanding_credits is being accessed with lock "journal->j_state_lock" held.
fs/jbd2/commit.c:576: missing_lock: Accessing variable "commit_transaction->t_outstanding_credits" (transaction_s.t_outstanding_credits) requires the journal_s.j_state_lock lock.

Error: MISSING_LOCK:
fs/jbd/transaction.c:163: example_lock: Locking "transaction->t_handle_lock".
fs/jbd/transaction.c:221: example_access: transaction_s.t_outstanding_credits is being accessed with lock "transaction->t_handle_lock" held.
fs/jbd/transaction.c:1418: example_lock: Locking "transaction->t_handle_lock".
fs/jbd/transaction.c:1419: example_access: transaction_s.t_outstanding_credits is being accessed with lock "transaction->t_handle_lock" held.
fs/jbd/transaction.c:405: example_lock: Locking "transaction->t_handle_lock".
fs/jbd/transaction.c:406: example_access: transaction_s.t_outstanding_credits is being accessed with lock "transaction->t_handle_lock" held.
fs/jbd/transaction.c:342: example_lock: Locking "transaction->t_handle_lock".
fs/jbd/transaction.c:358: example_access: transaction_s.t_outstanding_credits is being accessed with lock "transaction->t_handle_lock" held.
fs/jbd2/transaction.c:167: example_lock: Locking "transaction->t_handle_lock".
fs/jbd2/transaction.c:231: example_access: transaction_s.t_outstanding_credits is being accessed with lock "transaction->t_handle_lock" held.
fs/jbd2/commit.c:576: missing_lock: Accessing variable "commit_transaction->t_outstanding_credits" (transaction_s.t_outstanding_credits) requires the transaction_s.t_handle_lock lock.

Error: MISSING_LOCK:
fs/ntfs/attrib.c:1712: example_lock: Locking "ni->size_lock".
fs/ntfs/attrib.c:1713: example_access: _ntfs_inode.allocated_size is being accessed with lock "ni->size_lock" held.
fs/ntfs/attrib.c:1813: example_lock: Locking "ni->size_lock".
fs/ntfs/attrib.c:1814: example_access: _ntfs_inode.allocated_size is being accessed with lock "ni->size_lock" held.
fs/ntfs/attrib.c:2055: example_lock: Locking "ni->size_lock".
fs/ntfs/attrib.c:2056: example_access: _ntfs_inode.allocated_size is being accessed with lock "ni->size_lock" held.
fs/ntfs/attrib.c:2337: example_lock: Locking "ni->size_lock".
fs/ntfs/attrib.c:2338: example_access: _ntfs_inode.allocated_size is being accessed with lock "ni->size_lock" held.
fs/ntfs/attrib.c:2391: example_lock: Locking "ni->size_lock".
fs/ntfs/attrib.c:2392: example_access: _ntfs_inode.allocated_size is being accessed with lock "ni->size_lock" held.
fs/ntfs/inode.c:901: missing_lock: Accessing variable "ni->allocated_size" (_ntfs_inode.allocated_size) requires the _ntfs_inode.size_lock lock.

Error: MISSING_LOCK:
fs/ntfs/attrib.c:1712: example_lock: Locking "ni->size_lock".
fs/ntfs/attrib.c:1713: example_access: _ntfs_inode.allocated_size is being accessed with lock "ni->size_lock" held.
fs/ntfs/attrib.c:1813: example_lock: Locking "ni->size_lock".
fs/ntfs/attrib.c:1814: example_access: _ntfs_inode.allocated_size is being accessed with lock "ni->size_lock" held.
fs/ntfs/attrib.c:2055: example_lock: Locking "ni->size_lock".
fs/ntfs/attrib.c:2056: example_access: _ntfs_inode.allocated_size is being accessed with lock "ni->size_lock" held.
fs/ntfs/attrib.c:2337: example_lock: Locking "ni->size_lock".
fs/ntfs/attrib.c:2338: example_access: _ntfs_inode.allocated_size is being accessed with lock "ni->size_lock" held.
fs/ntfs/attrib.c:2391: example_lock: Locking "ni->size_lock".
fs/ntfs/attrib.c:2392: example_access: _ntfs_inode.allocated_size is being accessed with lock "ni->size_lock" held.
fs/ntfs/inode.c:1019: missing_lock: Accessing variable "ni->allocated_size" (_ntfs_inode.allocated_size) requires the _ntfs_inode.size_lock lock.

Error: MISSING_LOCK:
fs/ntfs/attrib.c:1712: example_lock: Locking "ni->size_lock".
fs/ntfs/attrib.c:1713: example_access: _ntfs_inode.allocated_size is being accessed with lock "ni->size_lock" held.
fs/ntfs/attrib.c:1813: example_lock: Locking "ni->size_lock".
fs/ntfs/attrib.c:1814: example_access: _ntfs_inode.allocated_size is being accessed with lock "ni->size_lock" held.
fs/ntfs/attrib.c:2055: example_lock: Locking "ni->size_lock".
fs/ntfs/attrib.c:2056: example_access: _ntfs_inode.allocated_size is being accessed with lock "ni->size_lock" held.
fs/ntfs/attrib.c:2337: example_lock: Locking "ni->size_lock".
fs/ntfs/attrib.c:2338: example_access: _ntfs_inode.allocated_size is being accessed with lock "ni->size_lock" held.
fs/ntfs/attrib.c:2391: example_lock: Locking "ni->size_lock".
fs/ntfs/attrib.c:2392: example_access: _ntfs_inode.allocated_size is being accessed with lock "ni->size_lock" held.
fs/ntfs/inode.c:1131: missing_lock: Accessing variable "ni->allocated_size" (_ntfs_inode.allocated_size) requires the _ntfs_inode.size_lock lock.

Error: MISSING_LOCK:
fs/ntfs/attrib.c:1712: example_lock: Locking "ni->size_lock".
fs/ntfs/attrib.c:1713: example_access: _ntfs_inode.allocated_size is being accessed with lock "ni->size_lock" held.
fs/ntfs/attrib.c:1813: example_lock: Locking "ni->size_lock".
fs/ntfs/attrib.c:1814: example_access: _ntfs_inode.allocated_size is being accessed with lock "ni->size_lock" held.
fs/ntfs/attrib.c:2055: example_lock: Locking "ni->size_lock".
fs/ntfs/attrib.c:2056: example_access: _ntfs_inode.allocated_size is being accessed with lock "ni->size_lock" held.
fs/ntfs/attrib.c:2337: example_lock: Locking "ni->size_lock".
fs/ntfs/attrib.c:2338: example_access: _ntfs_inode.allocated_size is being accessed with lock "ni->size_lock" held.
fs/ntfs/attrib.c:2391: example_lock: Locking "ni->size_lock".
fs/ntfs/attrib.c:2392: example_access: _ntfs_inode.allocated_size is being accessed with lock "ni->size_lock" held.
fs/ntfs/inode.c:1136: missing_lock: Accessing variable "ni->allocated_size" (_ntfs_inode.allocated_size) requires the _ntfs_inode.size_lock lock.

Error: MISSING_LOCK:
fs/ntfs/attrib.c:1794: example_lock: Locking "ni->size_lock".
fs/ntfs/attrib.c:1795: example_access: _ntfs_inode.initialized_size is being accessed with lock "ni->size_lock" held.
fs/ntfs/file.c:181: example_lock: Locking "ni->size_lock".
fs/ntfs/file.c:183: example_access: _ntfs_inode.initialized_size is being accessed with lock "ni->size_lock" held.
fs/ntfs/file.c:248: example_lock: Locking "ni->size_lock".
fs/ntfs/file.c:249: example_access: _ntfs_inode.initialized_size is being accessed with lock "ni->size_lock" held.
fs/ntfs/file.c:248: example_lock: Locking "ni->size_lock".
fs/ntfs/file.c:251: example_access: _ntfs_inode.initialized_size is being accessed with lock "ni->size_lock" held.
fs/ntfs/file.c:323: example_lock: Locking "ni->size_lock".
fs/ntfs/file.c:324: example_access: _ntfs_inode.initialized_size is being accessed with lock "ni->size_lock" held.
fs/ntfs/inode.c:901: missing_lock: Accessing variable "ni->initialized_size" (_ntfs_inode.initialized_size) requires the _ntfs_inode.size_lock lock.

Error: MISSING_LOCK:
fs/ntfs/attrib.c:1794: example_lock: Locking "ni->size_lock".
fs/ntfs/attrib.c:1795: example_access: _ntfs_inode.initialized_size is being accessed with lock "ni->size_lock" held.
fs/ntfs/file.c:181: example_lock: Locking "ni->size_lock".
fs/ntfs/file.c:183: example_access: _ntfs_inode.initialized_size is being accessed with lock "ni->size_lock" held.
fs/ntfs/file.c:248: example_lock: Locking "ni->size_lock".
fs/ntfs/file.c:249: example_access: _ntfs_inode.initialized_size is being accessed with lock "ni->size_lock" held.
fs/ntfs/file.c:248: example_lock: Locking "ni->size_lock".
fs/ntfs/file.c:251: example_access: _ntfs_inode.initialized_size is being accessed with lock "ni->size_lock" held.
fs/ntfs/file.c:323: example_lock: Locking "ni->size_lock".
fs/ntfs/file.c:324: example_access: _ntfs_inode.initialized_size is being accessed with lock "ni->size_lock" held.
fs/ntfs/inode.c:1019: missing_lock: Accessing variable "ni->initialized_size" (_ntfs_inode.initialized_size) requires the _ntfs_inode.size_lock lock.

Error: MISSING_LOCK:
fs/ntfs/attrib.c:1794: example_lock: Locking "ni->size_lock".
fs/ntfs/attrib.c:1795: example_access: _ntfs_inode.initialized_size is being accessed with lock "ni->size_lock" held.
fs/ntfs/file.c:181: example_lock: Locking "ni->size_lock".
fs/ntfs/file.c:183: example_access: _ntfs_inode.initialized_size is being accessed with lock "ni->size_lock" held.
fs/ntfs/file.c:248: example_lock: Locking "ni->size_lock".
fs/ntfs/file.c:249: example_access: _ntfs_inode.initialized_size is being accessed with lock "ni->size_lock" held.
fs/ntfs/file.c:248: example_lock: Locking "ni->size_lock".
fs/ntfs/file.c:251: example_access: _ntfs_inode.initialized_size is being accessed with lock "ni->size_lock" held.
fs/ntfs/file.c:323: example_lock: Locking "ni->size_lock".
fs/ntfs/file.c:324: example_access: _ntfs_inode.initialized_size is being accessed with lock "ni->size_lock" held.
fs/ntfs/inode.c:1129: missing_lock: Accessing variable "ni->initialized_size" (_ntfs_inode.initialized_size) requires the _ntfs_inode.size_lock lock.

Error: MISSING_LOCK:
fs/ntfs/attrib.c:1794: example_lock: Locking "ni->size_lock".
fs/ntfs/attrib.c:1795: example_access: _ntfs_inode.initialized_size is being accessed with lock "ni->size_lock" held.
fs/ntfs/file.c:181: example_lock: Locking "ni->size_lock".
fs/ntfs/file.c:183: example_access: _ntfs_inode.initialized_size is being accessed with lock "ni->size_lock" held.
fs/ntfs/file.c:248: example_lock: Locking "ni->size_lock".
fs/ntfs/file.c:249: example_access: _ntfs_inode.initialized_size is being accessed with lock "ni->size_lock" held.
fs/ntfs/file.c:248: example_lock: Locking "ni->size_lock".
fs/ntfs/file.c:251: example_access: _ntfs_inode.initialized_size is being accessed with lock "ni->size_lock" held.
fs/ntfs/file.c:323: example_lock: Locking "ni->size_lock".
fs/ntfs/file.c:324: example_access: _ntfs_inode.initialized_size is being accessed with lock "ni->size_lock" held.
fs/ntfs/inode.c:1134: missing_lock: Accessing variable "ni->initialized_size" (_ntfs_inode.initialized_size) requires the _ntfs_inode.size_lock lock.

Error: MISSING_LOCK:
fs/ntfs/attrib.c:1712: example_lock: Locking "ni->size_lock".
fs/ntfs/attrib.c:1715: example_access: _ntfs_inode.itype.compressed.size is being accessed with lock "ni->size_lock" held.
fs/ntfs/attrib.c:2337: example_lock: Locking "ni->size_lock".
fs/ntfs/attrib.c:2351: example_access: _ntfs_inode.itype.compressed.size is being accessed with lock "ni->size_lock" held.
fs/ntfs/attrib.c:2391: example_lock: Locking "ni->size_lock".
fs/ntfs/attrib.c:2399: example_access: _ntfs_inode.itype.compressed.size is being accessed with lock "ni->size_lock" held.
fs/ntfs/file.c:1064: example_lock: Locking "ni->size_lock".
fs/ntfs/file.c:1065: example_access: _ntfs_inode.itype.compressed.size is being accessed with lock "ni->size_lock" held.
fs/ntfs/file.c:1157: example_lock: Locking "ni->size_lock".
fs/ntfs/file.c:1158: example_access: _ntfs_inode.itype.compressed.size is being accessed with lock "ni->size_lock" held.
fs/ntfs/inode.c:1117: missing_lock: Accessing variable "ni->itype.compressed.size" (_ntfs_inode.itype.compressed.size) requires the _ntfs_inode.size_lock lock.

Error: MISSING_LOCK:
fs/ntfs/attrib.c:1712: example_lock: Locking "ni->size_lock".
fs/ntfs/attrib.c:1713: example_access: _ntfs_inode.allocated_size is being accessed with lock "ni->size_lock" held.
fs/ntfs/attrib.c:1813: example_lock: Locking "ni->size_lock".
fs/ntfs/attrib.c:1814: example_access: _ntfs_inode.allocated_size is being accessed with lock "ni->size_lock" held.
fs/ntfs/attrib.c:2055: example_lock: Locking "ni->size_lock".
fs/ntfs/attrib.c:2056: example_access: _ntfs_inode.allocated_size is being accessed with lock "ni->size_lock" held.
fs/ntfs/attrib.c:2337: example_lock: Locking "ni->size_lock".
fs/ntfs/attrib.c:2338: example_access: _ntfs_inode.allocated_size is being accessed with lock "ni->size_lock" held.
fs/ntfs/attrib.c:2391: example_lock: Locking "ni->size_lock".
fs/ntfs/attrib.c:2392: example_access: _ntfs_inode.allocated_size is being accessed with lock "ni->size_lock" held.
fs/ntfs/inode.c:1607: missing_lock: Accessing variable "ni->allocated_size" (_ntfs_inode.allocated_size) requires the _ntfs_inode.size_lock lock.

Error: MISSING_LOCK:
fs/ntfs/attrib.c:1794: example_lock: Locking "ni->size_lock".
fs/ntfs/attrib.c:1795: example_access: _ntfs_inode.initialized_size is being accessed with lock "ni->size_lock" held.
fs/ntfs/file.c:181: example_lock: Locking "ni->size_lock".
fs/ntfs/file.c:183: example_access: _ntfs_inode.initialized_size is being accessed with lock "ni->size_lock" held.
fs/ntfs/file.c:248: example_lock: Locking "ni->size_lock".
fs/ntfs/file.c:249: example_access: _ntfs_inode.initialized_size is being accessed with lock "ni->size_lock" held.
fs/ntfs/file.c:248: example_lock: Locking "ni->size_lock".
fs/ntfs/file.c:251: example_access: _ntfs_inode.initialized_size is being accessed with lock "ni->size_lock" held.
fs/ntfs/file.c:323: example_lock: Locking "ni->size_lock".
fs/ntfs/file.c:324: example_access: _ntfs_inode.initialized_size is being accessed with lock "ni->size_lock" held.
fs/ntfs/inode.c:1607: missing_lock: Accessing variable "ni->initialized_size" (_ntfs_inode.initialized_size) requires the _ntfs_inode.size_lock lock.

Error: MISSING_LOCK:
fs/jbd/transaction.c:115: example_lock: Locking "journal->j_state_lock".
fs/jbd/transaction.c:221: example_access: transaction_s.t_outstanding_credits is being accessed with lock "journal->j_state_lock" held.
fs/jbd/transaction.c:1417: example_lock: Locking "journal->j_state_lock".
fs/jbd/transaction.c:1419: example_access: transaction_s.t_outstanding_credits is being accessed with lock "journal->j_state_lock" held.
fs/jbd/transaction.c:404: example_lock: Locking "journal->j_state_lock".
fs/jbd/transaction.c:406: example_access: transaction_s.t_outstanding_credits is being accessed with lock "journal->j_state_lock" held.
fs/jbd/transaction.c:333: example_lock: Locking "journal->j_state_lock".
fs/jbd/transaction.c:358: example_access: transaction_s.t_outstanding_credits is being accessed with lock "journal->j_state_lock" held.
fs/jbd2/transaction.c:119: example_lock: Locking "journal->j_state_lock".
fs/jbd2/transaction.c:231: example_access: transaction_s.t_outstanding_credits is being accessed with lock "journal->j_state_lock" held.
fs/jbd/commit.c:592: missing_lock: Accessing variable "commit_transaction->t_outstanding_credits" (transaction_s.t_outstanding_credits) requires the journal_s.j_state_lock lock.

Error: MISSING_LOCK:
fs/jbd/transaction.c:163: example_lock: Locking "transaction->t_handle_lock".
fs/jbd/transaction.c:221: example_access: transaction_s.t_outstanding_credits is being accessed with lock "transaction->t_handle_lock" held.
fs/jbd/transaction.c:1418: example_lock: Locking "transaction->t_handle_lock".
fs/jbd/transaction.c:1419: example_access: transaction_s.t_outstanding_credits is being accessed with lock "transaction->t_handle_lock" held.
fs/jbd/transaction.c:405: example_lock: Locking "transaction->t_handle_lock".
fs/jbd/transaction.c:406: example_access: transaction_s.t_outstanding_credits is being accessed with lock "transaction->t_handle_lock" held.
fs/jbd/transaction.c:342: example_lock: Locking "transaction->t_handle_lock".
fs/jbd/transaction.c:358: example_access: transaction_s.t_outstanding_credits is being accessed with lock "transaction->t_handle_lock" held.
fs/jbd2/transaction.c:167: example_lock: Locking "transaction->t_handle_lock".
fs/jbd2/transaction.c:231: example_access: transaction_s.t_outstanding_credits is being accessed with lock "transaction->t_handle_lock" held.
fs/jbd/commit.c:592: missing_lock: Accessing variable "commit_transaction->t_outstanding_credits" (transaction_s.t_outstanding_credits) requires the transaction_s.t_handle_lock lock.

Error: MISSING_LOCK:
fs/ubifs/journal.c:651: example_lock: Locking "ui->ui_lock".
fs/ubifs/journal.c:652: example_access: ubifs_inode.synced_i_size is being accessed with lock "ui->ui_lock" held.
fs/ubifs/journal.c:1048: example_lock: Locking "new_ui->ui_lock".
fs/ubifs/journal.c:1049: example_access: ubifs_inode.synced_i_size is being accessed with lock "new_ui->ui_lock" held.
fs/ubifs/journal.c:1231: example_lock: Locking "ui->ui_lock".
fs/ubifs/journal.c:1232: example_access: ubifs_inode.synced_i_size is being accessed with lock "ui->ui_lock" held.
fs/ubifs/journal.c:1428: example_lock: Locking "host_ui->ui_lock".
fs/ubifs/journal.c:1429: example_access: ubifs_inode.synced_i_size is being accessed with lock "host_ui->ui_lock" held.
fs/ubifs/journal.c:809: example_lock: Locking "ui->ui_lock".
fs/ubifs/journal.c:810: example_access: ubifs_inode.synced_i_size is being accessed with lock "ui->ui_lock" held.
fs/ubifs/super.c:149: missing_lock: Accessing variable "ui->synced_i_size" (ubifs_inode.synced_i_size) requires the ubifs_inode.ui_lock lock.

Error: MISSING_LOCK:
drivers/block/ub.c:1847: example_lock: Locking "sc->lock".
drivers/block/ub.c:1848: example_access: ub_dev.tagcnt is being accessed with lock "sc->lock" held.
drivers/block/ub.c:1905: example_lock: Locking "sc->lock".
drivers/block/ub.c:1906: example_access: ub_dev.tagcnt is being accessed with lock "sc->lock" held.
drivers/block/ub.c:1462: missing_lock: Accessing variable "sc->tagcnt" (ub_dev.tagcnt) requires the ub_dev.lock lock.

Error: MISSING_LOCK:
drivers/block/ub.c:1847: example_lock: Locking "sc->lock".
drivers/block/ub.c:1848: example_access: ub_scsi_cmd.tag is being accessed with lock "sc->lock" held.
drivers/block/ub.c:1905: example_lock: Locking "sc->lock".
drivers/block/ub.c:1906: example_access: ub_scsi_cmd.tag is being accessed with lock "sc->lock" held.
drivers/block/ub.c:1462: missing_lock: Accessing variable "scmd->tag" (ub_scsi_cmd.tag) requires the ub_dev.lock lock.

Error: MISSING_LOCK:
drivers/usb/wusbcore/wa-xfer.c:1471: example_lock: Locking "xfer->lock".
drivers/usb/wusbcore/wa-xfer.c:1478: example_access: wa_seg.result is being accessed with lock "xfer->lock" held.
drivers/usb/wusbcore/wa-xfer.c:1492: example_lock: Locking "xfer->lock".
drivers/usb/wusbcore/wa-xfer.c:1506: example_access: wa_seg.result is being accessed with lock "xfer->lock" held.
drivers/usb/wusbcore/wa-xfer.c:629: example_lock: Locking "xfer->lock".
drivers/usb/wusbcore/wa-xfer.c:644: example_access: wa_seg.result is being accessed with lock "xfer->lock" held.
drivers/usb/wusbcore/wa-xfer.c:540: example_lock: Locking "xfer->lock".
drivers/usb/wusbcore/wa-xfer.c:547: example_access: wa_seg.result is being accessed with lock "xfer->lock" held.
drivers/usb/wusbcore/wa-xfer.c:554: example_lock: Locking "xfer->lock".
drivers/usb/wusbcore/wa-xfer.c:569: example_access: wa_seg.result is being accessed with lock "xfer->lock" held.
drivers/usb/wusbcore/wa-xfer.c:827: missing_lock: Accessing variable "seg->result" (wa_seg.result) requires the wa_xfer.lock lock.

Error: MISSING_LOCK:
sound/pci/rme9652/hdsp.c:1417: example_lock: Locking "hmidi->lock".
sound/pci/rme9652/hdsp.c:1418: example_access: hdsp_midi.output is being accessed with lock "hmidi->lock" held.
sound/pci/rme9652/hdsp.c:1389: example_lock: Locking "hmidi->lock".
sound/pci/rme9652/hdsp.c:1390: example_access: hdsp_midi.output is being accessed with lock "hmidi->lock" held.
sound/pci/rme9652/hdsp.c:1445: missing_lock: Accessing variable "hdsp->midi[id].output" (hdsp_midi.output) requires the hdsp_midi.lock lock.

Error: MISSING_LOCK:
sound/synth/emux/soundfont.c:318: example_lock: Locking "sflist->lock".
sound/synth/emux/soundfont.c:319: example_access: snd_sf_list.currsf is being accessed with lock "sflist->lock" held.
sound/synth/emux/soundfont.c:255: example_lock: Locking "sflist->lock".
sound/synth/emux/soundfont.c:257: example_access: snd_sf_list.currsf is being accessed with lock "sflist->lock" held.
sound/synth/emux/soundfont.c:1344: missing_lock: Accessing variable "sflist->currsf" (snd_sf_list.currsf) requires the snd_sf_list.lock lock.

Error: MISSING_LOCK:
sound/synth/emux/soundfont.c:318: example_lock: Locking "sflist->lock".
sound/synth/emux/soundfont.c:320: example_access: snd_sf_list.open_client is being accessed with lock "sflist->lock" held.
sound/synth/emux/soundfont.c:255: example_lock: Locking "sflist->lock".
sound/synth/emux/soundfont.c:256: example_access: snd_sf_list.open_client is being accessed with lock "sflist->lock" held.
sound/synth/emux/soundfont.c:1345: missing_lock: Accessing variable "sflist->open_client" (snd_sf_list.open_client) requires the snd_sf_list.lock lock.

Error: MISSING_LOCK:
drivers/net/wireless/iwlwifi/iwl3945-base.c:3527: example_lock: Locking "q->lock".
drivers/net/wireless/iwlwifi/iwl3945-base.c:3557: example_access: iwl3945_rx_queue.need_update is being accessed with lock "q->lock" held.
drivers/net/wireless/iwlwifi/iwl3945-base.c:3617: example_lock: Locking "rxq->lock".
drivers/net/wireless/iwlwifi/iwl3945-base.c:3618: example_access: iwl3945_rx_queue.need_update is being accessed with lock "rxq->lock" held.
drivers/net/wireless/iwlwifi/iwl3945-base.c:3750: missing_lock: Accessing variable "rxq->need_update" (iwl3945_rx_queue.need_update) requires the iwl3945_rx_queue.lock lock.

Error: MISSING_LOCK:
drivers/mtd/ubi/vmt.c:536: example_lock: Locking "ubi->volumes_lock".
drivers/mtd/ubi/vmt.c:545: example_access: ubi_device.rsvd_pebs is being accessed with lock "ubi->volumes_lock" held.
drivers/mtd/ubi/vmt.c:566: example_lock: Locking "ubi->volumes_lock".
drivers/mtd/ubi/vmt.c:567: example_access: ubi_device.rsvd_pebs is being accessed with lock "ubi->volumes_lock" held.
drivers/mtd/ubi/vmt.c:566: example_lock: Locking "ubi->volumes_lock".
drivers/mtd/ubi/vmt.c:573: example_access: ubi_device.rsvd_pebs is being accessed with lock "ubi->volumes_lock" held.
drivers/mtd/ubi/vmt.c:598: example_lock: Locking "ubi->volumes_lock".
drivers/mtd/ubi/vmt.c:599: example_access: ubi_device.rsvd_pebs is being accessed with lock "ubi->volumes_lock" held.
drivers/mtd/ubi/vmt.c:456: example_lock: Locking "ubi->volumes_lock".
drivers/mtd/ubi/vmt.c:457: example_access: ubi_device.rsvd_pebs is being accessed with lock "ubi->volumes_lock" held.
drivers/mtd/ubi/vtbl.c:666: missing_lock: Accessing variable "ubi->rsvd_pebs" (ubi_device.rsvd_pebs) requires the ubi_device.volumes_lock lock.

Error: MISSING_LOCK:
drivers/scsi/aacraid/commsup.c:497: example_lock: Locking "q->lock".
drivers/scsi/aacraid/commsup.c:498: example_access: aac_queue.numpending is being accessed with lock "q->lock" held.
drivers/scsi/aacraid/dpcsup.c:62: example_lock: Locking "q->lock".
drivers/scsi/aacraid/dpcsup.c:86: example_access: aac_queue.numpending is being accessed with lock "q->lock" held.
drivers/scsi/aacraid/rx.c:416: example_lock: Locking "q->lock".
drivers/scsi/aacraid/rx.c:417: example_access: aac_queue.numpending is being accessed with lock "q->lock" held.
drivers/scsi/aacraid/rx.c:426: example_lock: Locking "q->lock".
drivers/scsi/aacraid/rx.c:427: example_access: aac_queue.numpending is being accessed with lock "q->lock" held.
drivers/scsi/aacraid/rx.c:388: example_lock: Locking "q->lock".
drivers/scsi/aacraid/rx.c:391: example_access: aac_queue.numpending is being accessed with lock "q->lock" held.
drivers/scsi/aacraid/comminit.c:139: missing_lock: Accessing variable "q->numpending" (aac_queue.numpending) requires the aac_queue.lock lock.

Error: MISSING_LOCK:
fs/ubifs/io.c:367: example_lock: Locking "wbuf->lock".
fs/ubifs/io.c:369: example_access: ubifs_wbuf.avail is being accessed with lock "wbuf->lock" held.
fs/ubifs/io.c:409: example_lock: Locking "wbuf->lock".
fs/ubifs/io.c:412: example_access: ubifs_wbuf.avail is being accessed with lock "wbuf->lock" held.
fs/ubifs/io.c:538: example_lock: Locking "wbuf->lock".
fs/ubifs/io.c:540: example_access: ubifs_wbuf.avail is being accessed with lock "wbuf->lock" held.
fs/ubifs/io.c:545: example_lock: Locking "wbuf->lock".
fs/ubifs/io.c:546: example_access: ubifs_wbuf.avail is being accessed with lock "wbuf->lock" held.
fs/ubifs/io.c:591: example_lock: Locking "wbuf->lock".
fs/ubifs/io.c:602: example_access: ubifs_wbuf.avail is being accessed with lock "wbuf->lock" held.
fs/ubifs/io.c:837: missing_lock: Accessing variable "wbuf->avail" (ubifs_wbuf.avail) requires the ubifs_wbuf.lock lock.

Error: MISSING_LOCK:
fs/ubifs/io.c:409: example_lock: Locking "wbuf->lock".
fs/ubifs/io.c:410: example_access: ubifs_wbuf.lnum is being accessed with lock "wbuf->lock" held.
fs/ubifs/io.c:836: missing_lock: Accessing variable "wbuf->lnum" (ubifs_wbuf.lnum) requires the ubifs_wbuf.lock lock.

Error: MISSING_LOCK:
fs/ubifs/io.c:367: example_lock: Locking "wbuf->lock".
fs/ubifs/io.c:371: example_access: ubifs_wbuf.next_ino is being accessed with lock "wbuf->lock" held.
fs/ubifs/io.c:538: example_lock: Locking "wbuf->lock".
fs/ubifs/io.c:542: example_access: ubifs_wbuf.next_ino is being accessed with lock "wbuf->lock" held.
fs/ubifs/io.c:591: example_lock: Locking "wbuf->lock".
fs/ubifs/io.c:603: example_access: ubifs_wbuf.next_ino is being accessed with lock "wbuf->lock" held.
fs/ubifs/io.c:866: example_lock: Locking "wbuf->lock".
fs/ubifs/io.c:868: example_access: ubifs_wbuf.next_ino is being accessed with lock "wbuf->lock" held.
fs/ubifs/io.c:848: missing_lock: Accessing variable "wbuf->next_ino" (ubifs_wbuf.next_ino) requires the ubifs_wbuf.lock lock.

Error: MISSING_LOCK:
fs/ubifs/io.c:367: example_lock: Locking "wbuf->lock".
fs/ubifs/io.c:368: example_access: ubifs_wbuf.offs is being accessed with lock "wbuf->lock" held.
fs/ubifs/io.c:409: example_lock: Locking "wbuf->lock".
fs/ubifs/io.c:411: example_access: ubifs_wbuf.offs is being accessed with lock "wbuf->lock" held.
fs/ubifs/io.c:538: example_lock: Locking "wbuf->lock".
fs/ubifs/io.c:539: example_access: ubifs_wbuf.offs is being accessed with lock "wbuf->lock" held.
fs/ubifs/io.c:591: example_lock: Locking "wbuf->lock".
fs/ubifs/io.c:600: example_access: ubifs_wbuf.offs is being accessed with lock "wbuf->lock" held.
fs/ubifs/io.c:836: missing_lock: Accessing variable "wbuf->offs" (ubifs_wbuf.offs) requires the ubifs_wbuf.lock lock.

Error: MISSING_LOCK:
fs/ubifs/io.c:367: example_lock: Locking "wbuf->lock".
fs/ubifs/io.c:370: example_access: ubifs_wbuf.used is being accessed with lock "wbuf->lock" held.
fs/ubifs/io.c:409: example_lock: Locking "wbuf->lock".
fs/ubifs/io.c:413: example_access: ubifs_wbuf.used is being accessed with lock "wbuf->lock" held.
fs/ubifs/io.c:538: example_lock: Locking "wbuf->lock".
fs/ubifs/io.c:541: example_access: ubifs_wbuf.used is being accessed with lock "wbuf->lock" held.
fs/ubifs/io.c:545: example_lock: Locking "wbuf->lock".
fs/ubifs/io.c:547: example_access: ubifs_wbuf.used is being accessed with lock "wbuf->lock" held.
fs/ubifs/io.c:591: example_lock: Locking "wbuf->lock".
fs/ubifs/io.c:601: example_access: ubifs_wbuf.used is being accessed with lock "wbuf->lock" held.
fs/ubifs/io.c:835: missing_lock: Accessing variable "wbuf->used" (ubifs_wbuf.used) requires the ubifs_wbuf.lock lock.

Error: MISSING_LOCK:
drivers/isdn/gigaset/common.c:249: example_lock: Locking "cs->lock".
drivers/isdn/gigaset/common.c:251: example_access: bc_state.use_count is being accessed with lock "cs->lock" held.
drivers/isdn/gigaset/common.c:197: example_lock: Locking "bcs->cs->lock".
drivers/isdn/gigaset/common.c:203: example_access: bc_state.use_count is being accessed with lock "bcs->cs->lock" held.
drivers/isdn/gigaset/common.c:237: example_lock: Locking "cs->lock".
drivers/isdn/gigaset/common.c:239: example_access: bc_state.use_count is being accessed with lock "cs->lock" held.
drivers/isdn/gigaset/common.c:179: example_lock: Locking "bcs->cs->lock".
drivers/isdn/gigaset/common.c:186: example_access: bc_state.use_count is being accessed with lock "bcs->cs->lock" held.
drivers/isdn/gigaset/common.c:215: example_lock: Locking "cs->lock".
drivers/isdn/gigaset/common.c:223: example_access: bc_state.use_count is being accessed with lock "cs->lock" held.
drivers/isdn/gigaset/common.c:591: missing_lock: Accessing variable "bcs->use_count" (bc_state.use_count) requires the cardstate.lock lock.

Error: MISSING_LOCK:
drivers/scsi/lpfc/lpfc_ct.c:792: example_lock: Locking "shost->host_lock".
drivers/scsi/lpfc/lpfc_ct.c:793: example_access: lpfc_vport.fc_flag is being accessed with lock "shost->host_lock" held.
drivers/scsi/lpfc/lpfc_ct.c:668: example_lock: Locking "shost->host_lock".
drivers/scsi/lpfc/lpfc_ct.c:669: example_access: lpfc_vport.fc_flag is being accessed with lock "shost->host_lock" held.
drivers/scsi/lpfc/lpfc_els.c:108: example_lock: Locking "shost->host_lock".
drivers/scsi/lpfc/lpfc_els.c:109: example_access: lpfc_vport.fc_flag is being accessed with lock "shost->host_lock" held.
drivers/scsi/lpfc/lpfc_els.c:3770: example_lock: Locking "shost->host_lock".
drivers/scsi/lpfc/lpfc_els.c:3772: example_access: lpfc_vport.fc_flag is being accessed with lock "shost->host_lock" held.
drivers/scsi/lpfc/lpfc_els.c:1187: example_lock: Locking "shost->host_lock".
drivers/scsi/lpfc/lpfc_els.c:1188: example_access: lpfc_vport.fc_flag is being accessed with lock "shost->host_lock" held.
drivers/scsi/lpfc/lpfc_hbadisc.c:716: missing_lock: Accessing variable "phba->pport->fc_flag" (lpfc_vport.fc_flag) requires the Scsi_Host.host_lock lock.

Error: MISSING_LOCK:
drivers/net/wireless/zd1211rw/zd_usb.c:765: example_lock: Locking "tx->lock".
drivers/net/wireless/zd1211rw/zd_usb.c:770: example_access: zd_usb_tx.enabled is being accessed with lock "tx->lock" held.
drivers/net/wireless/zd1211rw/zd_usb.c:790: example_lock: Locking "tx->lock".
drivers/net/wireless/zd1211rw/zd_usb.c:791: example_access: zd_usb_tx.enabled is being accessed with lock "tx->lock" held.
drivers/net/wireless/zd1211rw/zd_usb.c:989: missing_lock: Accessing variable "tx->enabled" (zd_usb_tx.enabled) requires the zd_usb_tx.lock lock.

Error: MISSING_LOCK:
drivers/net/wireless/zd1211rw/zd_usb.c:765: example_lock: Locking "tx->lock".
drivers/net/wireless/zd1211rw/zd_usb.c:771: example_access: zd_usb_tx.submitted_urbs is being accessed with lock "tx->lock" held.
drivers/net/wireless/zd1211rw/zd_usb.c:790: example_lock: Locking "tx->lock".
drivers/net/wireless/zd1211rw/zd_usb.c:792: example_access: zd_usb_tx.submitted_urbs is being accessed with lock "tx->lock" held.
drivers/net/wireless/zd1211rw/zd_usb.c:867: example_lock: Locking "tx->lock".
drivers/net/wireless/zd1211rw/zd_usb.c:868: example_access: zd_usb_tx.submitted_urbs is being accessed with lock "tx->lock" held.
drivers/net/wireless/zd1211rw/zd_usb.c:853: example_lock: Locking "tx->lock".
drivers/net/wireless/zd1211rw/zd_usb.c:854: example_access: zd_usb_tx.submitted_urbs is being accessed with lock "tx->lock" held.
drivers/net/wireless/zd1211rw/zd_usb.c:992: missing_lock: Accessing variable "tx->submitted_urbs" (zd_usb_tx.submitted_urbs) requires the zd_usb_tx.lock lock.

Error: MISSING_LOCK:
fs/jfs/jfs_dmap.c:535: example_lock: Locking "log->synclock".
fs/jfs/jfs_dmap.c:556: example_access: jfs_log.count is being accessed with lock "log->synclock" held.
fs/jfs/jfs_imap.c:2830: example_lock: Locking "log->synclock".
fs/jfs/jfs_imap.c:2850: example_access: jfs_log.count is being accessed with lock "log->synclock" held.
fs/jfs/jfs_logmgr.c:263: example_lock: Locking "log->synclock".
fs/jfs/jfs_logmgr.c:271: example_access: jfs_log.count is being accessed with lock "log->synclock" held.
fs/jfs/jfs_logmgr.c:263: example_lock: Locking "log->synclock".
fs/jfs/jfs_logmgr.c:298: example_access: jfs_log.count is being accessed with lock "log->synclock" held.
fs/jfs/jfs_metapage.c:309: example_lock: Locking "log->synclock".
fs/jfs/jfs_metapage.c:314: example_access: jfs_log.count is being accessed with lock "log->synclock" held.
fs/jfs/jfs_logmgr.c:1292: missing_lock: Accessing variable "log->count" (jfs_log.count) requires the jfs_log.synclock lock.

Error: MISSING_LOCK:
fs/jfs/jfs_logmgr.c:829: example_lock: Locking "log->gclock".
fs/jfs/jfs_logmgr.c:854: example_access: jfs_log.flush_tblk is being accessed with lock "log->gclock" held.
fs/jfs/jfs_logmgr.c:1549: example_lock: Locking "log->gclock".
fs/jfs/jfs_logmgr.c:1566: example_access: jfs_log.flush_tblk is being accessed with lock "log->gclock" held.
fs/jfs/jfs_logmgr.c:1549: example_lock: Locking "log->gclock".
fs/jfs/jfs_logmgr.c:1569: example_access: jfs_log.flush_tblk is being accessed with lock "log->gclock" held.
fs/jfs/jfs_logmgr.c:1549: example_lock: Locking "log->gclock".
fs/jfs/jfs_logmgr.c:1584: example_access: jfs_log.flush_tblk is being accessed with lock "log->gclock" held.
fs/jfs/jfs_logmgr.c:1290: missing_lock: Accessing variable "log->flush_tblk" (jfs_log.flush_tblk) requires the jfs_log.gclock lock.

Error: MISSING_LOCK:
fs/ntfs/file.c:1571: example_lock: Locking "ni->size_lock".
fs/ntfs/file.c:1574: example_access: ATTR_RECORD.data.non_resident.initialized_size is being accessed with lock "ni->size_lock" held.
fs/ntfs/inode.c:2646: example_lock: Locking "ni->size_lock".
fs/ntfs/inode.c:2649: example_access: ATTR_RECORD.data.non_resident.initialized_size is being accessed with lock "ni->size_lock" held.
fs/ntfs/mft.c:1614: example_lock: Locking "mftbmp_ni->size_lock".
fs/ntfs/mft.c:1623: example_access: ATTR_RECORD.data.non_resident.initialized_size is being accessed with lock "mftbmp_ni->size_lock" held.
fs/ntfs/mft.c:1669: example_lock: Locking "mftbmp_ni->size_lock".
fs/ntfs/mft.c:1671: example_access: ATTR_RECORD.data.non_resident.initialized_size is being accessed with lock "mftbmp_ni->size_lock" held.
fs/ntfs/mft.c:2482: example_lock: Locking "mft_ni->size_lock".
fs/ntfs/mft.c:2483: example_access: ATTR_RECORD.data.non_resident.initialized_size is being accessed with lock "mft_ni->size_lock" held.
fs/ntfs/file.c:311: missing_lock: Accessing variable "a->data.non_resident.initialized_size" (ATTR_RECORD.data.non_resident.initialized_size) requires the _ntfs_inode.size_lock lock.

Error: MISSING_LOCK:
drivers/block/cciss.c:1487: example_lock: Locking "hba[h->ctlr]->lock".
drivers/block/cciss.c:1488: example_access: _drive_info_struct.busy_configuring is being accessed with lock "hba[h->ctlr]->lock" held.
drivers/block/cciss.c:1711: example_lock: Locking "hba[h->ctlr]->lock".
drivers/block/cciss.c:1712: example_access: _drive_info_struct.busy_configuring is being accessed with lock "hba[h->ctlr]->lock" held.
drivers/block/cciss.c:1716: missing_lock: Accessing variable "h->drv[i].busy_configuring" (_drive_info_struct.busy_configuring) requires the ctlr_info.lock lock.

Error: MISSING_LOCK:
fs/ext3/super.c:2001: example_lock: Locking "journal->j_state_lock".
fs/ext3/super.c:2003: example_access: journal_s.j_flags is being accessed with lock "journal->j_state_lock" held.
fs/ext3/super.c:2001: example_lock: Locking "journal->j_state_lock".
fs/ext3/super.c:2005: example_access: journal_s.j_flags is being accessed with lock "journal->j_state_lock" held.
fs/ext3/super.c:2001: example_lock: Locking "journal->j_state_lock".
fs/ext3/super.c:2007: example_access: journal_s.j_flags is being accessed with lock "journal->j_state_lock" held.
fs/ext3/super.c:2001: example_lock: Locking "journal->j_state_lock".
fs/ext3/super.c:2009: example_access: journal_s.j_flags is being accessed with lock "journal->j_state_lock" held.
fs/ext4/super.c:2485: example_lock: Locking "journal->j_state_lock".
fs/ext4/super.c:2487: example_access: journal_s.j_flags is being accessed with lock "journal->j_state_lock" held.
fs/jbd/journal.c:1109: missing_lock: Accessing variable "journal->j_flags" (journal_s.j_flags) requires the journal_s.j_state_lock lock.

Error: MISSING_LOCK:
fs/ext3/super.c:2001: example_lock: Locking "journal->j_state_lock".
fs/ext3/super.c:2003: example_access: journal_s.j_flags is being accessed with lock "journal->j_state_lock" held.
fs/ext3/super.c:2001: example_lock: Locking "journal->j_state_lock".
fs/ext3/super.c:2005: example_access: journal_s.j_flags is being accessed with lock "journal->j_state_lock" held.
fs/ext3/super.c:2001: example_lock: Locking "journal->j_state_lock".
fs/ext3/super.c:2007: example_access: journal_s.j_flags is being accessed with lock "journal->j_state_lock" held.
fs/ext3/super.c:2001: example_lock: Locking "journal->j_state_lock".
fs/ext3/super.c:2009: example_access: journal_s.j_flags is being accessed with lock "journal->j_state_lock" held.
fs/ext4/super.c:2485: example_lock: Locking "journal->j_state_lock".
fs/ext4/super.c:2487: example_access: journal_s.j_flags is being accessed with lock "journal->j_state_lock" held.
fs/jbd/journal.c:1110: missing_lock: Accessing variable "journal->j_flags" (journal_s.j_flags) requires the journal_s.j_state_lock lock.

Error: MISSING_LOCK:
drivers/mtd/ubi/vmt.c:536: example_lock: Locking "ubi->volumes_lock".
drivers/mtd/ubi/vmt.c:545: example_access: ubi_device.rsvd_pebs is being accessed with lock "ubi->volumes_lock" held.
drivers/mtd/ubi/vmt.c:566: example_lock: Locking "ubi->volumes_lock".
drivers/mtd/ubi/vmt.c:567: example_access: ubi_device.rsvd_pebs is being accessed with lock "ubi->volumes_lock" held.
drivers/mtd/ubi/vmt.c:566: example_lock: Locking "ubi->volumes_lock".
drivers/mtd/ubi/vmt.c:573: example_access: ubi_device.rsvd_pebs is being accessed with lock "ubi->volumes_lock" held.
drivers/mtd/ubi/vmt.c:598: example_lock: Locking "ubi->volumes_lock".
drivers/mtd/ubi/vmt.c:599: example_access: ubi_device.rsvd_pebs is being accessed with lock "ubi->volumes_lock" held.
drivers/mtd/ubi/vmt.c:456: example_lock: Locking "ubi->volumes_lock".
drivers/mtd/ubi/vmt.c:457: example_access: ubi_device.rsvd_pebs is being accessed with lock "ubi->volumes_lock" held.
drivers/mtd/ubi/wl.c:1536: missing_lock: Accessing variable "ubi->rsvd_pebs" (ubi_device.rsvd_pebs) requires the ubi_device.volumes_lock lock.

Error: MISSING_LOCK:
arch/x86/kernel/io_apic.c:2184: example_lock: Locking "desc->lock".
arch/x86/kernel/io_apic.c:2187: example_access: irq_desc.status is being accessed with lock "desc->lock" held.
kernel/irq/autoprobe.c:169: example_lock: Locking "desc->lock".
kernel/irq/autoprobe.c:178: example_access: irq_desc.status is being accessed with lock "desc->lock" held.
kernel/irq/autoprobe.c:71: example_lock: Locking "desc->lock".
kernel/irq/autoprobe.c:73: example_access: irq_desc.status is being accessed with lock "desc->lock" held.
kernel/irq/autoprobe.c:71: example_lock: Locking "desc->lock".
kernel/irq/autoprobe.c:75: example_access: irq_desc.status is being accessed with lock "desc->lock" held.
kernel/irq/autoprobe.c:89: example_lock: Locking "desc->lock".
kernel/irq/autoprobe.c:95: example_access: irq_desc.status is being accessed with lock "desc->lock" held.
arch/x86/kernel/io_apic.c:2167: missing_lock: Accessing variable "desc->status" (irq_desc.status) requires the irq_desc.lock lock.

Error: MISSING_LOCK:
kernel/cgroup.c:2900: example_lock: Locking "tsk->alloc_lock".
kernel/cgroup.c:2902: example_access: task_struct.cgroups is being accessed with lock "tsk->alloc_lock" held.
kernel/cgroup.c:2763: example_lock: Locking "get_current()->alloc_lock".
kernel/cgroup.c:2764: example_access: task_struct.cgroups is being accessed with lock "get_current()->alloc_lock" held.
kernel/cgroup.c:1249: example_lock: Locking "tsk->alloc_lock".
kernel/cgroup.c:1255: example_access: task_struct.cgroups is being accessed with lock "tsk->alloc_lock" held.
kernel/cgroup.c:2567: missing_lock: Accessing variable "init_task.cgroups" (task_struct.cgroups) requires the task_struct.alloc_lock lock.

Error: MISSING_LOCK:
drivers/isdn/gigaset/bas-gigaset.c:1948: example_lock: Locking "cs->cmdlock".
drivers/isdn/gigaset/bas-gigaset.c:1956: example_access: cardstate.cmdbytes is being accessed with lock "cs->cmdlock" held.
drivers/isdn/gigaset/ser-gigaset.c:207: example_lock: Locking "cs->cmdlock".
drivers/isdn/gigaset/ser-gigaset.c:215: example_access: cardstate.cmdbytes is being accessed with lock "cs->cmdlock" held.
drivers/isdn/gigaset/ser-gigaset.c:138: example_lock: Locking "cs->cmdlock".
drivers/isdn/gigaset/ser-gigaset.c:139: example_access: cardstate.cmdbytes is being accessed with lock "cs->cmdlock" held.
drivers/isdn/gigaset/ser-gigaset.c:263: example_lock: Locking "cs->cmdlock".
drivers/isdn/gigaset/ser-gigaset.c:271: example_access: cardstate.cmdbytes is being accessed with lock "cs->cmdlock" held.
drivers/isdn/gigaset/usb-gigaset.c:463: example_lock: Locking "cs->cmdlock".
drivers/isdn/gigaset/usb-gigaset.c:464: example_access: cardstate.cmdbytes is being accessed with lock "cs->cmdlock" held.
drivers/isdn/gigaset/common.c:827: missing_lock: Accessing variable "cs->cmdbytes" (cardstate.cmdbytes) requires the cardstate.cmdlock lock.

Error: MISSING_LOCK:
fs/ubifs/tnc_commit.c:796: example_lock: Locking "c->space_lock".
fs/ubifs/tnc_commit.c:805: example_access: ubifs_info.old_idx_sz is being accessed with lock "c->space_lock" held.
fs/ubifs/master.c:281: missing_lock: Accessing variable "c->old_idx_sz" (ubifs_info.old_idx_sz) requires the ubifs_info.space_lock lock.

Error: MISSING_LOCK:
fs/direct-io.c:338: example_lock: Locking "dio->bio_lock".
fs/direct-io.c:339: example_access: dio.refcount is being accessed with lock "dio->bio_lock" held.
fs/direct-io.c:1076: example_lock: Locking "dio->bio_lock".
fs/direct-io.c:1077: example_access: dio.refcount is being accessed with lock "dio->bio_lock" held.
fs/direct-io.c:270: example_lock: Locking "dio->bio_lock".
fs/direct-io.c:271: example_access: dio.refcount is being accessed with lock "dio->bio_lock" held.
fs/direct-io.c:295: example_lock: Locking "dio->bio_lock".
fs/direct-io.c:298: example_access: dio.refcount is being accessed with lock "dio->bio_lock" held.
fs/direct-io.c:961: missing_lock: Accessing variable "dio->refcount" (dio.refcount) requires the dio.bio_lock lock.

Error: MISSING_LOCK:
drivers/ieee1394/dv1394.c:553: example_lock: Locking "video->spinlock".
drivers/ieee1394/dv1394.c:557: example_access: video_card.n_clear_frames is being accessed with lock "video->spinlock" held.
drivers/ieee1394/dv1394.c:1681: example_lock: Locking "video->spinlock".
drivers/ieee1394/dv1394.c:1684: example_access: video_card.n_clear_frames is being accessed with lock "video->spinlock" held.
drivers/ieee1394/dv1394.c:1526: example_lock: Locking "video->spinlock".
drivers/ieee1394/dv1394.c:1527: example_access: video_card.n_clear_frames is being accessed with lock "video->spinlock" held.
drivers/ieee1394/dv1394.c:1996: example_lock: Locking "video->spinlock".
drivers/ieee1394/dv1394.c:2055: example_access: video_card.n_clear_frames is being accessed with lock "video->spinlock" held.
drivers/ieee1394/dv1394.c:1996: example_lock: Locking "video->spinlock".
drivers/ieee1394/dv1394.c:2068: example_access: video_card.n_clear_frames is being accessed with lock "video->spinlock" held.
drivers/ieee1394/dv1394.c:785: missing_lock: Accessing variable "video->n_clear_frames" (video_card.n_clear_frames) requires the video_card.spinlock lock.

Error: MISSING_LOCK:
fs/afs/dir.c:668: example_lock: Locking "dentry->d_lock".
fs/afs/dir.c:669: example_access: dentry.d_flags is being accessed with lock "dentry->d_lock" held.
fs/autofs4/root.c:129: example_lock: Locking "dentry->d_lock".
fs/autofs4/root.c:130: example_access: dentry.d_flags is being accessed with lock "dentry->d_lock" held.
fs/autofs4/root.c:144: example_lock: Locking "dentry->d_lock".
fs/autofs4/root.c:145: example_access: dentry.d_flags is being accessed with lock "dentry->d_lock" held.
fs/autofs4/root.c:152: example_lock: Locking "dentry->d_lock".
fs/autofs4/root.c:153: example_access: dentry.d_flags is being accessed with lock "dentry->d_lock" held.
fs/autofs4/root.c:163: example_lock: Locking "dentry->d_lock".
fs/autofs4/root.c:164: example_access: dentry.d_flags is being accessed with lock "dentry->d_lock" held.
net/socket.c:387: missing_lock: Accessing variable "dentry->d_flags" (dentry.d_flags) requires the dentry.d_lock lock.

Error: MISSING_LOCK:
drivers/net/wan/sbni.c:1436: example_lock: Locking "snl->lock".
drivers/net/wan/sbni.c:1443: example_access: net_local.link is being accessed with lock "snl->lock" held.
drivers/net/wan/sbni.c:1436: example_lock: Locking "snl->lock".
drivers/net/wan/sbni.c:1449: example_access: net_local.link is being accessed with lock "snl->lock" held.
drivers/net/wan/sbni.c:1403: example_lock: Locking "snl->lock".
drivers/net/wan/sbni.c:1406: example_access: net_local.link is being accessed with lock "snl->lock" held.
drivers/net/wan/sbni.c:1403: example_lock: Locking "snl->lock".
drivers/net/wan/sbni.c:1407: example_access: net_local.link is being accessed with lock "snl->lock" held.
drivers/net/wan/sbni.c:430: missing_lock: Accessing variable "nl->link" (net_local.link) requires the net_local.lock lock.

Error: MISSING_LOCK:
drivers/ata/ata_piix.c:1136: example_lock: Locking "host->lock".
drivers/ata/ata_piix.c:1137: example_access: ata_host.flags is being accessed with lock "host->lock" held.
drivers/ata/ata_piix.c:1120: example_lock: Locking "host->lock".
drivers/ata/ata_piix.c:1121: example_access: ata_host.flags is being accessed with lock "host->lock" held.
drivers/ata/libata-core.c:5817: missing_lock: Accessing variable "host->flags" (ata_host.flags) requires the ata_host.lock lock.

Error: MISSING_LOCK:
drivers/net/wireless/iwlwifi/iwl-agn.c:3269: example_lock: Locking "priv->sta_lock".
drivers/net/wireless/iwlwifi/iwl-agn.c:3278: example_access: sta_id_modify.modify_mask is being accessed with lock "priv->sta_lock" held.
drivers/net/wireless/iwlwifi/iwl-rx.c:497: example_lock: Locking "priv->sta_lock".
drivers/net/wireless/iwlwifi/iwl-rx.c:499: example_access: sta_id_modify.modify_mask is being accessed with lock "priv->sta_lock" held.
drivers/net/wireless/iwlwifi/iwl-rx.c:519: example_lock: Locking "priv->sta_lock".
drivers/net/wireless/iwlwifi/iwl-rx.c:521: example_access: sta_id_modify.modify_mask is being accessed with lock "priv->sta_lock" held.
drivers/net/wireless/iwlwifi/iwl-rx.c:1010: example_lock: Locking "priv->sta_lock".
drivers/net/wireless/iwlwifi/iwl-rx.c:1013: example_access: sta_id_modify.modify_mask is being accessed with lock "priv->sta_lock" held.
drivers/net/wireless/iwlwifi/iwl-sta.c:1009: example_lock: Locking "priv->sta_lock".
drivers/net/wireless/iwlwifi/iwl-sta.c:1010: example_access: sta_id_modify.modify_mask is being accessed with lock "priv->sta_lock" held.
drivers/net/wireless/iwlwifi/iwl-3945.c:877: missing_lock: Accessing variable "station->sta.sta.modify_mask" (sta_id_modify.modify_mask) requires the iwl_priv.sta_lock lock.

Error: MISSING_LOCK:
security/selinux/ss/sidtab.c:263: example_lock: Locking "src->lock".
security/selinux/ss/sidtab.c:267: example_access: sidtab.shutdown is being accessed with lock "src->lock" held.
security/selinux/ss/sidtab.c:275: example_lock: Locking "s->lock".
security/selinux/ss/sidtab.c:276: example_access: sidtab.shutdown is being accessed with lock "s->lock" held.
security/selinux/ss/sidtab.c:28: missing_lock: Accessing variable "s->shutdown" (sidtab.shutdown) requires the sidtab.lock lock.

Error: MISSING_LOCK:
drivers/isdn/gigaset/common.c:396: example_lock: Locking "drv->lock".
drivers/isdn/gigaset/common.c:397: example_access: cardstate.flags is being accessed with lock "drv->lock" held.
drivers/isdn/gigaset/common.c:362: example_lock: Locking "drv->lock".
drivers/isdn/gigaset/common.c:368: example_access: cardstate.flags is being accessed with lock "drv->lock" held.
drivers/isdn/gigaset/common.c:387: example_lock: Locking "drv->lock".
drivers/isdn/gigaset/common.c:388: example_access: cardstate.flags is being accessed with lock "drv->lock" held.
drivers/isdn/gigaset/common.c:380: missing_lock: Accessing variable "cs->flags" (cardstate.flags) requires the gigaset_driver.lock lock.

Error: MISSING_LOCK:
drivers/infiniband/core/mad.c:1019: example_lock: Locking "qp_info->send_queue.lock".
drivers/infiniband/core/mad.c:1030: example_access: ib_mad_queue.count is being accessed with lock "qp_info->send_queue.lock" held.
drivers/infiniband/core/mad.c:583: example_lock: Locking "mad_queue->lock".
drivers/infiniband/core/mad.c:585: example_access: ib_mad_queue.count is being accessed with lock "mad_queue->lock" held.
drivers/infiniband/core/mad.c:2572: example_lock: Locking "recv_queue->lock".
drivers/infiniband/core/mad.c:2573: example_access: ib_mad_queue.count is being accessed with lock "recv_queue->lock" held.
drivers/infiniband/core/mad.c:2578: example_lock: Locking "recv_queue->lock".
drivers/infiniband/core/mad.c:2580: example_access: ib_mad_queue.count is being accessed with lock "recv_queue->lock" held.
drivers/infiniband/core/mad.c:2119: example_lock: Locking "send_queue->lock".
drivers/infiniband/core/mad.c:2123: example_access: ib_mad_queue.count is being accessed with lock "send_queue->lock" held.
drivers/infiniband/core/mad.c:2711: missing_lock: Accessing variable "mad_queue->count" (ib_mad_queue.count) requires the ib_mad_queue.lock lock.

Error: MISSING_LOCK:
sound/pci/ens1370.c:967: example_lock: Locking "ensoniq->reg_lock".
sound/pci/ens1370.c:968: example_access: ensoniq.ctrl is being accessed with lock "ensoniq->reg_lock" held.
sound/pci/ens1370.c:967: example_lock: Locking "ensoniq->reg_lock".
sound/pci/ens1370.c:980: example_access: ensoniq.ctrl is being accessed with lock "ensoniq->reg_lock" held.
sound/pci/ens1370.c:967: example_lock: Locking "ensoniq->reg_lock".
sound/pci/ens1370.c:981: example_access: ensoniq.ctrl is being accessed with lock "ensoniq->reg_lock" held.
sound/pci/ens1370.c:1709: example_lock: Locking "ensoniq->reg_lock".
sound/pci/ens1370.c:1711: example_access: ensoniq.ctrl is being accessed with lock "ensoniq->reg_lock" held.
sound/pci/ens1370.c:1709: example_lock: Locking "ensoniq->reg_lock".
sound/pci/ens1370.c:1712: example_access: ensoniq.ctrl is being accessed with lock "ensoniq->reg_lock" held.
sound/pci/ens1370.c:1853: missing_lock: Accessing variable "ensoniq->ctrl" (ensoniq.ctrl) requires the ensoniq.reg_lock lock.

Error: MISSING_LOCK:
sound/pci/ens1370.c:967: example_lock: Locking "ensoniq->reg_lock".
sound/pci/ens1370.c:968: example_access: ensoniq.ctrl is being accessed with lock "ensoniq->reg_lock" held.
sound/pci/ens1370.c:967: example_lock: Locking "ensoniq->reg_lock".
sound/pci/ens1370.c:980: example_access: ensoniq.ctrl is being accessed with lock "ensoniq->reg_lock" held.
sound/pci/ens1370.c:967: example_lock: Locking "ensoniq->reg_lock".
sound/pci/ens1370.c:981: example_access: ensoniq.ctrl is being accessed with lock "ensoniq->reg_lock" held.
sound/pci/ens1370.c:1709: example_lock: Locking "ensoniq->reg_lock".
sound/pci/ens1370.c:1711: example_access: ensoniq.ctrl is being accessed with lock "ensoniq->reg_lock" held.
sound/pci/ens1370.c:1709: example_lock: Locking "ensoniq->reg_lock".
sound/pci/ens1370.c:1712: example_access: ensoniq.ctrl is being accessed with lock "ensoniq->reg_lock" held.
sound/pci/ens1370.c:1853: missing_lock: Accessing variable "ensoniq->ctrl" (ensoniq.ctrl) requires the ensoniq.reg_lock lock.

Error: MISSING_LOCK:
sound/oss/sequencer.c:121: example_lock: Locking "lock".
sound/oss/sequencer.c:122: example_access: iqhead is being accessed with lock "lock" held.
sound/oss/sequencer.c:1245: missing_lock: Accessing variable "iqhead" (iqhead) requires the lock lock.

Error: MISSING_LOCK:
drivers/isdn/capi/capi.c:1180: example_lock: Locking "workaround_lock".
drivers/isdn/capi/capi.c:1183: example_access: capiminor.ttyskb is being accessed with lock "workaround_lock" held.
drivers/isdn/capi/capi.c:1137: example_lock: Locking "workaround_lock".
drivers/isdn/capi/capi.c:1145: example_access: capiminor.ttyskb is being accessed with lock "workaround_lock" held.
drivers/isdn/capi/capi.c:1137: example_lock: Locking "workaround_lock".
drivers/isdn/capi/capi.c:1154: example_access: capiminor.ttyskb is being accessed with lock "workaround_lock" held.
drivers/isdn/capi/capi.c:1093: example_lock: Locking "workaround_lock".
drivers/isdn/capi/capi.c:1096: example_access: capiminor.ttyskb is being accessed with lock "workaround_lock" held.
drivers/isdn/capi/capi.c:281: missing_lock: Accessing variable "mp->ttyskb" (capiminor.ttyskb) requires the workaround_lock lock.

Error: MISSING_LOCK:
kernel/exit.c:549: example_lock: Locking "tsk->alloc_lock".
kernel/exit.c:550: example_access: task_struct.files is being accessed with lock "tsk->alloc_lock" held.
kernel/exit.c:538: example_lock: Locking "tsk->alloc_lock".
kernel/exit.c:539: example_access: task_struct.files is being accessed with lock "tsk->alloc_lock" held.
kernel/fork.c:1715: example_lock: Locking "task->alloc_lock".
kernel/fork.c:1716: example_access: task_struct.files is being accessed with lock "task->alloc_lock" held.
kernel/fork.c:1646: example_lock: Locking "get_current()->alloc_lock".
kernel/fork.c:1665: example_access: task_struct.files is being accessed with lock "get_current()->alloc_lock" held.
kernel/fork.c:723: missing_lock: Accessing variable "tsk->files" (task_struct.files) requires the task_struct.alloc_lock lock.

Error: MISSING_LOCK:
drivers/scsi/aic94xx/aic94xx_scb.c:530: example_lock: Locking "last_dev_task->task_state_lock".
drivers/scsi/aic94xx/aic94xx_scb.c:531: example_access: sas_task.task_state_flags is being accessed with lock "last_dev_task->task_state_lock" held.
drivers/scsi/aic94xx/aic94xx_task.c:597: example_lock: Locking "t->task_state_lock".
drivers/scsi/aic94xx/aic94xx_task.c:598: example_access: sas_task.task_state_flags is being accessed with lock "t->task_state_lock" held.
drivers/scsi/aic94xx/aic94xx_task.c:618: example_lock: Locking "t->task_state_lock".
drivers/scsi/aic94xx/aic94xx_task.c:619: example_access: sas_task.task_state_flags is being accessed with lock "t->task_state_lock" held.
drivers/scsi/aic94xx/aic94xx_task.c:341: example_lock: Locking "task->task_state_lock".
drivers/scsi/aic94xx/aic94xx_task.c:342: example_access: sas_task.task_state_flags is being accessed with lock "task->task_state_lock" held.
drivers/scsi/aic94xx/aic94xx_task.c:341: example_lock: Locking "task->task_state_lock".
drivers/scsi/aic94xx/aic94xx_task.c:343: example_access: sas_task.task_state_flags is being accessed with lock "task->task_state_lock" held.
drivers/scsi/libsas/sas_scsi_host.c:270: missing_lock: Accessing variable "task->task_state_flags" (sas_task.task_state_flags) requires the sas_task.task_state_lock lock.

Error: MISSING_LOCK:
fs/aio.c:611: example_lock: Locking "tsk->alloc_lock".
fs/aio.c:612: example_access: task_struct.mm is being accessed with lock "tsk->alloc_lock" held.
fs/aio.c:588: example_lock: Locking "tsk->alloc_lock".
fs/aio.c:591: example_access: task_struct.mm is being accessed with lock "tsk->alloc_lock" held.
fs/exec.c:746: example_lock: Locking "tsk->alloc_lock".
fs/exec.c:748: example_access: task_struct.mm is being accessed with lock "tsk->alloc_lock" held.
kernel/exit.c:715: example_lock: Locking "tsk->alloc_lock".
kernel/exit.c:716: example_access: task_struct.mm is being accessed with lock "tsk->alloc_lock" held.
kernel/fork.c:1646: example_lock: Locking "get_current()->alloc_lock".
kernel/fork.c:1657: example_access: task_struct.mm is being accessed with lock "get_current()->alloc_lock" held.
kernel/fork.c:629: missing_lock: Accessing variable "tsk->mm" (task_struct.mm) requires the task_struct.alloc_lock lock.

Error: MISSING_LOCK:
fs/aio.c:611: example_lock: Locking "tsk->alloc_lock".
fs/aio.c:612: example_access: task_struct.mm is being accessed with lock "tsk->alloc_lock" held.
fs/aio.c:588: example_lock: Locking "tsk->alloc_lock".
fs/aio.c:591: example_access: task_struct.mm is being accessed with lock "tsk->alloc_lock" held.
fs/exec.c:746: example_lock: Locking "tsk->alloc_lock".
fs/exec.c:748: example_access: task_struct.mm is being accessed with lock "tsk->alloc_lock" held.
kernel/exit.c:715: example_lock: Locking "tsk->alloc_lock".
kernel/exit.c:716: example_access: task_struct.mm is being accessed with lock "tsk->alloc_lock" held.
kernel/fork.c:1646: example_lock: Locking "get_current()->alloc_lock".
kernel/fork.c:1657: example_access: task_struct.mm is being accessed with lock "get_current()->alloc_lock" held.
kernel/fork.c:657: missing_lock: Accessing variable "tsk->mm" (task_struct.mm) requires the task_struct.alloc_lock lock.

Error: MISSING_LOCK:
drivers/scsi/lpfc/lpfc_hbadisc.c:1143: example_lock: Locking "phba->hbalock".
drivers/scsi/lpfc/lpfc_hbadisc.c:1144: example_access: lpfc_sli.sli_flag is being accessed with lock "phba->hbalock" held.
drivers/scsi/lpfc/lpfc_hbadisc.c:874: example_lock: Locking "phba->hbalock".
drivers/scsi/lpfc/lpfc_hbadisc.c:875: example_access: lpfc_sli.sli_flag is being accessed with lock "phba->hbalock" held.
drivers/scsi/lpfc/lpfc_hbadisc.c:898: example_lock: Locking "phba->hbalock".
drivers/scsi/lpfc/lpfc_hbadisc.c:899: example_access: lpfc_sli.sli_flag is being accessed with lock "phba->hbalock" held.
drivers/scsi/lpfc/lpfc_init.c:1719: example_lock: Locking "phba->hbalock".
drivers/scsi/lpfc/lpfc_init.c:1720: example_access: lpfc_sli.sli_flag is being accessed with lock "phba->hbalock" held.
drivers/scsi/lpfc/lpfc_init.c:1797: example_lock: Locking "phba->hbalock".
drivers/scsi/lpfc/lpfc_init.c:1798: example_access: lpfc_sli.sli_flag is being accessed with lock "phba->hbalock" held.
drivers/scsi/lpfc/lpfc_sli.c:2679: missing_lock: Accessing variable "psli->sli_flag" (lpfc_sli.sli_flag) requires the lpfc_hba.hbalock lock.

Error: MISSING_LOCK:
drivers/scsi/lpfc/lpfc_hbadisc.c:489: example_lock: Locking "phba->hbalock".
drivers/scsi/lpfc/lpfc_hbadisc.c:491: example_access: lpfc_hba.work_ha is being accessed with lock "phba->hbalock" held.
drivers/scsi/lpfc/lpfc_init.c:1889: example_lock: Locking "phba->hbalock".
drivers/scsi/lpfc/lpfc_init.c:1890: example_access: lpfc_hba.work_ha is being accessed with lock "phba->hbalock" held.
drivers/scsi/lpfc/lpfc_sli.c:5157: example_lock: Locking "phba->hbalock".
drivers/scsi/lpfc/lpfc_sli.c:5159: example_access: lpfc_hba.work_ha is being accessed with lock "phba->hbalock" held.
drivers/scsi/lpfc/lpfc_sli.c:5464: example_lock: Locking "phba->hbalock".
drivers/scsi/lpfc/lpfc_sli.c:5465: example_access: lpfc_hba.work_ha is being accessed with lock "phba->hbalock" held.
drivers/scsi/lpfc/lpfc_sli.c:5194: example_lock: Locking "phba->hbalock".
drivers/scsi/lpfc/lpfc_sli.c:5207: example_access: lpfc_hba.work_ha is being accessed with lock "phba->hbalock" held.
drivers/scsi/lpfc/lpfc_sli.c:1705: missing_lock: Accessing variable "phba->work_ha" (lpfc_hba.work_ha) requires the lpfc_hba.hbalock lock.

Error: MISSING_LOCK:
drivers/input/serio/libps2.c:132: example_lock: Locking "ps2dev->serio->lock".
drivers/input/serio/libps2.c:133: example_access: ps2dev.flags is being accessed with lock "ps2dev->serio->lock" held.
drivers/input/serio/libps2.c:143: example_lock: Locking "ps2dev->serio->lock".
drivers/input/serio/libps2.c:144: example_access: ps2dev.flags is being accessed with lock "ps2dev->serio->lock" held.
drivers/input/serio/libps2.c:39: example_lock: Locking "ps2dev->serio->lock".
drivers/input/serio/libps2.c:41: example_access: ps2dev.flags is being accessed with lock "ps2dev->serio->lock" held.
drivers/input/serio/libps2.c:49: example_lock: Locking "ps2dev->serio->lock".
drivers/input/serio/libps2.c:50: example_access: ps2dev.flags is being accessed with lock "ps2dev->serio->lock" held.
drivers/input/serio/libps2.c:184: example_lock: Locking "ps2dev->serio->lock".
drivers/input/serio/libps2.c:185: example_access: ps2dev.flags is being accessed with lock "ps2dev->serio->lock" held.
drivers/input/mouse/psmouse-base.c:220: missing_lock: Accessing variable "psmouse->ps2dev.flags" (ps2dev.flags) requires the serio.lock lock.

Error: MISSING_LOCK:
drivers/mtd/ubi/vmt.c:566: example_lock: Locking "ubi->volumes_lock".
drivers/mtd/ubi/vmt.c:574: example_access: ubi_device.beb_rsvd_pebs is being accessed with lock "ubi->volumes_lock" held.
drivers/mtd/ubi/vmt.c:456: example_lock: Locking "ubi->volumes_lock".
drivers/mtd/ubi/vmt.c:464: example_access: ubi_device.beb_rsvd_pebs is being accessed with lock "ubi->volumes_lock" held.
drivers/mtd/ubi/wl.c:1099: example_lock: Locking "ubi->volumes_lock".
drivers/mtd/ubi/wl.c:1105: example_access: ubi_device.beb_rsvd_pebs is being accessed with lock "ubi->volumes_lock" held.
drivers/mtd/ubi/wl.c:1123: example_lock: Locking "ubi->volumes_lock".
drivers/mtd/ubi/wl.c:1124: example_access: ubi_device.beb_rsvd_pebs is being accessed with lock "ubi->volumes_lock" held.
drivers/mtd/ubi/eba.c:1198: missing_lock: Accessing variable "ubi->beb_rsvd_pebs" (ubi_device.beb_rsvd_pebs) requires the ubi_device.volumes_lock lock.

Error: MISSING_LOCK:
drivers/mtd/ubi/vmt.c:566: example_lock: Locking "ubi->volumes_lock".
drivers/mtd/ubi/vmt.c:574: example_access: ubi_device.beb_rsvd_pebs is being accessed with lock "ubi->volumes_lock" held.
drivers/mtd/ubi/vmt.c:456: example_lock: Locking "ubi->volumes_lock".
drivers/mtd/ubi/vmt.c:464: example_access: ubi_device.beb_rsvd_pebs is being accessed with lock "ubi->volumes_lock" held.
drivers/mtd/ubi/wl.c:1099: example_lock: Locking "ubi->volumes_lock".
drivers/mtd/ubi/wl.c:1105: example_access: ubi_device.beb_rsvd_pebs is being accessed with lock "ubi->volumes_lock" held.
drivers/mtd/ubi/wl.c:1123: example_lock: Locking "ubi->volumes_lock".
drivers/mtd/ubi/wl.c:1124: example_access: ubi_device.beb_rsvd_pebs is being accessed with lock "ubi->volumes_lock" held.
drivers/mtd/ubi/eba.c:1203: missing_lock: Accessing variable "ubi->beb_rsvd_pebs" (ubi_device.beb_rsvd_pebs) requires the ubi_device.volumes_lock lock.

Error: MISSING_LOCK:
drivers/mtd/ubi/eba.c:64: example_lock: Locking "ubi->ltree_lock".
drivers/mtd/ubi/eba.c:65: example_access: ubi_device.global_sqnum is being accessed with lock "ubi->ltree_lock" held.
drivers/mtd/ubi/eba.c:1149: missing_lock: Accessing variable "ubi->global_sqnum" (ubi_device.global_sqnum) requires the ubi_device.ltree_lock lock.

Error: MISSING_LOCK:
drivers/mtd/ubi/vmt.c:536: example_lock: Locking "ubi->volumes_lock".
drivers/mtd/ubi/vmt.c:545: example_access: ubi_device.rsvd_pebs is being accessed with lock "ubi->volumes_lock" held.
drivers/mtd/ubi/vmt.c:566: example_lock: Locking "ubi->volumes_lock".
drivers/mtd/ubi/vmt.c:567: example_access: ubi_device.rsvd_pebs is being accessed with lock "ubi->volumes_lock" held.
drivers/mtd/ubi/vmt.c:566: example_lock: Locking "ubi->volumes_lock".
drivers/mtd/ubi/vmt.c:573: example_access: ubi_device.rsvd_pebs is being accessed with lock "ubi->volumes_lock" held.
drivers/mtd/ubi/vmt.c:598: example_lock: Locking "ubi->volumes_lock".
drivers/mtd/ubi/vmt.c:599: example_access: ubi_device.rsvd_pebs is being accessed with lock "ubi->volumes_lock" held.
drivers/mtd/ubi/vmt.c:456: example_lock: Locking "ubi->volumes_lock".
drivers/mtd/ubi/vmt.c:457: example_access: ubi_device.rsvd_pebs is being accessed with lock "ubi->volumes_lock" held.
drivers/mtd/ubi/eba.c:1191: missing_lock: Accessing variable "ubi->rsvd_pebs" (ubi_device.rsvd_pebs) requires the ubi_device.volumes_lock lock.

Error: MISSING_LOCK:
drivers/mtd/ubi/vmt.c:536: example_lock: Locking "ubi->volumes_lock".
drivers/mtd/ubi/vmt.c:545: example_access: ubi_device.rsvd_pebs is being accessed with lock "ubi->volumes_lock" held.
drivers/mtd/ubi/vmt.c:566: example_lock: Locking "ubi->volumes_lock".
drivers/mtd/ubi/vmt.c:567: example_access: ubi_device.rsvd_pebs is being accessed with lock "ubi->volumes_lock" held.
drivers/mtd/ubi/vmt.c:566: example_lock: Locking "ubi->volumes_lock".
drivers/mtd/ubi/vmt.c:573: example_access: ubi_device.rsvd_pebs is being accessed with lock "ubi->volumes_lock" held.
drivers/mtd/ubi/vmt.c:598: example_lock: Locking "ubi->volumes_lock".
drivers/mtd/ubi/vmt.c:599: example_access: ubi_device.rsvd_pebs is being accessed with lock "ubi->volumes_lock" held.
drivers/mtd/ubi/vmt.c:456: example_lock: Locking "ubi->volumes_lock".
drivers/mtd/ubi/vmt.c:457: example_access: ubi_device.rsvd_pebs is being accessed with lock "ubi->volumes_lock" held.
drivers/mtd/ubi/eba.c:1206: missing_lock: Accessing variable "ubi->rsvd_pebs" (ubi_device.rsvd_pebs) requires the ubi_device.volumes_lock lock.

Error: MISSING_LOCK:
sound/pci/via82xx.c:630: example_lock: Locking "chip->reg_lock".
sound/pci/via82xx.c:643: example_access: viadev.hwptr_done is being accessed with lock "chip->reg_lock" held.
sound/pci/via82xx.c:630: example_lock: Locking "chip->reg_lock".
sound/pci/via82xx.c:645: example_access: viadev.hwptr_done is being accessed with lock "chip->reg_lock" held.
sound/pci/via82xx.c:669: example_lock: Locking "chip->reg_lock".
sound/pci/via82xx.c:692: example_access: viadev.hwptr_done is being accessed with lock "chip->reg_lock" held.
sound/pci/via82xx.c:669: example_lock: Locking "chip->reg_lock".
sound/pci/via82xx.c:694: example_access: viadev.hwptr_done is being accessed with lock "chip->reg_lock" held.
sound/pci/via82xx.c:607: missing_lock: Accessing variable "viadev->hwptr_done" (viadev.hwptr_done) requires the via82xx.reg_lock lock.

Error: MISSING_LOCK:
drivers/infiniband/hw/mthca/mthca_qp.c:2173: example_lock: Locking "qp->rq.lock".
drivers/infiniband/hw/mthca/mthca_qp.c:2218: example_access: mthca_wq.head is being accessed with lock "qp->rq.lock" held.
drivers/infiniband/hw/mthca/mthca_qp.c:1946: example_lock: Locking "qp->sq.lock".
drivers/infiniband/hw/mthca/mthca_qp.c:1959: example_access: mthca_wq.head is being accessed with lock "qp->sq.lock" held.
drivers/infiniband/hw/mthca/mthca_qp.c:1946: example_lock: Locking "qp->sq.lock".
drivers/infiniband/hw/mthca/mthca_qp.c:2132: example_access: mthca_wq.head is being accessed with lock "qp->sq.lock" held.
drivers/infiniband/hw/mthca/mthca_qp.c:1832: example_lock: Locking "qp->rq.lock".
drivers/infiniband/hw/mthca/mthca_qp.c:1895: example_access: mthca_wq.head is being accessed with lock "qp->rq.lock" held.
drivers/infiniband/hw/mthca/mthca_qp.c:1832: example_lock: Locking "qp->rq.lock".
drivers/infiniband/hw/mthca/mthca_qp.c:1909: example_access: mthca_wq.head is being accessed with lock "qp->rq.lock" held.
drivers/infiniband/hw/mthca/mthca_qp.c:233: missing_lock: Accessing variable "wq->head" (mthca_wq.head) requires the mthca_wq.lock lock.

Error: MISSING_LOCK:
drivers/net/wireless/b43/main.c:1655: example_lock: Locking "wl->irq_lock".
drivers/net/wireless/b43/main.c:1657: example_access: b43_wldev.irq_savedstate is being accessed with lock "wl->irq_lock" held.
drivers/net/wireless/b43/main.c:3629: example_lock: Locking "wl->irq_lock".
drivers/net/wireless/b43/main.c:3630: example_access: b43_wldev.irq_savedstate is being accessed with lock "wl->irq_lock" held.
drivers/net/wireless/b43/main.c:1941: example_lock: Locking "dev->wl->irq_lock".
drivers/net/wireless/b43/main.c:1968: example_access: b43_wldev.irq_savedstate is being accessed with lock "dev->wl->irq_lock" held.
drivers/net/wireless/b43/main.c:3819: missing_lock: Accessing variable "dev->irq_savedstate" (b43_wldev.irq_savedstate) requires the b43_wl.irq_lock lock.

Error: MISSING_LOCK:
sound/oss/sb_common.c:260: example_lock: Locking "devc->lock".
sound/oss/sb_common.c:261: example_access: sb_devc.major is being accessed with lock "devc->lock" held.
sound/oss/sb_common.c:260: example_lock: Locking "devc->lock".
sound/oss/sb_common.c:269: example_access: sb_devc.major is being accessed with lock "devc->lock" held.
sound/oss/sb_common.c:576: missing_lock: Accessing variable "devc->major" (sb_devc.major) requires the sb_devc.lock lock.

Error: MISSING_LOCK:
fs/ocfs2/localalloc.c:1004: example_lock: Locking "osb->osb_lock".
fs/ocfs2/localalloc.c:1030: example_access: ocfs2_super.local_alloc_bits is being accessed with lock "osb->osb_lock" held.
fs/ocfs2/localalloc.c:1004: example_lock: Locking "osb->osb_lock".
fs/ocfs2/localalloc.c:1046: example_access: ocfs2_super.local_alloc_bits is being accessed with lock "osb->osb_lock" held.
fs/ocfs2/localalloc.c:1159: example_lock: Locking "osb->osb_lock".
fs/ocfs2/localalloc.c:1160: example_access: ocfs2_super.local_alloc_bits is being accessed with lock "osb->osb_lock" held.
fs/ocfs2/localalloc.c:237: missing_lock: Accessing variable "osb->local_alloc_bits" (ocfs2_super.local_alloc_bits) requires the ocfs2_super.osb_lock lock.

Error: MISSING_LOCK:
kernel/sched_rt.c:337: example_lock: Locking "iter->rt_runtime_lock".
kernel/sched_rt.c:340: example_access: rt_rq.rt_runtime is being accessed with lock "iter->rt_runtime_lock" held.
kernel/sched_rt.c:337: example_lock: Locking "iter->rt_runtime_lock".
kernel/sched_rt.c:343: example_access: rt_rq.rt_runtime is being accessed with lock "iter->rt_runtime_lock" held.
kernel/sched_rt.c:306: example_lock: Locking "rt_rq->rt_runtime_lock".
kernel/sched_rt.c:363: example_access: rt_rq.rt_runtime is being accessed with lock "rt_rq->rt_runtime_lock" held.
kernel/sched_rt.c:392: example_lock: Locking "rt_rq->rt_runtime_lock".
kernel/sched_rt.c:393: example_access: rt_rq.rt_runtime is being accessed with lock "rt_rq->rt_runtime_lock" held.
kernel/sched_rt.c:255: example_lock: Locking "iter->rt_runtime_lock".
kernel/sched_rt.c:273: example_access: rt_rq.rt_runtime is being accessed with lock "iter->rt_runtime_lock" held.
kernel/sched.c:8273: missing_lock: Accessing variable "rq->rt.rt_runtime" (rt_rq.rt_runtime) requires the rt_rq.rt_runtime_lock lock.

Error: MISSING_LOCK:
drivers/char/tty_io.c:630: example_lock: Locking "tty->ctrl_lock".
drivers/char/tty_io.c:635: example_access: tty_struct.pgrp is being accessed with lock "tty->ctrl_lock" held.
drivers/char/tty_io.c:817: example_lock: Locking "tty->ctrl_lock".
drivers/char/tty_io.c:821: example_access: tty_struct.pgrp is being accessed with lock "tty->ctrl_lock" held.
drivers/char/tty_io.c:3054: example_lock: Locking "tty->ctrl_lock".
drivers/char/tty_io.c:3057: example_access: tty_struct.pgrp is being accessed with lock "tty->ctrl_lock" held.
drivers/char/tty_io.c:2325: example_lock: Locking "tty->ctrl_lock".
drivers/char/tty_io.c:2327: example_access: tty_struct.pgrp is being accessed with lock "tty->ctrl_lock" held.
drivers/char/tty_io.c:2777: missing_lock: Accessing variable "tty->pgrp" (tty_struct.pgrp) requires the tty_struct.ctrl_lock lock.

Error: MISSING_LOCK:
drivers/scsi/megaraid/megaraid_mbox.c:3751: example_lock: Locking "adapter->lock".
drivers/scsi/megaraid/megaraid_mbox.c:3752: example_access: adapter_t.quiescent is being accessed with lock "adapter->lock" held.
drivers/scsi/megaraid/megaraid_mbox.c:3807: missing_lock: Accessing variable "adapter->quiescent" (adapter_t.quiescent) requires the adapter_t.lock lock.

Error: MISSING_LOCK:
drivers/ata/ata_piix.c:1136: example_lock: Locking "host->lock".
drivers/ata/ata_piix.c:1137: example_access: ata_host.flags is being accessed with lock "host->lock" held.
drivers/ata/ata_piix.c:1120: example_lock: Locking "host->lock".
drivers/ata/ata_piix.c:1121: example_access: ata_host.flags is being accessed with lock "host->lock" held.
drivers/ata/libata-sff.c:2501: missing_lock: Accessing variable "host->flags" (ata_host.flags) requires the ata_host.lock lock.

Error: MISSING_LOCK:
fs/jffs2/compr.c:133: example_lock: Locking "jffs2_compressor_list_lock".
fs/jffs2/compr.c:134: example_access: jffs2_compressor.compr_buf_size is being accessed with lock "jffs2_compressor_list_lock" held.
fs/jffs2/compr.c:140: example_lock: Locking "jffs2_compressor_list_lock".
fs/jffs2/compr.c:147: example_access: jffs2_compressor.compr_buf_size is being accessed with lock "jffs2_compressor_list_lock" held.
fs/jffs2/compr.c:140: example_lock: Locking "jffs2_compressor_list_lock".
fs/jffs2/compr.c:171: example_access: jffs2_compressor.compr_buf_size is being accessed with lock "jffs2_compressor_list_lock" held.
fs/jffs2/compr.c:250: missing_lock: Accessing variable "comp->compr_buf_size" (jffs2_compressor.compr_buf_size) requires the jffs2_compressor_list_lock lock.

Error: MISSING_LOCK:
fs/jffs2/compr.c:217: example_lock: Locking "jffs2_compressor_list_lock".
fs/jffs2/compr.c:220: example_access: jffs2_compressor.usecount is being accessed with lock "jffs2_compressor_list_lock" held.
fs/jffs2/compr.c:223: example_lock: Locking "jffs2_compressor_list_lock".
fs/jffs2/compr.c:230: example_access: jffs2_compressor.usecount is being accessed with lock "jffs2_compressor_list_lock" held.
fs/jffs2/compr.c:95: example_lock: Locking "jffs2_compressor_list_lock".
fs/jffs2/compr.c:101: example_access: jffs2_compressor.usecount is being accessed with lock "jffs2_compressor_list_lock" held.
fs/jffs2/compr.c:106: example_lock: Locking "jffs2_compressor_list_lock".
fs/jffs2/compr.c:107: example_access: jffs2_compressor.usecount is being accessed with lock "jffs2_compressor_list_lock" held.
fs/jffs2/compr.c:140: example_lock: Locking "jffs2_compressor_list_lock".
fs/jffs2/compr.c:150: example_access: jffs2_compressor.usecount is being accessed with lock "jffs2_compressor_list_lock" held.
fs/jffs2/compr.c:252: missing_lock: Accessing variable "comp->usecount" (jffs2_compressor.usecount) requires the jffs2_compressor_list_lock lock.

Error: MISSING_LOCK:
arch/x86/kernel/io_apic.c:2184: example_lock: Locking "desc->lock".
arch/x86/kernel/io_apic.c:2187: example_access: irq_desc.status is being accessed with lock "desc->lock" held.
kernel/irq/autoprobe.c:169: example_lock: Locking "desc->lock".
kernel/irq/autoprobe.c:178: example_access: irq_desc.status is being accessed with lock "desc->lock" held.
kernel/irq/autoprobe.c:71: example_lock: Locking "desc->lock".
kernel/irq/autoprobe.c:73: example_access: irq_desc.status is being accessed with lock "desc->lock" held.
kernel/irq/autoprobe.c:71: example_lock: Locking "desc->lock".
kernel/irq/autoprobe.c:75: example_access: irq_desc.status is being accessed with lock "desc->lock" held.
kernel/irq/autoprobe.c:89: example_lock: Locking "desc->lock".
kernel/irq/autoprobe.c:95: example_access: irq_desc.status is being accessed with lock "desc->lock" held.
kernel/irq/spurious.c:253: missing_lock: Accessing variable "desc->status" (irq_desc.status) requires the irq_desc.lock lock.

Error: MISSING_LOCK:
drivers/atm/he.c:2094: example_lock: Locking "he_dev->global_lock".
drivers/atm/he.c:2096: example_access: he_dev.irq_tail is being accessed with lock "he_dev->global_lock" held.
drivers/atm/he.c:2094: example_lock: Locking "he_dev->global_lock".
drivers/atm/he.c:2101: example_access: he_dev.irq_tail is being accessed with lock "he_dev->global_lock" held.
drivers/atm/he.c:929: missing_lock: Accessing variable "he_dev->irq_tail" (he_dev.irq_tail) requires the he_dev.global_lock lock.

Error: MISSING_LOCK:
sound/pci/atiixp_modem.c:1047: example_lock: Locking "chip->reg_lock".
sound/pci/atiixp_modem.c:1048: example_access: atiixp_modem.codec_not_ready_bits is being accessed with lock "chip->reg_lock" held.
sound/pci/atiixp_modem.c:544: missing_lock: Accessing variable "chip->codec_not_ready_bits" (atiixp_modem.codec_not_ready_bits) requires the atiixp_modem.reg_lock lock.

Error: MISSING_LOCK:
drivers/net/mlx4/en_tx.c:407: example_lock: Locking "ring->comp_lock".
drivers/net/mlx4/en_tx.c:408: example_access: mlx4_en_cq.armed is being accessed with lock "ring->comp_lock" held.
drivers/net/mlx4/en_cq.c:139: missing_lock: Accessing variable "cq->armed" (mlx4_en_cq.armed) requires the mlx4_en_tx_ring.comp_lock lock.

Error: MISSING_LOCK:
drivers/net/ipg.c:1964: example_lock: Locking "sp->lock".
drivers/net/ipg.c:1966: example_access: ipg_nic_private.tx_current is being accessed with lock "sp->lock" held.
drivers/net/ipg.c:845: missing_lock: Accessing variable "sp->tx_current" (ipg_nic_private.tx_current) requires the ipg_nic_private.lock lock.

Error: MISSING_LOCK:
drivers/message/fusion/mptctl.c:456: example_lock: Locking "ioc->FreeQlock".
drivers/message/fusion/mptctl.c:459: example_access: _MPT_SCSI_HOST.tmPending is being accessed with lock "ioc->FreeQlock" held.
drivers/message/fusion/mptctl.c:432: example_lock: Locking "hd->ioc->FreeQlock".
drivers/message/fusion/mptctl.c:436: example_access: _MPT_SCSI_HOST.tmPending is being accessed with lock "hd->ioc->FreeQlock" held.
drivers/message/fusion/mptsas.c:3178: example_lock: Locking "ioc->FreeQlock".
drivers/message/fusion/mptsas.c:3255: example_access: _MPT_SCSI_HOST.tmPending is being accessed with lock "ioc->FreeQlock" held.
drivers/message/fusion/mptscsih.c:2699: example_lock: Locking "ioc->FreeQlock".
drivers/message/fusion/mptscsih.c:2700: example_access: _MPT_SCSI_HOST.tmPending is being accessed with lock "ioc->FreeQlock" held.
drivers/message/fusion/mptscsih.c:2234: example_lock: Locking "ioc->FreeQlock".
drivers/message/fusion/mptscsih.c:2235: example_access: _MPT_SCSI_HOST.tmPending is being accessed with lock "ioc->FreeQlock" held.
drivers/message/fusion/mptscsih.c:1751: missing_lock: Accessing variable "hd->tmPending" (_MPT_SCSI_HOST.tmPending) requires the _MPT_ADAPTER.FreeQlock lock.

Error: MISSING_LOCK:
fs/inode.c:563: example_lock: Locking "inode_lock".
fs/inode.c:564: example_access: inodes_stat_t.nr_inodes is being accessed with lock "inode_lock" held.
fs/inode.c:309: example_lock: Locking "inode_lock".
fs/inode.c:310: example_access: inodes_stat_t.nr_inodes is being accessed with lock "inode_lock" held.
fs/inode.c:618: example_lock: Locking "inode_lock".
fs/inode.c:625: example_access: inodes_stat_t.nr_inodes is being accessed with lock "inode_lock" held.
fs/inode.c:669: example_lock: Locking "inode_lock".
fs/inode.c:674: example_access: inodes_stat_t.nr_inodes is being accessed with lock "inode_lock" held.
fs/inode.c:1096: missing_lock: Accessing variable "inodes_stat.nr_inodes" (inodes_stat_t.nr_inodes) requires the inode_lock lock.

Error: MISSING_LOCK:
drivers/net/atlx/atlx.c:93: example_lock: Locking "adapter->lock".
drivers/net/atlx/atlx.c:94: example_access: atl1_adapter.phy_timer_pending is being accessed with lock "adapter->lock" held.
drivers/net/atlx/atl1.c:2549: example_lock: Locking "adapter->lock".
drivers/net/atlx/atl1.c:2550: example_access: atl1_adapter.phy_timer_pending is being accessed with lock "adapter->lock" held.
drivers/net/atlx/atl1.c:2630: missing_lock: Accessing variable "adapter->phy_timer_pending" (atl1_adapter.phy_timer_pending) requires the atl1_adapter.lock lock.

Error: MISSING_LOCK:
drivers/scsi/aic94xx/aic94xx_hwi.c:754: example_lock: Locking "seq->pend_q_lock".
drivers/scsi/aic94xx/aic94xx_hwi.c:756: example_access: asd_seq_data.pending is being accessed with lock "seq->pend_q_lock" held.
drivers/scsi/aic94xx/aic94xx_hwi.c:1212: example_lock: Locking "asd_ha->seq.pend_q_lock".
drivers/scsi/aic94xx/aic94xx_hwi.c:1215: example_access: asd_seq_data.pending is being accessed with lock "asd_ha->seq.pend_q_lock" held.
drivers/scsi/aic94xx/aic94xx_init.c:892: example_lock: Locking "asd_ha->seq.pend_q_lock".
drivers/scsi/aic94xx/aic94xx_init.c:893: example_access: asd_seq_data.pending is being accessed with lock "asd_ha->seq.pend_q_lock" held.
drivers/scsi/aic94xx/aic94xx_scb.c:879: example_lock: Locking "seq->pend_q_lock".
drivers/scsi/aic94xx/aic94xx_scb.c:880: example_access: asd_seq_data.pending is being accessed with lock "seq->pend_q_lock" held.
drivers/scsi/aic94xx/aic94xx_hwi.c:246: missing_lock: Accessing variable "seq->pending" (asd_seq_data.pending) requires the asd_seq_data.pend_q_lock lock.

Error: MISSING_LOCK:
fs/cifs/connect.c:171: example_lock: Locking "GlobalMid_Lock".
fs/cifs/connect.c:181: example_access: mid_q_entry.midState is being accessed with lock "GlobalMid_Lock" held.
fs/cifs/connect.c:577: example_lock: Locking "GlobalMid_Lock".
fs/cifs/connect.c:620: example_access: mid_q_entry.midState is being accessed with lock "GlobalMid_Lock" held.
fs/cifs/transport.c:83: example_lock: Locking "GlobalMid_Lock".
fs/cifs/transport.c:84: example_access: mid_q_entry.midState is being accessed with lock "GlobalMid_Lock" held.
fs/cifs/transport.c:69: example_lock: Locking "GlobalMid_Lock".
fs/cifs/transport.c:72: example_access: mid_q_entry.midState is being accessed with lock "GlobalMid_Lock" held.
fs/cifs/transport.c:774: example_lock: Locking "GlobalMid_Lock".
fs/cifs/transport.c:786: example_access: mid_q_entry.midState is being accessed with lock "GlobalMid_Lock" held.
fs/cifs/transport.c:962: missing_lock: Accessing variable "midQ->midState" (mid_q_entry.midState) requires the GlobalMid_Lock lock.

Error: MISSING_LOCK:
drivers/infiniband/core/mad.c:1019: example_lock: Locking "qp_info->send_queue.lock".
drivers/infiniband/core/mad.c:1030: example_access: ib_mad_queue.count is being accessed with lock "qp_info->send_queue.lock" held.
drivers/infiniband/core/mad.c:583: example_lock: Locking "mad_queue->lock".
drivers/infiniband/core/mad.c:585: example_access: ib_mad_queue.count is being accessed with lock "mad_queue->lock" held.
drivers/infiniband/core/mad.c:2572: example_lock: Locking "recv_queue->lock".
drivers/infiniband/core/mad.c:2573: example_access: ib_mad_queue.count is being accessed with lock "recv_queue->lock" held.
drivers/infiniband/core/mad.c:2578: example_lock: Locking "recv_queue->lock".
drivers/infiniband/core/mad.c:2580: example_access: ib_mad_queue.count is being accessed with lock "recv_queue->lock" held.
drivers/infiniband/core/mad.c:2119: example_lock: Locking "send_queue->lock".
drivers/infiniband/core/mad.c:2123: example_access: ib_mad_queue.count is being accessed with lock "send_queue->lock" held.
drivers/infiniband/core/mad.c:2626: missing_lock: Accessing variable "qp_info->recv_queue.count" (ib_mad_queue.count) requires the ib_mad_queue.lock lock.

Error: MISSING_LOCK:
sound/pci/ens1370.c:2181: example_lock: Locking "ensoniq->reg_lock".
sound/pci/ens1370.c:2188: example_access: ensoniq.uartc is being accessed with lock "ensoniq->reg_lock" held.
sound/pci/ens1370.c:2270: example_lock: Locking "ensoniq->reg_lock".
sound/pci/ens1370.c:2276: example_access: ensoniq.uartc is being accessed with lock "ensoniq->reg_lock" held.
sound/pci/ens1370.c:2270: example_lock: Locking "ensoniq->reg_lock".
sound/pci/ens1370.c:2281: example_access: ensoniq.uartc is being accessed with lock "ensoniq->reg_lock" held.
sound/pci/ens1370.c:2251: example_lock: Locking "ensoniq->reg_lock".
sound/pci/ens1370.c:2253: example_access: ensoniq.uartc is being accessed with lock "ensoniq->reg_lock" held.
sound/pci/ens1370.c:2251: example_lock: Locking "ensoniq->reg_lock".
sound/pci/ens1370.c:2256: example_access: ensoniq.uartc is being accessed with lock "ensoniq->reg_lock" held.
sound/pci/ens1370.c:2013: missing_lock: Accessing variable "ensoniq->uartc" (ensoniq.uartc) requires the ensoniq.reg_lock lock.

Error: MISSING_LOCK:
fs/gfs2/sys.c:337: example_lock: Locking "gt->gt_spin".
fs/gfs2/sys.c:338: example_access: gfs2_tune.gt_quota_scale_num is being accessed with lock "gt->gt_spin" held.
fs/gfs2/ops_fstype.c:69: missing_lock: Accessing variable "gt->gt_quota_scale_num" (gfs2_tune.gt_quota_scale_num) requires the gfs2_tune.gt_spin lock.

Error: MISSING_LOCK:
fs/ocfs2/dlm/userdlm.c:434: example_lock: Locking "lockres->l_lock".
fs/ocfs2/dlm/userdlm.c:464: example_access: user_lock_res.l_requested is being accessed with lock "lockres->l_lock" held.
fs/ocfs2/dlm/userdlm.c:133: example_lock: Locking "lockres->l_lock".
fs/ocfs2/dlm/userdlm.c:157: example_access: user_lock_res.l_requested is being accessed with lock "lockres->l_lock" held.
fs/ocfs2/dlm/userdlm.c:291: example_lock: Locking "lockres->l_lock".
fs/ocfs2/dlm/userdlm.c:356: example_access: user_lock_res.l_requested is being accessed with lock "lockres->l_lock" held.
fs/ocfs2/dlm/userdlm.c:240: example_lock: Locking "lockres->l_lock".
fs/ocfs2/dlm/userdlm.c:257: example_access: user_lock_res.l_requested is being accessed with lock "lockres->l_lock" held.
fs/ocfs2/dlm/userdlm.c:580: missing_lock: Accessing variable "lockres->l_requested" (user_lock_res.l_requested) requires the user_lock_res.l_lock lock.

Error: MISSING_LOCK:
drivers/net/lib8390.c:339: example_lock: Locking "ei_local->page_lock".
drivers/net/lib8390.c:341: example_access: ei_device.irqlock is being accessed with lock "ei_local->page_lock" held.
drivers/net/lib8390.c:339: example_lock: Locking "ei_local->page_lock".
drivers/net/lib8390.c:372: example_access: ei_device.irqlock is being accessed with lock "ei_local->page_lock" held.
drivers/net/lib8390.c:339: example_lock: Locking "ei_local->page_lock".
drivers/net/lib8390.c:413: example_access: ei_device.irqlock is being accessed with lock "ei_local->page_lock" held.
drivers/net/pcmcia/axnet_cs.c:1201: example_lock: Locking "ei_local->page_lock".
drivers/net/pcmcia/axnet_cs.c:1222: example_access: ei_device.irqlock is being accessed with lock "ei_local->page_lock" held.
drivers/net/pcmcia/axnet_cs.c:1201: example_lock: Locking "ei_local->page_lock".
drivers/net/pcmcia/axnet_cs.c:1283: example_access: ei_device.irqlock is being accessed with lock "ei_local->page_lock" held.
drivers/net/lib8390.c:227: missing_lock: Accessing variable "ei_local->irqlock" (ei_device.irqlock) requires the ei_device.page_lock lock.

Error: MISSING_LOCK:
fs/ext4/balloc.c:527: example_lock: Locking "sbi->s_blockgroup_lock.locks[flex_group & 0x1fUL].lock".
fs/ext4/balloc.c:528: example_access: flex_groups.free_blocks is being accessed with lock "sbi->s_blockgroup_lock.locks[flex_group & 0x1fUL].lock" held.
fs/ext4/mballoc.c:4629: example_lock: Locking "sbi->s_blockgroup_lock.locks[flex_group & 0x1fUL].lock".
fs/ext4/mballoc.c:4630: example_access: flex_groups.free_blocks is being accessed with lock "sbi->s_blockgroup_lock.locks[flex_group & 0x1fUL].lock" held.
fs/ext4/mballoc.c:2897: example_lock: Locking "sbi->s_blockgroup_lock.locks[flex_group & 0x1fUL].lock".
fs/ext4/mballoc.c:2898: example_access: flex_groups.free_blocks is being accessed with lock "sbi->s_blockgroup_lock.locks[flex_group & 0x1fUL].lock" held.
fs/ext4/resize.c:934: missing_lock: Accessing variable "(sbi->s_flex_groups + flex_group).free_blocks" (flex_groups.free_blocks) requires the bgl_lock.lock lock.

Error: MISSING_LOCK:
fs/ext4/ialloc.c:251: example_lock: Locking "sbi->s_blockgroup_lock.locks[flex_group & 0x1fUL].lock".
fs/ext4/ialloc.c:252: example_access: flex_groups.free_inodes is being accessed with lock "sbi->s_blockgroup_lock.locks[flex_group & 0x1fUL].lock" held.
fs/ext4/ialloc.c:785: example_lock: Locking "sbi->s_blockgroup_lock.locks[flex_group & 0x1fUL].lock".
fs/ext4/ialloc.c:786: example_access: flex_groups.free_inodes is being accessed with lock "sbi->s_blockgroup_lock.locks[flex_group & 0x1fUL].lock" held.
fs/ext4/resize.c:936: missing_lock: Accessing variable "(sbi->s_flex_groups + flex_group).free_inodes" (flex_groups.free_inodes) requires the bgl_lock.lock lock.

Error: MISSING_LOCK:
fs/ext4/balloc.c:519: example_lock: Locking "sbi->s_blockgroup_lock.locks[block_group & 0x1fUL].lock".
fs/ext4/balloc.c:521: example_access: ext4_group_desc.bg_checksum is being accessed with lock "sbi->s_blockgroup_lock.locks[block_group & 0x1fUL].lock" held.
fs/ext4/ialloc.c:238: example_lock: Locking "sbi->s_blockgroup_lock.locks[block_group & 0x1fUL].lock".
fs/ext4/ialloc.c:242: example_access: ext4_group_desc.bg_checksum is being accessed with lock "sbi->s_blockgroup_lock.locks[block_group & 0x1fUL].lock" held.
fs/ext4/ialloc.c:715: example_lock: Locking "sbi->s_blockgroup_lock.locks[group & 0x1fUL].lock".
fs/ext4/ialloc.c:721: example_access: ext4_group_desc.bg_checksum is being accessed with lock "sbi->s_blockgroup_lock.locks[group & 0x1fUL].lock" held.
fs/ext4/ialloc.c:737: example_lock: Locking "sbi->s_blockgroup_lock.locks[group & 0x1fUL].lock".
fs/ext4/ialloc.c:772: example_access: ext4_group_desc.bg_checksum is being accessed with lock "sbi->s_blockgroup_lock.locks[group & 0x1fUL].lock" held.
fs/ext4/mballoc.c:4621: example_lock: Locking "sbi->s_blockgroup_lock.locks[block_group & 0x1fUL].lock".
fs/ext4/mballoc.c:4623: example_access: ext4_group_desc.bg_checksum is being accessed with lock "sbi->s_blockgroup_lock.locks[block_group & 0x1fUL].lock" held.
fs/ext4/resize.c:867: missing_lock: Accessing variable "gdp->bg_checksum" (ext4_group_desc.bg_checksum) requires the bgl_lock.lock lock.

Error: MISSING_LOCK:
drivers/media/dvb/dvb-core/dmxdev.c:558: example_lock: Locking "filter->dev->lock".
drivers/media/dvb/dvb-core/dmxdev.c:559: example_access: dvb_ringbuffer.data is being accessed with lock "filter->dev->lock" held.
drivers/media/dvb/dvb-core/dmxdev.c:323: example_lock: Locking "dmxdevfilter->dev->lock".
drivers/media/dvb/dvb-core/dmxdev.c:324: example_access: dvb_ringbuffer.data is being accessed with lock "dmxdevfilter->dev->lock" held.
drivers/media/dvb/dvb-core/dmxdev.c:750: example_lock: Locking "dmxdev->lock".
drivers/media/dvb/dvb-core/dmxdev.c:751: example_access: dvb_ringbuffer.data is being accessed with lock "dmxdev->lock" held.
drivers/media/dvb/dvb-core/dmxdev.c:282: example_lock: Locking "dmxdev->lock".
drivers/media/dvb/dvb-core/dmxdev.c:283: example_access: dvb_ringbuffer.data is being accessed with lock "dmxdev->lock" held.
drivers/media/dvb/dvb-core/dmxdev.c:200: example_lock: Locking "dmxdev->lock".
drivers/media/dvb/dvb-core/dmxdev.c:201: example_access: dvb_ringbuffer.data is being accessed with lock "dmxdev->lock" held.
drivers/media/dvb/ttpci/av7110_ca.c:100: missing_lock: Accessing variable "p[0]->data" (dvb_ringbuffer.data) requires the dmxdev.lock lock.

Error: MISSING_LOCK:
sound/pci/ali5451/ali5451.c:1844: example_lock: Locking "codec->reg_lock".
sound/pci/ali5451/ali5451.c:1851: example_access: snd_ali.spdif_mask is being accessed with lock "codec->reg_lock" held.
sound/pci/ali5451/ali5451.c:1844: example_lock: Locking "codec->reg_lock".
sound/pci/ali5451/ali5451.c:1854: example_access: snd_ali.spdif_mask is being accessed with lock "codec->reg_lock" held.
sound/pci/ali5451/ali5451.c:1844: example_lock: Locking "codec->reg_lock".
sound/pci/ali5451/ali5451.c:1855: example_access: snd_ali.spdif_mask is being accessed with lock "codec->reg_lock" held.
sound/pci/ali5451/ali5451.c:1844: example_lock: Locking "codec->reg_lock".
sound/pci/ali5451/ali5451.c:1865: example_access: snd_ali.spdif_mask is being accessed with lock "codec->reg_lock" held.
sound/pci/ali5451/ali5451.c:1844: example_lock: Locking "codec->reg_lock".
sound/pci/ali5451/ali5451.c:1868: example_access: snd_ali.spdif_mask is being accessed with lock "codec->reg_lock" held.
sound/pci/ali5451/ali5451.c:2105: missing_lock: Accessing variable "codec->spdif_mask" (snd_ali.spdif_mask) requires the snd_ali.reg_lock lock.

Error: MISSING_LOCK:
fs/aio.c:312: example_lock: Locking "ctx->ctx_lock".
fs/aio.c:313: example_access: kioctx.dead is being accessed with lock "ctx->ctx_lock" held.
fs/aio.c:1224: missing_lock: Accessing variable "ioctx->dead" (kioctx.dead) requires the kioctx.ctx_lock lock.

Error: MISSING_LOCK:
drivers/usb/serial/garmin_gps.c:1090: example_lock: Locking "garmin_data_p->lock".
drivers/usb/serial/garmin_gps.c:1091: example_access: garmin_data.flags is being accessed with lock "garmin_data_p->lock" held.
drivers/usb/serial/garmin_gps.c:866: example_lock: Locking "garmin_data_p->lock".
drivers/usb/serial/garmin_gps.c:867: example_access: garmin_data.flags is being accessed with lock "garmin_data_p->lock" held.
drivers/usb/serial/garmin_gps.c:1442: example_lock: Locking "garmin_data_p->lock".
drivers/usb/serial/garmin_gps.c:1443: example_access: garmin_data.flags is being accessed with lock "garmin_data_p->lock" held.
drivers/usb/serial/garmin_gps.c:984: example_lock: Locking "garmin_data_p->lock".
drivers/usb/serial/garmin_gps.c:987: example_access: garmin_data.flags is being accessed with lock "garmin_data_p->lock" held.
drivers/usb/serial/garmin_gps.c:320: example_lock: Locking "garmin_data_p->lock".
drivers/usb/serial/garmin_gps.c:321: example_access: garmin_data.flags is being accessed with lock "garmin_data_p->lock" held.
drivers/usb/serial/garmin_gps.c:471: missing_lock: Accessing variable "garmin_data_p->flags" (garmin_data.flags) requires the garmin_data.lock lock.

Error: MISSING_LOCK:
sound/pci/trident/trident_main.c:2550: example_lock: Locking "trident->reg_lock".
sound/pci/trident/trident_main.c:2551: example_access: snd_trident.ac97_ctrl is being accessed with lock "trident->reg_lock" held.
sound/pci/trident/trident_main.c:2564: example_lock: Locking "trident->reg_lock".
sound/pci/trident/trident_main.c:2565: example_access: snd_trident.ac97_ctrl is being accessed with lock "trident->reg_lock" held.
sound/pci/trident/trident_main.c:2564: example_lock: Locking "trident->reg_lock".
sound/pci/trident/trident_main.c:2570: example_access: snd_trident.ac97_ctrl is being accessed with lock "trident->reg_lock" held.
sound/pci/trident/trident_main.c:2564: example_lock: Locking "trident->reg_lock".
sound/pci/trident/trident_main.c:2571: example_access: snd_trident.ac97_ctrl is being accessed with lock "trident->reg_lock" held.
sound/pci/trident/trident_main.c:3427: missing_lock: Accessing variable "trident->ac97_ctrl" (snd_trident.ac97_ctrl) requires the snd_trident.reg_lock lock.

Error: MISSING_LOCK:
sound/pci/trident/trident_main.c:2550: example_lock: Locking "trident->reg_lock".
sound/pci/trident/trident_main.c:2551: example_access: snd_trident.ac97_ctrl is being accessed with lock "trident->reg_lock" held.
sound/pci/trident/trident_main.c:2564: example_lock: Locking "trident->reg_lock".
sound/pci/trident/trident_main.c:2565: example_access: snd_trident.ac97_ctrl is being accessed with lock "trident->reg_lock" held.
sound/pci/trident/trident_main.c:2564: example_lock: Locking "trident->reg_lock".
sound/pci/trident/trident_main.c:2570: example_access: snd_trident.ac97_ctrl is being accessed with lock "trident->reg_lock" held.
sound/pci/trident/trident_main.c:2564: example_lock: Locking "trident->reg_lock".
sound/pci/trident/trident_main.c:2571: example_access: snd_trident.ac97_ctrl is being accessed with lock "trident->reg_lock" held.
sound/pci/trident/trident_main.c:3479: missing_lock: Accessing variable "trident->ac97_ctrl" (snd_trident.ac97_ctrl) requires the snd_trident.reg_lock lock.

Error: MISSING_LOCK:
fs/autofs4/waitq.c:484: example_lock: Locking "sbi->fs_lock".
fs/autofs4/waitq.c:485: example_access: autofs_info.uid is being accessed with lock "sbi->fs_lock" held.
fs/autofs4/inode.c:56: missing_lock: Accessing variable "ino->uid" (autofs_info.uid) requires the autofs_sb_info.fs_lock lock.

Error: MISSING_LOCK:
fs/gfs2/super.c:355: example_lock: Locking "sdp->sd_statfs_spin".
fs/gfs2/super.c:356: example_access: gfs2_statfs_change_host.sc_total is being accessed with lock "sdp->sd_statfs_spin" held.
fs/gfs2/super.c:403: example_lock: Locking "sdp->sd_statfs_spin".
fs/gfs2/super.c:404: example_access: gfs2_statfs_change_host.sc_total is being accessed with lock "sdp->sd_statfs_spin" held.
fs/gfs2/super.c:439: example_lock: Locking "sdp->sd_statfs_spin".
fs/gfs2/super.c:442: example_access: gfs2_statfs_change_host.sc_total is being accessed with lock "sdp->sd_statfs_spin" held.
fs/gfs2/super.c:470: missing_lock: Accessing variable "sc->sc_total" (gfs2_statfs_change_host.sc_total) requires the gfs2_sbd.sd_statfs_spin lock.

Error: MISSING_LOCK:
drivers/media/dvb/dvb-core/dmxdev.c:558: example_lock: Locking "filter->dev->lock".
drivers/media/dvb/dvb-core/dmxdev.c:559: example_access: dvb_ringbuffer.data is being accessed with lock "filter->dev->lock" held.
drivers/media/dvb/dvb-core/dmxdev.c:323: example_lock: Locking "dmxdevfilter->dev->lock".
drivers/media/dvb/dvb-core/dmxdev.c:324: example_access: dvb_ringbuffer.data is being accessed with lock "dmxdevfilter->dev->lock" held.
drivers/media/dvb/dvb-core/dmxdev.c:750: example_lock: Locking "dmxdev->lock".
drivers/media/dvb/dvb-core/dmxdev.c:751: example_access: dvb_ringbuffer.data is being accessed with lock "dmxdev->lock" held.
drivers/media/dvb/dvb-core/dmxdev.c:282: example_lock: Locking "dmxdev->lock".
drivers/media/dvb/dvb-core/dmxdev.c:283: example_access: dvb_ringbuffer.data is being accessed with lock "dmxdev->lock" held.
drivers/media/dvb/dvb-core/dmxdev.c:200: example_lock: Locking "dmxdev->lock".
drivers/media/dvb/dvb-core/dmxdev.c:201: example_access: dvb_ringbuffer.data is being accessed with lock "dmxdev->lock" held.
drivers/media/dvb/ttpci/av7110_ca.c:118: missing_lock: Accessing variable "cirbuf->data" (dvb_ringbuffer.data) requires the dmxdev.lock lock.

Error: MISSING_LOCK:
drivers/media/dvb/dvb-core/dmxdev.c:558: example_lock: Locking "filter->dev->lock".
drivers/media/dvb/dvb-core/dmxdev.c:559: example_access: dvb_ringbuffer.data is being accessed with lock "filter->dev->lock" held.
drivers/media/dvb/dvb-core/dmxdev.c:323: example_lock: Locking "dmxdevfilter->dev->lock".
drivers/media/dvb/dvb-core/dmxdev.c:324: example_access: dvb_ringbuffer.data is being accessed with lock "dmxdevfilter->dev->lock" held.
drivers/media/dvb/dvb-core/dmxdev.c:750: example_lock: Locking "dmxdev->lock".
drivers/media/dvb/dvb-core/dmxdev.c:751: example_access: dvb_ringbuffer.data is being accessed with lock "dmxdev->lock" held.
drivers/media/dvb/dvb-core/dmxdev.c:282: example_lock: Locking "dmxdev->lock".
drivers/media/dvb/dvb-core/dmxdev.c:283: example_access: dvb_ringbuffer.data is being accessed with lock "dmxdev->lock" held.
drivers/media/dvb/dvb-core/dmxdev.c:200: example_lock: Locking "dmxdev->lock".
drivers/media/dvb/dvb-core/dmxdev.c:201: example_access: dvb_ringbuffer.data is being accessed with lock "dmxdev->lock" held.
drivers/media/dvb/ttpci/av7110_ca.c:120: missing_lock: Accessing variable "ciwbuf->data" (dvb_ringbuffer.data) requires the dmxdev.lock lock.

Error: MISSING_LOCK:
fs/inode.c:563: example_lock: Locking "inode_lock".
fs/inode.c:564: example_access: inodes_stat_t.nr_inodes is being accessed with lock "inode_lock" held.
fs/inode.c:309: example_lock: Locking "inode_lock".
fs/inode.c:310: example_access: inodes_stat_t.nr_inodes is being accessed with lock "inode_lock" held.
fs/inode.c:618: example_lock: Locking "inode_lock".
fs/inode.c:625: example_access: inodes_stat_t.nr_inodes is being accessed with lock "inode_lock" held.
fs/inode.c:669: example_lock: Locking "inode_lock".
fs/inode.c:674: example_access: inodes_stat_t.nr_inodes is being accessed with lock "inode_lock" held.
fs/inode.c:1045: missing_lock: Accessing variable "inodes_stat.nr_inodes" (inodes_stat_t.nr_inodes) requires the inode_lock lock.

Error: MISSING_LOCK:
drivers/isdn/hisax/hfc4s8s_l1.c:1338: example_lock: Locking "hw->lock".
drivers/isdn/hisax/hfc4s8s_l1.c:1343: example_access: _hfc4s8s_hw.mr.r_irq_ctrl is being accessed with lock "hw->lock" held.
drivers/isdn/hisax/hfc4s8s_l1.c:1443: example_lock: Locking "hw->lock".
drivers/isdn/hisax/hfc4s8s_l1.c:1444: example_access: _hfc4s8s_hw.mr.r_irq_ctrl is being accessed with lock "hw->lock" held.
drivers/isdn/hisax/hfc4s8s_l1.c:1449: example_lock: Locking "hw->lock".
drivers/isdn/hisax/hfc4s8s_l1.c:1450: example_access: _hfc4s8s_hw.mr.r_irq_ctrl is being accessed with lock "hw->lock" held.
drivers/isdn/hisax/hfc4s8s_l1.c:1374: missing_lock: Accessing variable "hw->mr.r_irq_ctrl" (_hfc4s8s_hw.mr.r_irq_ctrl) requires the _hfc4s8s_hw.lock lock.

Error: MISSING_LOCK:
fs/ocfs2/alloc.c:6353: example_lock: Locking "OCFS2_I(inode)->ip_lock".
fs/ocfs2/alloc.c:6354: example_access: ocfs2_inode_info.ip_clusters is being accessed with lock "OCFS2_I(inode)->ip_lock" held.
fs/ocfs2/alloc.c:163: example_lock: Locking "OCFS2_I(inode)->ip_lock".
fs/ocfs2/alloc.c:164: example_access: ocfs2_inode_info.ip_clusters is being accessed with lock "OCFS2_I(inode)->ip_lock" held.
fs/ocfs2/dlmglue.c:1887: example_lock: Locking "oi->ip_lock".
fs/ocfs2/dlmglue.c:1888: example_access: ocfs2_inode_info.ip_clusters is being accessed with lock "oi->ip_lock" held.
fs/ocfs2/inode.c:1243: example_lock: Locking "OCFS2_I(inode)->ip_lock".
fs/ocfs2/inode.c:1245: example_access: ocfs2_inode_info.ip_clusters is being accessed with lock "OCFS2_I(inode)->ip_lock" held.
fs/ocfs2/resize.c:610: example_lock: Locking "OCFS2_I(main_bm_inode)->ip_lock".
fs/ocfs2/resize.c:611: example_access: ocfs2_inode_info.ip_clusters is being accessed with lock "OCFS2_I(main_bm_inode)->ip_lock" held.
fs/ocfs2/journal.c:1226: missing_lock: Accessing variable "OCFS2_I(inode)->ip_clusters" (ocfs2_inode_info.ip_clusters) requires the ocfs2_inode_info.ip_lock lock.

Error: MISSING_LOCK:
drivers/input/serio/libps2.c:143: example_lock: Locking "ps2dev->serio->lock".
drivers/input/serio/libps2.c:144: example_access: ps2dev.cmdcnt is being accessed with lock "ps2dev->serio->lock" held.
drivers/input/serio/libps2.c:184: example_lock: Locking "ps2dev->serio->lock".
drivers/input/serio/libps2.c:186: example_access: ps2dev.cmdcnt is being accessed with lock "ps2dev->serio->lock" held.
drivers/input/serio/libps2.c:71: example_lock: Locking "ps2dev->serio->lock".
drivers/input/serio/libps2.c:73: example_access: ps2dev.cmdcnt is being accessed with lock "ps2dev->serio->lock" held.
drivers/input/serio/libps2.c:307: missing_lock: Accessing variable "ps2dev->cmdcnt" (ps2dev.cmdcnt) requires the serio.lock lock.

Error: MISSING_LOCK:
drivers/input/serio/libps2.c:132: example_lock: Locking "ps2dev->serio->lock".
drivers/input/serio/libps2.c:133: example_access: ps2dev.flags is being accessed with lock "ps2dev->serio->lock" held.
drivers/input/serio/libps2.c:143: example_lock: Locking "ps2dev->serio->lock".
drivers/input/serio/libps2.c:144: example_access: ps2dev.flags is being accessed with lock "ps2dev->serio->lock" held.
drivers/input/serio/libps2.c:39: example_lock: Locking "ps2dev->serio->lock".
drivers/input/serio/libps2.c:41: example_access: ps2dev.flags is being accessed with lock "ps2dev->serio->lock" held.
drivers/input/serio/libps2.c:49: example_lock: Locking "ps2dev->serio->lock".
drivers/input/serio/libps2.c:50: example_access: ps2dev.flags is being accessed with lock "ps2dev->serio->lock" held.
drivers/input/serio/libps2.c:184: example_lock: Locking "ps2dev->serio->lock".
drivers/input/serio/libps2.c:185: example_access: ps2dev.flags is being accessed with lock "ps2dev->serio->lock" held.
drivers/input/serio/libps2.c:310: missing_lock: Accessing variable "ps2dev->flags" (ps2dev.flags) requires the serio.lock lock.

Error: MISSING_LOCK:
drivers/input/serio/libps2.c:132: example_lock: Locking "ps2dev->serio->lock".
drivers/input/serio/libps2.c:133: example_access: ps2dev.flags is being accessed with lock "ps2dev->serio->lock" held.
drivers/input/serio/libps2.c:143: example_lock: Locking "ps2dev->serio->lock".
drivers/input/serio/libps2.c:144: example_access: ps2dev.flags is being accessed with lock "ps2dev->serio->lock" held.
drivers/input/serio/libps2.c:39: example_lock: Locking "ps2dev->serio->lock".
drivers/input/serio/libps2.c:41: example_access: ps2dev.flags is being accessed with lock "ps2dev->serio->lock" held.
drivers/input/serio/libps2.c:49: example_lock: Locking "ps2dev->serio->lock".
drivers/input/serio/libps2.c:50: example_access: ps2dev.flags is being accessed with lock "ps2dev->serio->lock" held.
drivers/input/serio/libps2.c:184: example_lock: Locking "ps2dev->serio->lock".
drivers/input/serio/libps2.c:185: example_access: ps2dev.flags is being accessed with lock "ps2dev->serio->lock" held.
drivers/input/serio/libps2.c:316: missing_lock: Accessing variable "ps2dev->flags" (ps2dev.flags) requires the serio.lock lock.

Error: MISSING_LOCK:
drivers/ata/ata_piix.c:1136: example_lock: Locking "host->lock".
drivers/ata/ata_piix.c:1137: example_access: ata_host.flags is being accessed with lock "host->lock" held.
drivers/ata/ata_piix.c:1120: example_lock: Locking "host->lock".
drivers/ata/ata_piix.c:1121: example_access: ata_host.flags is being accessed with lock "host->lock" held.
drivers/ata/libata-core.c:5848: missing_lock: Accessing variable "host->flags" (ata_host.flags) requires the ata_host.lock lock.

Error: MISSING_LOCK:
net/core/pktgen.c:2424: example_lock: Locking "x->lock".
net/core/pktgen.c:2434: example_access: xfrm_lifetime_cur.bytes is being accessed with lock "x->lock" held.
net/ipv6/xfrm6_input.c:132: example_lock: Locking "x->lock".
net/ipv6/xfrm6_input.c:134: example_access: xfrm_lifetime_cur.bytes is being accessed with lock "x->lock" held.
net/xfrm/xfrm_input.c:194: example_lock: Locking "x->lock".
net/xfrm/xfrm_input.c:211: example_access: xfrm_lifetime_cur.bytes is being accessed with lock "x->lock" held.
net/xfrm/xfrm_user.c:306: missing_lock: Accessing variable "x->curlft.bytes" (xfrm_lifetime_cur.bytes) requires the xfrm_state.lock lock.

Error: MISSING_LOCK:
drivers/block/ub.c:1623: example_lock: Locking "sc->lock".
drivers/block/ub.c:1624: example_access: ub_dev.reset is being accessed with lock "sc->lock" held.
drivers/block/ub.c:1558: missing_lock: Accessing variable "sc->reset" (ub_dev.reset) requires the ub_dev.lock lock.

Error: MISSING_LOCK:
arch/x86/kernel/io_apic.c:2184: example_lock: Locking "desc->lock".
arch/x86/kernel/io_apic.c:2187: example_access: irq_desc.status is being accessed with lock "desc->lock" held.
kernel/irq/autoprobe.c:169: example_lock: Locking "desc->lock".
kernel/irq/autoprobe.c:178: example_access: irq_desc.status is being accessed with lock "desc->lock" held.
kernel/irq/autoprobe.c:71: example_lock: Locking "desc->lock".
kernel/irq/autoprobe.c:73: example_access: irq_desc.status is being accessed with lock "desc->lock" held.
kernel/irq/autoprobe.c:71: example_lock: Locking "desc->lock".
kernel/irq/autoprobe.c:75: example_access: irq_desc.status is being accessed with lock "desc->lock" held.
kernel/irq/autoprobe.c:89: example_lock: Locking "desc->lock".
kernel/irq/autoprobe.c:95: example_access: irq_desc.status is being accessed with lock "desc->lock" held.
arch/x86/kernel/io_apic.c:2206: missing_lock: Accessing variable "desc->status" (irq_desc.status) requires the irq_desc.lock lock.

Error: MISSING_LOCK:
drivers/scsi/ipr.c:4202: example_lock: Locking "ioa_cfg->host->host_lock".
drivers/scsi/ipr.c:4229: example_access: ipr_ioa_cfg.errors_logged is being accessed with lock "ioa_cfg->host->host_lock" held.
drivers/scsi/ipr.c:1786: example_lock: Locking "ioa_cfg->host->host_lock".
drivers/scsi/ipr.c:1788: example_access: ipr_ioa_cfg.errors_logged is being accessed with lock "ioa_cfg->host->host_lock" held.
drivers/scsi/ipr.c:2693: example_lock: Locking "ioa_cfg->host->host_lock".
drivers/scsi/ipr.c:2696: example_access: ipr_ioa_cfg.errors_logged is being accessed with lock "ioa_cfg->host->host_lock" held.
drivers/scsi/ipr.c:1754: example_lock: Locking "ioa_cfg->host->host_lock".
drivers/scsi/ipr.c:1756: example_access: ipr_ioa_cfg.errors_logged is being accessed with lock "ioa_cfg->host->host_lock" held.
drivers/scsi/ipr.c:6406: missing_lock: Accessing variable "ioa_cfg->errors_logged" (ipr_ioa_cfg.errors_logged) requires the Scsi_Host.host_lock lock.

Error: MISSING_LOCK:
fs/fat/inode.c:268: example_lock: Locking "sbi->inode_hash_lock".
fs/fat/inode.c:269: example_access: msdos_inode_info.i_pos is being accessed with lock "sbi->inode_hash_lock" held.
fs/fat/inode.c:278: example_lock: Locking "sbi->inode_hash_lock".
fs/fat/inode.c:279: example_access: msdos_inode_info.i_pos is being accessed with lock "sbi->inode_hash_lock" held.
fs/fat/inode.c:1135: missing_lock: Accessing variable "MSDOS_I(inode)->i_pos" (msdos_inode_info.i_pos) requires the msdos_sb_info.inode_hash_lock lock.

Error: MISSING_LOCK:
drivers/rtc/rtc-cmos.c:734: example_lock: Locking "rtc_lock".
drivers/rtc/rtc-cmos.c:742: example_access: rtc_device.irq_freq is being accessed with lock "rtc_lock" held.
drivers/rtc/interface.c:466: missing_lock: Accessing variable "rtc->irq_freq" (rtc_device.irq_freq) requires the rtc_lock lock.

Error: MISSING_LOCK:
arch/x86/kernel/io_apic.c:2184: example_lock: Locking "desc->lock".
arch/x86/kernel/io_apic.c:2187: example_access: irq_desc.status is being accessed with lock "desc->lock" held.
kernel/irq/autoprobe.c:169: example_lock: Locking "desc->lock".
kernel/irq/autoprobe.c:178: example_access: irq_desc.status is being accessed with lock "desc->lock" held.
kernel/irq/autoprobe.c:71: example_lock: Locking "desc->lock".
kernel/irq/autoprobe.c:73: example_access: irq_desc.status is being accessed with lock "desc->lock" held.
kernel/irq/autoprobe.c:71: example_lock: Locking "desc->lock".
kernel/irq/autoprobe.c:75: example_access: irq_desc.status is being accessed with lock "desc->lock" held.
kernel/irq/autoprobe.c:89: example_lock: Locking "desc->lock".
kernel/irq/autoprobe.c:95: example_access: irq_desc.status is being accessed with lock "desc->lock" held.
kernel/irq/migration.c:20: missing_lock: Accessing variable "desc->status" (irq_desc.status) requires the irq_desc.lock lock.

Error: MISSING_LOCK:
kernel/sched.c:1513: example_lock: Locking "rq->lock".
kernel/sched.c:1517: example_access: cfs_rq.shares is being accessed with lock "rq->lock" held.
kernel/sched.c:1621: missing_lock: Accessing variable "cfs_rq->shares" (cfs_rq.shares) requires the rq.lock lock.

Error: MISSING_LOCK:
sound/pci/ens1370.c:2181: example_lock: Locking "ensoniq->reg_lock".
sound/pci/ens1370.c:2188: example_access: ensoniq.uartc is being accessed with lock "ensoniq->reg_lock" held.
sound/pci/ens1370.c:2270: example_lock: Locking "ensoniq->reg_lock".
sound/pci/ens1370.c:2276: example_access: ensoniq.uartc is being accessed with lock "ensoniq->reg_lock" held.
sound/pci/ens1370.c:2270: example_lock: Locking "ensoniq->reg_lock".
sound/pci/ens1370.c:2281: example_access: ensoniq.uartc is being accessed with lock "ensoniq->reg_lock" held.
sound/pci/ens1370.c:2251: example_lock: Locking "ensoniq->reg_lock".
sound/pci/ens1370.c:2253: example_access: ensoniq.uartc is being accessed with lock "ensoniq->reg_lock" held.
sound/pci/ens1370.c:2251: example_lock: Locking "ensoniq->reg_lock".
sound/pci/ens1370.c:2256: example_access: ensoniq.uartc is being accessed with lock "ensoniq->reg_lock" held.
sound/pci/ens1370.c:2013: missing_lock: Accessing variable "ensoniq->uartc" (ensoniq.uartc) requires the ensoniq.reg_lock lock.

Error: MISSING_LOCK:
drivers/scsi/ipr.c:2650: example_lock: Locking "ioa_cfg->host->host_lock".
drivers/scsi/ipr.c:2651: example_access: ipr_ioa_cfg.log_level is being accessed with lock "ioa_cfg->host->host_lock" held.
drivers/scsi/ipr.c:7342: missing_lock: Accessing variable "ioa_cfg->log_level" (ipr_ioa_cfg.log_level) requires the Scsi_Host.host_lock lock.

Error: MISSING_LOCK:
drivers/scsi/aic94xx/aic94xx_task.c:40: example_lock: Locking "asd_ha->seq.pend_q_lock".
drivers/scsi/aic94xx/aic94xx_task.c:41: example_access: asd_seq_data.can_queue is being accessed with lock "asd_ha->seq.pend_q_lock" held.
drivers/scsi/aic94xx/aic94xx_task.c:535: example_lock: Locking "asd_ha->seq.pend_q_lock".
drivers/scsi/aic94xx/aic94xx_task.c:539: example_access: asd_seq_data.can_queue is being accessed with lock "asd_ha->seq.pend_q_lock" held.
drivers/scsi/aic94xx/aic94xx_hwi.c:412: missing_lock: Accessing variable "seq->can_queue" (asd_seq_data.can_queue) requires the asd_seq_data.pend_q_lock lock.

Error: MISSING_LOCK:
drivers/scsi/aic94xx/aic94xx_hwi.c:754: example_lock: Locking "seq->pend_q_lock".
drivers/scsi/aic94xx/aic94xx_hwi.c:756: example_access: asd_seq_data.pending is being accessed with lock "seq->pend_q_lock" held.
drivers/scsi/aic94xx/aic94xx_hwi.c:1212: example_lock: Locking "asd_ha->seq.pend_q_lock".
drivers/scsi/aic94xx/aic94xx_hwi.c:1215: example_access: asd_seq_data.pending is being accessed with lock "asd_ha->seq.pend_q_lock" held.
drivers/scsi/aic94xx/aic94xx_init.c:892: example_lock: Locking "asd_ha->seq.pend_q_lock".
drivers/scsi/aic94xx/aic94xx_init.c:893: example_access: asd_seq_data.pending is being accessed with lock "asd_ha->seq.pend_q_lock" held.
drivers/scsi/aic94xx/aic94xx_scb.c:879: example_lock: Locking "seq->pend_q_lock".
drivers/scsi/aic94xx/aic94xx_scb.c:880: example_access: asd_seq_data.pending is being accessed with lock "seq->pend_q_lock" held.
drivers/scsi/aic94xx/aic94xx_hwi.c:411: missing_lock: Accessing variable "seq->pending" (asd_seq_data.pending) requires the asd_seq_data.pend_q_lock lock.

Error: MISSING_LOCK:
drivers/ide/ide-proc.c:597: example_lock: Locking "ide_lock".
drivers/ide/ide-proc.c:609: example_access: ide_drive_s.settings is being accessed with lock "ide_lock" held.
drivers/ide/ide-proc.c:570: missing_lock: Accessing variable "drive->settings" (ide_drive_s.settings) requires the ide_lock lock.

Error: MISSING_LOCK:
drivers/scsi/lpfc/lpfc_els.c:1817: example_lock: Locking "shost->host_lock".
drivers/scsi/lpfc/lpfc_els.c:1818: example_access: lpfc_nodelist.nlp_flag is being accessed with lock "shost->host_lock" held.
drivers/scsi/lpfc/lpfc_els.c:1821: example_lock: Locking "shost->host_lock".
drivers/scsi/lpfc/lpfc_els.c:1822: example_access: lpfc_nodelist.nlp_flag is being accessed with lock "shost->host_lock" held.
drivers/scsi/lpfc/lpfc_els.c:2253: example_lock: Locking "shost->host_lock".
drivers/scsi/lpfc/lpfc_els.c:2254: example_access: lpfc_nodelist.nlp_flag is being accessed with lock "shost->host_lock" held.
drivers/scsi/lpfc/lpfc_els.c:2265: example_lock: Locking "shost->host_lock".
drivers/scsi/lpfc/lpfc_els.c:2266: example_access: lpfc_nodelist.nlp_flag is being accessed with lock "shost->host_lock" held.
drivers/scsi/lpfc/lpfc_els.c:3656: example_lock: Locking "shost->host_lock".
drivers/scsi/lpfc/lpfc_els.c:3657: example_access: lpfc_nodelist.nlp_flag is being accessed with lock "shost->host_lock" held.
drivers/scsi/lpfc/lpfc_els.c:1116: missing_lock: Accessing variable "ndlp->nlp_flag" (lpfc_nodelist.nlp_flag) requires the Scsi_Host.host_lock lock.

Error: MISSING_LOCK:
drivers/scsi/lpfc/lpfc_els.c:1817: example_lock: Locking "shost->host_lock".
drivers/scsi/lpfc/lpfc_els.c:1818: example_access: lpfc_nodelist.nlp_flag is being accessed with lock "shost->host_lock" held.
drivers/scsi/lpfc/lpfc_els.c:1821: example_lock: Locking "shost->host_lock".
drivers/scsi/lpfc/lpfc_els.c:1822: example_access: lpfc_nodelist.nlp_flag is being accessed with lock "shost->host_lock" held.
drivers/scsi/lpfc/lpfc_els.c:2253: example_lock: Locking "shost->host_lock".
drivers/scsi/lpfc/lpfc_els.c:2254: example_access: lpfc_nodelist.nlp_flag is being accessed with lock "shost->host_lock" held.
drivers/scsi/lpfc/lpfc_els.c:2265: example_lock: Locking "shost->host_lock".
drivers/scsi/lpfc/lpfc_els.c:2266: example_access: lpfc_nodelist.nlp_flag is being accessed with lock "shost->host_lock" held.
drivers/scsi/lpfc/lpfc_els.c:3656: example_lock: Locking "shost->host_lock".
drivers/scsi/lpfc/lpfc_els.c:3657: example_access: lpfc_nodelist.nlp_flag is being accessed with lock "shost->host_lock" held.
drivers/scsi/lpfc/lpfc_els.c:1115: missing_lock: Accessing variable "new_ndlp->nlp_flag" (lpfc_nodelist.nlp_flag) requires the Scsi_Host.host_lock lock.

Error: MISSING_LOCK:
drivers/atm/zatm.c:1495: example_lock: Locking "zatm_dev->lock".
drivers/atm/zatm.c:1496: example_access: zatm_pool_info.low_water is being accessed with lock "zatm_dev->lock" held.
drivers/atm/zatm.c:614: missing_lock: Accessing variable "zatm_dev->pool_info[i].low_water" (zatm_pool_info.low_water) requires the zatm_dev.lock lock.

Error: MISSING_LOCK:
fs/afs/dir.c:668: example_lock: Locking "dentry->d_lock".
fs/afs/dir.c:669: example_access: dentry.d_flags is being accessed with lock "dentry->d_lock" held.
fs/autofs4/root.c:129: example_lock: Locking "dentry->d_lock".
fs/autofs4/root.c:130: example_access: dentry.d_flags is being accessed with lock "dentry->d_lock" held.
fs/autofs4/root.c:144: example_lock: Locking "dentry->d_lock".
fs/autofs4/root.c:145: example_access: dentry.d_flags is being accessed with lock "dentry->d_lock" held.
fs/autofs4/root.c:152: example_lock: Locking "dentry->d_lock".
fs/autofs4/root.c:153: example_access: dentry.d_flags is being accessed with lock "dentry->d_lock" held.
fs/autofs4/root.c:163: example_lock: Locking "dentry->d_lock".
fs/autofs4/root.c:164: example_access: dentry.d_flags is being accessed with lock "dentry->d_lock" held.
fs/autofs/root.c:102: missing_lock: Accessing variable "dentry->d_flags" (dentry.d_flags) requires the dentry.d_lock lock.

Error: MISSING_LOCK:
fs/afs/dir.c:668: example_lock: Locking "dentry->d_lock".
fs/afs/dir.c:669: example_access: dentry.d_flags is being accessed with lock "dentry->d_lock" held.
fs/autofs4/root.c:129: example_lock: Locking "dentry->d_lock".
fs/autofs4/root.c:130: example_access: dentry.d_flags is being accessed with lock "dentry->d_lock" held.
fs/autofs4/root.c:144: example_lock: Locking "dentry->d_lock".
fs/autofs4/root.c:145: example_access: dentry.d_flags is being accessed with lock "dentry->d_lock" held.
fs/autofs4/root.c:152: example_lock: Locking "dentry->d_lock".
fs/autofs4/root.c:153: example_access: dentry.d_flags is being accessed with lock "dentry->d_lock" held.
fs/autofs4/root.c:163: example_lock: Locking "dentry->d_lock".
fs/autofs4/root.c:164: example_access: dentry.d_flags is being accessed with lock "dentry->d_lock" held.
fs/autofs/root.c:137: missing_lock: Accessing variable "dentry->d_flags" (dentry.d_flags) requires the dentry.d_lock lock.

Error: MISSING_LOCK:
drivers/scsi/ipr.c:4202: example_lock: Locking "ioa_cfg->host->host_lock".
drivers/scsi/ipr.c:4229: example_access: ipr_ioa_cfg.errors_logged is being accessed with lock "ioa_cfg->host->host_lock" held.
drivers/scsi/ipr.c:1786: example_lock: Locking "ioa_cfg->host->host_lock".
drivers/scsi/ipr.c:1788: example_access: ipr_ioa_cfg.errors_logged is being accessed with lock "ioa_cfg->host->host_lock" held.
drivers/scsi/ipr.c:2693: example_lock: Locking "ioa_cfg->host->host_lock".
drivers/scsi/ipr.c:2696: example_access: ipr_ioa_cfg.errors_logged is being accessed with lock "ioa_cfg->host->host_lock" held.
drivers/scsi/ipr.c:1754: example_lock: Locking "ioa_cfg->host->host_lock".
drivers/scsi/ipr.c:1756: example_access: ipr_ioa_cfg.errors_logged is being accessed with lock "ioa_cfg->host->host_lock" held.
drivers/scsi/ipr.c:1660: missing_lock: Accessing variable "ioa_cfg->errors_logged" (ipr_ioa_cfg.errors_logged) requires the Scsi_Host.host_lock lock.

Error: MISSING_LOCK:
drivers/scsi/lpfc/lpfc_ct.c:792: example_lock: Locking "shost->host_lock".
drivers/scsi/lpfc/lpfc_ct.c:793: example_access: lpfc_vport.fc_flag is being accessed with lock "shost->host_lock" held.
drivers/scsi/lpfc/lpfc_ct.c:668: example_lock: Locking "shost->host_lock".
drivers/scsi/lpfc/lpfc_ct.c:669: example_access: lpfc_vport.fc_flag is being accessed with lock "shost->host_lock" held.
drivers/scsi/lpfc/lpfc_els.c:108: example_lock: Locking "shost->host_lock".
drivers/scsi/lpfc/lpfc_els.c:109: example_access: lpfc_vport.fc_flag is being accessed with lock "shost->host_lock" held.
drivers/scsi/lpfc/lpfc_els.c:3770: example_lock: Locking "shost->host_lock".
drivers/scsi/lpfc/lpfc_els.c:3772: example_access: lpfc_vport.fc_flag is being accessed with lock "shost->host_lock" held.
drivers/scsi/lpfc/lpfc_els.c:1187: example_lock: Locking "shost->host_lock".
drivers/scsi/lpfc/lpfc_els.c:1188: example_access: lpfc_vport.fc_flag is being accessed with lock "shost->host_lock" held.
drivers/scsi/lpfc/lpfc_els.c:3989: missing_lock: Accessing variable "vport->fc_flag" (lpfc_vport.fc_flag) requires the Scsi_Host.host_lock lock.

Error: MISSING_LOCK:
drivers/usb/gadget/file_storage.c:3097: example_lock: Locking "fsg->lock".
drivers/usb/gadget/file_storage.c:3098: example_access: fsg_dev.cmnd_size is being accessed with lock "fsg->lock" held.
drivers/usb/gadget/file_storage.c:3030: missing_lock: Accessing variable "fsg->cmnd_size" (fsg_dev.cmnd_size) requires the fsg_dev.lock lock.

Error: MISSING_LOCK:
fs/ubifs/journal.c:651: example_lock: Locking "ui->ui_lock".
fs/ubifs/journal.c:652: example_access: ubifs_inode.synced_i_size is being accessed with lock "ui->ui_lock" held.
fs/ubifs/journal.c:1048: example_lock: Locking "new_ui->ui_lock".
fs/ubifs/journal.c:1049: example_access: ubifs_inode.synced_i_size is being accessed with lock "new_ui->ui_lock" held.
fs/ubifs/journal.c:1231: example_lock: Locking "ui->ui_lock".
fs/ubifs/journal.c:1232: example_access: ubifs_inode.synced_i_size is being accessed with lock "ui->ui_lock" held.
fs/ubifs/journal.c:1428: example_lock: Locking "host_ui->ui_lock".
fs/ubifs/journal.c:1429: example_access: ubifs_inode.synced_i_size is being accessed with lock "host_ui->ui_lock" held.
fs/ubifs/journal.c:809: example_lock: Locking "ui->ui_lock".
fs/ubifs/journal.c:810: example_access: ubifs_inode.synced_i_size is being accessed with lock "ui->ui_lock" held.
fs/ubifs/dir.c:151: missing_lock: Accessing variable "ui->synced_i_size" (ubifs_inode.synced_i_size) requires the ubifs_inode.ui_lock lock.

Error: MISSING_LOCK:
fs/ext3/super.c:2001: example_lock: Locking "journal->j_state_lock".
fs/ext3/super.c:2003: example_access: journal_s.j_flags is being accessed with lock "journal->j_state_lock" held.
fs/ext3/super.c:2001: example_lock: Locking "journal->j_state_lock".
fs/ext3/super.c:2005: example_access: journal_s.j_flags is being accessed with lock "journal->j_state_lock" held.
fs/ext3/super.c:2001: example_lock: Locking "journal->j_state_lock".
fs/ext3/super.c:2007: example_access: journal_s.j_flags is being accessed with lock "journal->j_state_lock" held.
fs/ext3/super.c:2001: example_lock: Locking "journal->j_state_lock".
fs/ext3/super.c:2009: example_access: journal_s.j_flags is being accessed with lock "journal->j_state_lock" held.
fs/ext4/super.c:2485: example_lock: Locking "journal->j_state_lock".
fs/ext4/super.c:2487: example_access: journal_s.j_flags is being accessed with lock "journal->j_state_lock" held.
fs/jbd2/journal.c:1441: missing_lock: Accessing variable "journal->j_flags" (journal_s.j_flags) requires the journal_s.j_state_lock lock.

Error: MISSING_LOCK:
fs/ext3/super.c:2001: example_lock: Locking "journal->j_state_lock".
fs/ext3/super.c:2003: example_access: journal_s.j_flags is being accessed with lock "journal->j_state_lock" held.
fs/ext3/super.c:2001: example_lock: Locking "journal->j_state_lock".
fs/ext3/super.c:2005: example_access: journal_s.j_flags is being accessed with lock "journal->j_state_lock" held.
fs/ext3/super.c:2001: example_lock: Locking "journal->j_state_lock".
fs/ext3/super.c:2007: example_access: journal_s.j_flags is being accessed with lock "journal->j_state_lock" held.
fs/ext3/super.c:2001: example_lock: Locking "journal->j_state_lock".
fs/ext3/super.c:2009: example_access: journal_s.j_flags is being accessed with lock "journal->j_state_lock" held.
fs/ext4/super.c:2485: example_lock: Locking "journal->j_state_lock".
fs/ext4/super.c:2487: example_access: journal_s.j_flags is being accessed with lock "journal->j_state_lock" held.
fs/jbd2/journal.c:1442: missing_lock: Accessing variable "journal->j_flags" (journal_s.j_flags) requires the journal_s.j_state_lock lock.

Error: MISSING_LOCK:
drivers/infiniband/hw/nes/nes_cm.c:1199: example_lock: Locking "nesqp->lock".
drivers/infiniband/hw/nes/nes_cm.c:1204: example_access: nes_qp.hw_tcp_state is being accessed with lock "nesqp->lock" held.
drivers/infiniband/hw/nes/nes_cm.c:488: example_lock: Locking "nesqp->lock".
drivers/infiniband/hw/nes/nes_cm.c:495: example_access: nes_qp.hw_tcp_state is being accessed with lock "nesqp->lock" held.
drivers/infiniband/hw/nes/nes_hw.c:2957: example_lock: Locking "nesqp->lock".
drivers/infiniband/hw/nes/nes_hw.c:2959: example_access: nes_qp.hw_tcp_state is being accessed with lock "nesqp->lock" held.
drivers/infiniband/hw/nes/nes_hw.c:2970: example_lock: Locking "nesqp->lock".
drivers/infiniband/hw/nes/nes_hw.c:2986: example_access: nes_qp.hw_tcp_state is being accessed with lock "nesqp->lock" held.
drivers/infiniband/hw/nes/nes_hw.c:3021: example_lock: Locking "nesqp->lock".
drivers/infiniband/hw/nes/nes_hw.c:3023: example_access: nes_qp.hw_tcp_state is being accessed with lock "nesqp->lock" held.
drivers/infiniband/hw/nes/nes_hw.c:3010: missing_lock: Accessing variable "nesqp->hw_tcp_state" (nes_qp.hw_tcp_state) requires the nes_qp.lock lock.

Error: MISSING_LOCK:
drivers/infiniband/hw/nes/nes_cm.c:2426: example_lock: Locking "nesqp->lock".
drivers/infiniband/hw/nes/nes_cm.c:2442: example_access: nes_qp.in_disconnect is being accessed with lock "nesqp->lock" held.
drivers/infiniband/hw/nes/nes_verbs.c:2889: example_lock: Locking "nesqp->lock".
drivers/infiniband/hw/nes/nes_verbs.c:2960: example_access: nes_qp.in_disconnect is being accessed with lock "nesqp->lock" held.
drivers/infiniband/hw/nes/nes_verbs.c:2889: example_lock: Locking "nesqp->lock".
drivers/infiniband/hw/nes/nes_verbs.c:2973: example_access: nes_qp.in_disconnect is being accessed with lock "nesqp->lock" held.
drivers/infiniband/hw/nes/nes_verbs.c:2889: example_lock: Locking "nesqp->lock".
drivers/infiniband/hw/nes/nes_verbs.c:2990: example_access: nes_qp.in_disconnect is being accessed with lock "nesqp->lock" held.
drivers/infiniband/hw/nes/nes_verbs.c:2889: example_lock: Locking "nesqp->lock".
drivers/infiniband/hw/nes/nes_verbs.c:3010: example_access: nes_qp.in_disconnect is being accessed with lock "nesqp->lock" held.
drivers/infiniband/hw/nes/nes_hw.c:3040: missing_lock: Accessing variable "nesqp->in_disconnect" (nes_qp.in_disconnect) requires the nes_qp.lock lock.

Error: MISSING_LOCK:
drivers/scsi/libsas/sas_init.c:137: example_lock: Locking "sas_ha->state_lock".
drivers/scsi/libsas/sas_init.c:138: example_access: sas_ha_struct.state is being accessed with lock "sas_ha->state_lock" held.
drivers/scsi/libsas/sas_init.c:90: missing_lock: Accessing variable "sas_ha->state" (sas_ha_struct.state) requires the sas_ha_struct.state_lock lock.

Error: MISSING_LOCK:
net/ieee80211/ieee80211_crypt.c:59: example_lock: Locking "ieee->lock".
net/ieee80211/ieee80211_crypt.c:60: example_access: ieee80211_device.crypt_quiesced is being accessed with lock "ieee->lock" held.
net/ieee80211/ieee80211_module.c:186: missing_lock: Accessing variable "ieee->crypt_quiesced" (ieee80211_device.crypt_quiesced) requires the ieee80211_device.lock lock.

Error: MISSING_LOCK:
drivers/atm/ambassador.c:565: example_lock: Locking "cq->lock".
drivers/atm/ambassador.c:577: example_access: amb_cq.pending is being accessed with lock "cq->lock" held.
drivers/atm/ambassador.c:608: example_lock: Locking "cq->lock".
drivers/atm/ambassador.c:609: example_access: amb_cq.pending is being accessed with lock "cq->lock" held.
drivers/atm/ambassador.c:1558: missing_lock: Accessing variable "cq->pending" (amb_cq.pending) requires the amb_cq.lock lock.

Error: MISSING_LOCK:
fs/ocfs2/alloc.c:6750: example_lock: Locking "oi->ip_lock".
fs/ocfs2/alloc.c:6752: example_access: ocfs2_dinode.i_dyn_features is being accessed with lock "oi->ip_lock" held.
fs/ocfs2/alloc.c:6638: example_lock: Locking "oi->ip_lock".
fs/ocfs2/alloc.c:6640: example_access: ocfs2_dinode.i_dyn_features is being accessed with lock "oi->ip_lock" held.
fs/ocfs2/dir.c:1327: example_lock: Locking "oi->ip_lock".
fs/ocfs2/dir.c:1329: example_access: ocfs2_dinode.i_dyn_features is being accessed with lock "oi->ip_lock" held.
fs/ocfs2/inode.c:1205: example_lock: Locking "OCFS2_I(inode)->ip_lock".
fs/ocfs2/inode.c:1209: example_access: ocfs2_dinode.i_dyn_features is being accessed with lock "OCFS2_I(inode)->ip_lock" held.
fs/ocfs2/xattr.c:1618: example_lock: Locking "oi->ip_lock".
fs/ocfs2/xattr.c:1620: example_access: ocfs2_dinode.i_dyn_features is being accessed with lock "oi->ip_lock" held.
fs/ocfs2/namei.c:452: missing_lock: Accessing variable "fe->i_dyn_features" (ocfs2_dinode.i_dyn_features) requires the ocfs2_inode_info.ip_lock lock.

Error: MISSING_LOCK:
drivers/usb/serial/io_edgeport.c:1293: example_lock: Locking "edge_port->ep_lock".
drivers/usb/serial/io_edgeport.c:1372: example_access: edgeport_port.txCredits is being accessed with lock "edge_port->ep_lock" held.
drivers/usb/serial/io_edgeport.c:1293: example_lock: Locking "edge_port->ep_lock".
drivers/usb/serial/io_edgeport.c:1385: example_access: edgeport_port.txCredits is being accessed with lock "edge_port->ep_lock" held.
drivers/usb/serial/io_edgeport.c:670: example_lock: Locking "edge_port->ep_lock".
drivers/usb/serial/io_edgeport.c:671: example_access: edgeport_port.txCredits is being accessed with lock "edge_port->ep_lock" held.
drivers/usb/serial/io_edgeport.c:2025: missing_lock: Accessing variable "edge_port->txCredits" (edgeport_port.txCredits) requires the edgeport_port.ep_lock lock.

Error: MISSING_LOCK:
drivers/char/stallion.c:3223: example_lock: Locking "brd_lock".
drivers/char/stallion.c:3251: example_access: comstats_t.rxxoff is being accessed with lock "brd_lock" held.
drivers/char/stallion.c:3286: example_lock: Locking "brd_lock".
drivers/char/stallion.c:3297: example_access: comstats_t.rxxoff is being accessed with lock "brd_lock" held.
drivers/char/stallion.c:4163: example_lock: Locking "brd_lock".
drivers/char/stallion.c:4195: example_access: comstats_t.rxxoff is being accessed with lock "brd_lock" held.
drivers/char/stallion.c:4233: example_lock: Locking "brd_lock".
drivers/char/stallion.c:4248: example_access: comstats_t.rxxoff is being accessed with lock "brd_lock" held.
drivers/char/istallion.c:4279: missing_lock: Accessing variable "stli_comstats.rxxoff" (comstats_t.rxxoff) requires the brd_lock lock.

Error: MISSING_LOCK:
drivers/char/stallion.c:3223: example_lock: Locking "brd_lock".
drivers/char/stallion.c:3231: example_access: comstats_t.rxxon is being accessed with lock "brd_lock" held.
drivers/char/stallion.c:3286: example_lock: Locking "brd_lock".
drivers/char/stallion.c:3292: example_access: comstats_t.rxxon is being accessed with lock "brd_lock" held.
drivers/char/stallion.c:4163: example_lock: Locking "brd_lock".
drivers/char/stallion.c:4172: example_access: comstats_t.rxxon is being accessed with lock "brd_lock" held.
drivers/char/stallion.c:4233: example_lock: Locking "brd_lock".
drivers/char/stallion.c:4240: example_access: comstats_t.rxxon is being accessed with lock "brd_lock" held.
drivers/char/istallion.c:4278: missing_lock: Accessing variable "stli_comstats.rxxon" (comstats_t.rxxon) requires the brd_lock lock.

Error: MISSING_LOCK:
fs/fat/inode.c:268: example_lock: Locking "sbi->inode_hash_lock".
fs/fat/inode.c:269: example_access: msdos_inode_info.i_pos is being accessed with lock "sbi->inode_hash_lock" held.
fs/fat/inode.c:278: example_lock: Locking "sbi->inode_hash_lock".
fs/fat/inode.c:279: example_access: msdos_inode_info.i_pos is being accessed with lock "sbi->inode_hash_lock" held.
fs/fat/inode.c:339: missing_lock: Accessing variable "MSDOS_I(inode)->i_pos" (msdos_inode_info.i_pos) requires the msdos_sb_info.inode_hash_lock lock.

Error: MISSING_LOCK:
drivers/gpu/drm/via/via_dmablit.c:760: example_lock: Locking "blitq->blit_lock".
drivers/gpu/drm/via/via_dmablit.c:762: example_access: _drm_via_blitq.head is being accessed with lock "blitq->blit_lock" held.
drivers/gpu/drm/via/via_dmablit.c:760: example_lock: Locking "blitq->blit_lock".
drivers/gpu/drm/via/via_dmablit.c:764: example_access: _drm_via_blitq.head is being accessed with lock "blitq->blit_lock" held.
drivers/gpu/drm/via/via_dmablit.c:560: missing_lock: Accessing variable "blitq->head" (_drm_via_blitq.head) requires the _drm_via_blitq.blit_lock lock.

Error: MISSING_LOCK:
drivers/gpu/drm/via/via_dmablit.c:702: example_lock: Locking "blitq->blit_lock".
drivers/gpu/drm/via/via_dmablit.c:705: example_access: _drm_via_blitq.num_free is being accessed with lock "blitq->blit_lock" held.
drivers/gpu/drm/via/via_dmablit.c:720: example_lock: Locking "blitq->blit_lock".
drivers/gpu/drm/via/via_dmablit.c:721: example_access: _drm_via_blitq.num_free is being accessed with lock "blitq->blit_lock" held.
drivers/gpu/drm/via/via_dmablit.c:513: example_lock: Locking "blitq->blit_lock".
drivers/gpu/drm/via/via_dmablit.c:525: example_access: _drm_via_blitq.num_free is being accessed with lock "blitq->blit_lock" held.
drivers/gpu/drm/via/via_dmablit.c:563: missing_lock: Accessing variable "blitq->num_free" (_drm_via_blitq.num_free) requires the _drm_via_blitq.blit_lock lock.

Error: MISSING_LOCK:
drivers/isdn/gigaset/common.c:285: example_lock: Locking "cs->ev_lock".
drivers/isdn/gigaset/common.c:296: example_access: event_t.ptr is being accessed with lock "cs->ev_lock" held.
drivers/isdn/gigaset/ev-layer.c:578: example_lock: Locking "cs->ev_lock".
drivers/isdn/gigaset/ev-layer.c:594: example_access: event_t.ptr is being accessed with lock "cs->ev_lock" held.
drivers/isdn/gigaset/ev-layer.c:578: example_lock: Locking "cs->ev_lock".
drivers/isdn/gigaset/ev-layer.c:663: example_access: event_t.ptr is being accessed with lock "cs->ev_lock" held.
drivers/isdn/gigaset/ev-layer.c:1945: example_lock: Locking "cs->ev_lock".
drivers/isdn/gigaset/ev-layer.c:1947: example_access: event_t.ptr is being accessed with lock "cs->ev_lock" held.
drivers/isdn/gigaset/ev-layer.c:1652: missing_lock: Accessing variable "ev->ptr" (event_t.ptr) requires the cardstate.ev_lock lock.

Error: MISSING_LOCK:
drivers/isdn/gigaset/common.c:285: example_lock: Locking "cs->ev_lock".
drivers/isdn/gigaset/common.c:293: example_access: event_t.type is being accessed with lock "cs->ev_lock" held.
drivers/isdn/gigaset/ev-layer.c:578: example_lock: Locking "cs->ev_lock".
drivers/isdn/gigaset/ev-layer.c:607: example_access: event_t.type is being accessed with lock "cs->ev_lock" held.
drivers/isdn/gigaset/ev-layer.c:578: example_lock: Locking "cs->ev_lock".
drivers/isdn/gigaset/ev-layer.c:619: example_access: event_t.type is being accessed with lock "cs->ev_lock" held.
drivers/isdn/gigaset/ev-layer.c:578: example_lock: Locking "cs->ev_lock".
drivers/isdn/gigaset/ev-layer.c:628: example_access: event_t.type is being accessed with lock "cs->ev_lock" held.
drivers/isdn/gigaset/ev-layer.c:1634: missing_lock: Accessing variable "ev->type" (event_t.type) requires the cardstate.ev_lock lock.

Error: MISSING_LOCK:
sound/oss/audio.c:831: example_lock: Locking "dmap_in->lock".
sound/oss/audio.c:842: example_access: audio_operations.enable_bits is being accessed with lock "dmap_in->lock" held.
sound/oss/audio.c:831: example_lock: Locking "dmap_in->lock".
sound/oss/audio.c:845: example_access: audio_operations.enable_bits is being accessed with lock "dmap_in->lock" held.
sound/oss/audio.c:850: example_lock: Locking "dmap_out->lock".
sound/oss/audio.c:859: example_access: audio_operations.enable_bits is being accessed with lock "dmap_out->lock" held.
sound/oss/audio.c:850: example_lock: Locking "dmap_out->lock".
sound/oss/audio.c:863: example_access: audio_operations.enable_bits is being accessed with lock "dmap_out->lock" held.
sound/oss/dmabuf.c:302: missing_lock: Accessing variable "adev->enable_bits" (audio_operations.enable_bits) requires the dma_buffparms.lock lock.

Error: MISSING_LOCK:
drivers/net/wireless/iwlwifi/iwl-agn.c:1569: example_lock: Locking "priv->lock".
drivers/net/wireless/iwlwifi/iwl-agn.c:1570: example_access: iwl_priv.assoc_id is being accessed with lock "priv->lock" held.
drivers/net/wireless/iwlwifi/iwl-agn.c:3583: example_lock: Locking "priv->lock".
drivers/net/wireless/iwlwifi/iwl-agn.c:3590: example_access: iwl_priv.assoc_id is being accessed with lock "priv->lock" held.
drivers/net/wireless/iwlwifi/iwl-agn.c:3502: example_lock: Locking "priv->lock".
drivers/net/wireless/iwlwifi/iwl-agn.c:3503: example_access: iwl_priv.assoc_id is being accessed with lock "priv->lock" held.
drivers/net/wireless/iwlwifi/iwl-agn.c:2541: missing_lock: Accessing variable "priv->assoc_id" (iwl_priv.assoc_id) requires the iwl_priv.lock lock.

Error: MISSING_LOCK:
drivers/scsi/osst.c:4383: example_lock: Locking "os_scsi_tapes_lock".
drivers/scsi/osst.c:4407: example_access: osst_tape.in_use is being accessed with lock "os_scsi_tapes_lock" held.
drivers/scsi/osst.c:4848: example_lock: Locking "os_scsi_tapes_lock".
drivers/scsi/osst.c:4849: example_access: osst_tape.in_use is being accessed with lock "os_scsi_tapes_lock" held.
drivers/scsi/osst.c:5773: example_lock: Locking "os_scsi_tapes_lock".
drivers/scsi/osst.c:5823: example_access: osst_tape.in_use is being accessed with lock "os_scsi_tapes_lock" held.
drivers/scsi/osst.c:4723: missing_lock: Accessing variable "STp->in_use" (osst_tape.in_use) requires the os_scsi_tapes_lock lock.

Error: MISSING_LOCK:
sound/pci/ens1370.c:967: example_lock: Locking "ensoniq->reg_lock".
sound/pci/ens1370.c:968: example_access: ensoniq.ctrl is being accessed with lock "ensoniq->reg_lock" held.
sound/pci/ens1370.c:967: example_lock: Locking "ensoniq->reg_lock".
sound/pci/ens1370.c:980: example_access: ensoniq.ctrl is being accessed with lock "ensoniq->reg_lock" held.
sound/pci/ens1370.c:967: example_lock: Locking "ensoniq->reg_lock".
sound/pci/ens1370.c:981: example_access: ensoniq.ctrl is being accessed with lock "ensoniq->reg_lock" held.
sound/pci/ens1370.c:1709: example_lock: Locking "ensoniq->reg_lock".
sound/pci/ens1370.c:1711: example_access: ensoniq.ctrl is being accessed with lock "ensoniq->reg_lock" held.
sound/pci/ens1370.c:1709: example_lock: Locking "ensoniq->reg_lock".
sound/pci/ens1370.c:1712: example_access: ensoniq.ctrl is being accessed with lock "ensoniq->reg_lock" held.
sound/pci/ens1370.c:1834: missing_lock: Accessing variable "ensoniq->ctrl" (ensoniq.ctrl) requires the ensoniq.reg_lock lock.

Error: MISSING_LOCK:
drivers/scsi/gdth_proc.c:674: example_lock: Locking "ha->smp_lock".
drivers/scsi/gdth_proc.c:677: example_access: gdth_ha_str.scratch_busy is being accessed with lock "ha->smp_lock" held.
drivers/scsi/gdth_proc.c:698: example_lock: Locking "ha->smp_lock".
drivers/scsi/gdth_proc.c:699: example_access: gdth_ha_str.scratch_busy is being accessed with lock "ha->smp_lock" held.
drivers/scsi/gdth.c:5004: missing_lock: Accessing variable "ha->scratch_busy" (gdth_ha_str.scratch_busy) requires the gdth_ha_str.smp_lock lock.

Error: MISSING_LOCK:
drivers/net/forcedeth.c:5374: example_lock: Locking "np->lock".
drivers/net/forcedeth.c:5375: example_access: fe_priv.in_shutdown is being accessed with lock "np->lock" held.
drivers/net/forcedeth.c:5239: missing_lock: Accessing variable "np->in_shutdown" (fe_priv.in_shutdown) requires the fe_priv.lock lock.

Error: MISSING_LOCK:
drivers/net/forcedeth.c:3450: example_lock: Locking "np->lock".
drivers/net/forcedeth.c:3459: example_access: fe_priv.nic_poll_irq is being accessed with lock "np->lock" held.
drivers/net/forcedeth.c:3467: example_lock: Locking "np->lock".
drivers/net/forcedeth.c:3476: example_access: fe_priv.nic_poll_irq is being accessed with lock "np->lock" held.
drivers/net/forcedeth.c:3567: example_lock: Locking "np->lock".
drivers/net/forcedeth.c:3576: example_access: fe_priv.nic_poll_irq is being accessed with lock "np->lock" held.
drivers/net/forcedeth.c:3585: example_lock: Locking "np->lock".
drivers/net/forcedeth.c:3594: example_access: fe_priv.nic_poll_irq is being accessed with lock "np->lock" held.
drivers/net/forcedeth.c:3800: example_lock: Locking "np->lock".
drivers/net/forcedeth.c:3806: example_access: fe_priv.nic_poll_irq is being accessed with lock "np->lock" held.
drivers/net/forcedeth.c:4049: missing_lock: Accessing variable "np->nic_poll_irq" (fe_priv.nic_poll_irq) requires the fe_priv.lock lock.

Error: MISSING_LOCK:
drivers/net/wireless/libertas/main.c:401: example_lock: Locking "priv->driver_lock".
drivers/net/wireless/libertas/main.c:413: example_access: lbs_private.infra_open is being accessed with lock "priv->driver_lock" held.
drivers/net/wireless/libertas/main.c:469: example_lock: Locking "priv->driver_lock".
drivers/net/wireless/libertas/main.c:470: example_access: lbs_private.infra_open is being accessed with lock "priv->driver_lock" held.
drivers/net/wireless/libertas/main.c:1138: missing_lock: Accessing variable "priv->infra_open" (lbs_private.infra_open) requires the lbs_private.driver_lock lock.

Error: MISSING_LOCK:
drivers/net/wireless/libertas/main.c:401: example_lock: Locking "priv->driver_lock".
drivers/net/wireless/libertas/main.c:409: example_access: lbs_private.mesh_open is being accessed with lock "priv->driver_lock" held.
drivers/net/wireless/libertas/main.c:441: example_lock: Locking "priv->driver_lock".
drivers/net/wireless/libertas/main.c:443: example_access: lbs_private.mesh_open is being accessed with lock "priv->driver_lock" held.
drivers/net/wireless/libertas/main.c:1137: missing_lock: Accessing variable "priv->mesh_open" (lbs_private.mesh_open) requires the lbs_private.driver_lock lock.

Error: MISSING_LOCK:
fs/inode.c:563: example_lock: Locking "inode_lock".
fs/inode.c:564: example_access: inodes_stat_t.nr_inodes is being accessed with lock "inode_lock" held.
fs/inode.c:309: example_lock: Locking "inode_lock".
fs/inode.c:310: example_access: inodes_stat_t.nr_inodes is being accessed with lock "inode_lock" held.
fs/inode.c:618: example_lock: Locking "inode_lock".
fs/inode.c:625: example_access: inodes_stat_t.nr_inodes is being accessed with lock "inode_lock" held.
fs/inode.c:669: example_lock: Locking "inode_lock".
fs/inode.c:674: example_access: inodes_stat_t.nr_inodes is being accessed with lock "inode_lock" held.
fs/hugetlbfs/inode.c:414: missing_lock: Accessing variable "inodes_stat.nr_inodes" (inodes_stat_t.nr_inodes) requires the inode_lock lock.

Error: MISSING_LOCK:
drivers/net/forcedeth.c:3861: example_lock: Locking "np->lock".
drivers/net/forcedeth.c:3862: example_access: fe_priv.intr_test is being accessed with lock "np->lock" held.
drivers/net/forcedeth.c:4848: missing_lock: Accessing variable "np->intr_test" (fe_priv.intr_test) requires the fe_priv.lock lock.

Error: MISSING_LOCK:
sound/oss/ad1848.c:1332: example_lock: Locking "devc->lock".
sound/oss/ad1848.c:1349: example_access: ad1848_info.audio_mode is being accessed with lock "devc->lock" held.
sound/oss/ad1848.c:1332: example_lock: Locking "devc->lock".
sound/oss/ad1848.c:1355: example_access: ad1848_info.audio_mode is being accessed with lock "devc->lock" held.
sound/oss/ad1848.c:1368: example_lock: Locking "devc->lock".
sound/oss/ad1848.c:1385: example_access: ad1848_info.audio_mode is being accessed with lock "devc->lock" held.
sound/oss/ad1848.c:1368: example_lock: Locking "devc->lock".
sound/oss/ad1848.c:1391: example_access: ad1848_info.audio_mode is being accessed with lock "devc->lock" held.
sound/oss/ad1848.c:1023: example_lock: Locking "devc->lock".
sound/oss/ad1848.c:1025: example_access: ad1848_info.audio_mode is being accessed with lock "devc->lock" held.
sound/oss/ad1848.c:1321: missing_lock: Accessing variable "devc->audio_mode" (ad1848_info.audio_mode) requires the ad1848_info.lock lock.

Error: MISSING_LOCK:
drivers/firewire/fw-topology.c:383: example_lock: Locking "card->lock".
drivers/firewire/fw-topology.c:384: example_access: fw_card.color is being accessed with lock "card->lock" held.
drivers/firewire/fw-topology.c:515: example_lock: Locking "card->lock".
drivers/firewire/fw-topology.c:539: example_access: fw_card.color is being accessed with lock "card->lock" held.
drivers/firewire/fw-card.c:379: missing_lock: Accessing variable "card->color" (fw_card.color) requires the fw_card.lock lock.

Error: MISSING_LOCK:
drivers/firewire/fw-transaction.c:384: example_lock: Locking "card->lock".
drivers/firewire/fw-transaction.c:386: example_access: fw_card.tlabel_mask is being accessed with lock "card->lock" held.
drivers/firewire/fw-transaction.c:271: example_lock: Locking "card->lock".
drivers/firewire/fw-transaction.c:281: example_access: fw_card.tlabel_mask is being accessed with lock "card->lock" held.
drivers/firewire/fw-transaction.c:74: example_lock: Locking "card->lock".
drivers/firewire/fw-transaction.c:78: example_access: fw_card.tlabel_mask is being accessed with lock "card->lock" held.
drivers/firewire/fw-transaction.c:736: example_lock: Locking "card->lock".
drivers/firewire/fw-transaction.c:740: example_access: fw_card.tlabel_mask is being accessed with lock "card->lock" held.
drivers/firewire/fw-card.c:378: missing_lock: Accessing variable "card->tlabel_mask" (fw_card.tlabel_mask) requires the fw_card.lock lock.

Error: MISSING_LOCK:
sound/pci/nm256/nm256.c:606: example_lock: Locking "chip->reg_lock".
sound/pci/nm256/nm256.c:612: example_access: nm256_stream.running is being accessed with lock "chip->reg_lock" held.
sound/pci/nm256/nm256.c:606: example_lock: Locking "chip->reg_lock".
sound/pci/nm256/nm256.c:619: example_access: nm256_stream.running is being accessed with lock "chip->reg_lock" held.
sound/pci/nm256/nm256.c:647: example_lock: Locking "chip->reg_lock".
sound/pci/nm256/nm256.c:648: example_access: nm256_stream.running is being accessed with lock "chip->reg_lock" held.
sound/pci/nm256/nm256.c:568: example_lock: Locking "chip->reg_lock".
sound/pci/nm256/nm256.c:576: example_access: nm256_stream.running is being accessed with lock "chip->reg_lock" held.
sound/pci/nm256/nm256.c:568: example_lock: Locking "chip->reg_lock".
sound/pci/nm256/nm256.c:585: example_access: nm256_stream.running is being accessed with lock "chip->reg_lock" held.
sound/pci/nm256/nm256.c:839: missing_lock: Accessing variable "s->running" (nm256_stream.running) requires the nm256.reg_lock lock.

Error: MISSING_LOCK:
sound/pci/ens1370.c:967: example_lock: Locking "ensoniq->reg_lock".
sound/pci/ens1370.c:968: example_access: ensoniq.ctrl is being accessed with lock "ensoniq->reg_lock" held.
sound/pci/ens1370.c:967: example_lock: Locking "ensoniq->reg_lock".
sound/pci/ens1370.c:980: example_access: ensoniq.ctrl is being accessed with lock "ensoniq->reg_lock" held.
sound/pci/ens1370.c:967: example_lock: Locking "ensoniq->reg_lock".
sound/pci/ens1370.c:981: example_access: ensoniq.ctrl is being accessed with lock "ensoniq->reg_lock" held.
sound/pci/ens1370.c:1709: example_lock: Locking "ensoniq->reg_lock".
sound/pci/ens1370.c:1711: example_access: ensoniq.ctrl is being accessed with lock "ensoniq->reg_lock" held.
sound/pci/ens1370.c:1709: example_lock: Locking "ensoniq->reg_lock".
sound/pci/ens1370.c:1712: example_access: ensoniq.ctrl is being accessed with lock "ensoniq->reg_lock" held.
sound/pci/ens1370.c:1834: missing_lock: Accessing variable "ensoniq->ctrl" (ensoniq.ctrl) requires the ensoniq.reg_lock lock.

Error: MISSING_LOCK:
sound/pci/ens1370.c:967: example_lock: Locking "ensoniq->reg_lock".
sound/pci/ens1370.c:968: example_access: ensoniq.ctrl is being accessed with lock "ensoniq->reg_lock" held.
sound/pci/ens1370.c:967: example_lock: Locking "ensoniq->reg_lock".
sound/pci/ens1370.c:980: example_access: ensoniq.ctrl is being accessed with lock "ensoniq->reg_lock" held.
sound/pci/ens1370.c:967: example_lock: Locking "ensoniq->reg_lock".
sound/pci/ens1370.c:981: example_access: ensoniq.ctrl is being accessed with lock "ensoniq->reg_lock" held.
sound/pci/ens1370.c:1709: example_lock: Locking "ensoniq->reg_lock".
sound/pci/ens1370.c:1711: example_access: ensoniq.ctrl is being accessed with lock "ensoniq->reg_lock" held.
sound/pci/ens1370.c:1709: example_lock: Locking "ensoniq->reg_lock".
sound/pci/ens1370.c:1712: example_access: ensoniq.ctrl is being accessed with lock "ensoniq->reg_lock" held.
sound/pci/ens1370.c:1836: missing_lock: Accessing variable "ensoniq->ctrl" (ensoniq.ctrl) requires the ensoniq.reg_lock lock.

Error: MISSING_LOCK:
sound/pci/ens1370.c:967: example_lock: Locking "ensoniq->reg_lock".
sound/pci/ens1370.c:968: example_access: ensoniq.ctrl is being accessed with lock "ensoniq->reg_lock" held.
sound/pci/ens1370.c:967: example_lock: Locking "ensoniq->reg_lock".
sound/pci/ens1370.c:980: example_access: ensoniq.ctrl is being accessed with lock "ensoniq->reg_lock" held.
sound/pci/ens1370.c:967: example_lock: Locking "ensoniq->reg_lock".
sound/pci/ens1370.c:981: example_access: ensoniq.ctrl is being accessed with lock "ensoniq->reg_lock" held.
sound/pci/ens1370.c:1709: example_lock: Locking "ensoniq->reg_lock".
sound/pci/ens1370.c:1711: example_access: ensoniq.ctrl is being accessed with lock "ensoniq->reg_lock" held.
sound/pci/ens1370.c:1709: example_lock: Locking "ensoniq->reg_lock".
sound/pci/ens1370.c:1712: example_access: ensoniq.ctrl is being accessed with lock "ensoniq->reg_lock" held.
sound/pci/ens1370.c:1837: missing_lock: Accessing variable "ensoniq->ctrl" (ensoniq.ctrl) requires the ensoniq.reg_lock lock.

Error: MISSING_LOCK:
sound/pci/bt87x.c:617: example_lock: Locking "chip->reg_lock".
sound/pci/bt87x.c:619: example_access: snd_bt87x.reg_control is being accessed with lock "chip->reg_lock" held.
sound/pci/bt87x.c:665: example_lock: Locking "chip->reg_lock".
sound/pci/bt87x.c:667: example_access: snd_bt87x.reg_control is being accessed with lock "chip->reg_lock" held.
sound/pci/bt87x.c:581: example_lock: Locking "chip->reg_lock".
sound/pci/bt87x.c:583: example_access: snd_bt87x.reg_control is being accessed with lock "chip->reg_lock" held.
sound/pci/bt87x.c:444: example_lock: Locking "chip->reg_lock".
sound/pci/bt87x.c:445: example_access: snd_bt87x.reg_control is being accessed with lock "chip->reg_lock" held.
sound/pci/bt87x.c:512: example_lock: Locking "chip->reg_lock".
sound/pci/bt87x.c:513: example_access: snd_bt87x.reg_control is being accessed with lock "chip->reg_lock" held.
sound/pci/bt87x.c:384: missing_lock: Accessing variable "chip->reg_control" (snd_bt87x.reg_control) requires the snd_bt87x.reg_lock lock.

Error: MISSING_LOCK:
drivers/atm/eni.c:1518: example_lock: Locking "eni_dev->lock".
drivers/atm/eni.c:1519: example_access: eni_dev.events is being accessed with lock "eni_dev->lock" held.
drivers/atm/eni.c:1834: missing_lock: Accessing variable "eni_dev->events" (eni_dev.events) requires the eni_dev.lock lock.

Error: MISSING_LOCK:
drivers/uwb/uwbd.c:351: example_lock: Locking "uwbd_event_list_lock".
drivers/uwb/uwbd.c:352: example_access: uwbd_pid is being accessed with lock "uwbd_event_list_lock" held.
drivers/uwb/uwbd.c:342: missing_lock: Accessing variable "uwbd_pid" (uwbd_pid) requires the uwbd_event_list_lock lock.

Error: MISSING_LOCK:
drivers/mmc/host/tifm_sd.c:804: example_lock: Locking "sock->lock".
drivers/mmc/host/tifm_sd.c:835: example_access: tifm_sd.clk_div is being accessed with lock "sock->lock" held.
drivers/mmc/host/tifm_sd.c:804: example_lock: Locking "sock->lock".
drivers/mmc/host/tifm_sd.c:841: example_access: tifm_sd.clk_div is being accessed with lock "sock->lock" held.
drivers/mmc/host/tifm_sd.c:804: example_lock: Locking "sock->lock".
drivers/mmc/host/tifm_sd.c:847: example_access: tifm_sd.clk_div is being accessed with lock "sock->lock" held.
drivers/mmc/host/tifm_sd.c:804: example_lock: Locking "sock->lock".
drivers/mmc/host/tifm_sd.c:849: example_access: tifm_sd.clk_div is being accessed with lock "sock->lock" held.
drivers/mmc/host/tifm_sd.c:892: missing_lock: Accessing variable "host->clk_div" (tifm_sd.clk_div) requires the tifm_dev.lock lock.

Error: MISSING_LOCK:
drivers/char/specialix.c:1465: example_lock: Locking "port->lock".
drivers/char/specialix.c:1466: example_access: specialix_port.xmit_cnt is being accessed with lock "port->lock" held.
drivers/char/specialix.c:1209: example_lock: Locking "port->lock".
drivers/char/specialix.c:1214: example_access: specialix_port.xmit_cnt is being accessed with lock "port->lock" held.
drivers/char/specialix.c:1656: example_lock: Locking "port->lock".
drivers/char/specialix.c:1669: example_access: specialix_port.xmit_cnt is being accessed with lock "port->lock" held.
drivers/char/specialix.c:1607: example_lock: Locking "port->lock".
drivers/char/specialix.c:1616: example_access: specialix_port.xmit_cnt is being accessed with lock "port->lock" held.
drivers/char/specialix.c:721: missing_lock: Accessing variable "port->xmit_cnt" (specialix_port.xmit_cnt) requires the specialix_port.lock lock.

Error: MISSING_LOCK:
drivers/isdn/divert/isdn_divert.c:227: example_lock: Locking "divert_lock".
drivers/isdn/divert/isdn_divert.c:228: example_access: call_struc.akt_state is being accessed with lock "divert_lock" held.
drivers/isdn/divert/isdn_divert.c:241: example_lock: Locking "divert_lock".
drivers/isdn/divert/isdn_divert.c:242: example_access: call_struc.akt_state is being accessed with lock "divert_lock" held.
drivers/isdn/divert/isdn_divert.c:258: example_lock: Locking "divert_lock".
drivers/isdn/divert/isdn_divert.c:259: example_access: call_struc.akt_state is being accessed with lock "divert_lock" held.
drivers/isdn/divert/isdn_divert.c:70: example_lock: Locking "divert_lock".
drivers/isdn/divert/isdn_divert.c:71: example_access: call_struc.akt_state is being accessed with lock "divert_lock" held.
drivers/isdn/divert/isdn_divert.c:82: example_lock: Locking "divert_lock".
drivers/isdn/divert/isdn_divert.c:83: example_access: call_struc.akt_state is being accessed with lock "divert_lock" held.
drivers/isdn/divert/isdn_divert.c:248: missing_lock: Accessing variable "cs->akt_state" (call_struc.akt_state) requires the divert_lock lock.

Error: MISSING_LOCK:
drivers/isdn/divert/isdn_divert.c:227: example_lock: Locking "divert_lock".
drivers/isdn/divert/isdn_divert.c:228: example_access: call_struc.akt_state is being accessed with lock "divert_lock" held.
drivers/isdn/divert/isdn_divert.c:241: example_lock: Locking "divert_lock".
drivers/isdn/divert/isdn_divert.c:242: example_access: call_struc.akt_state is being accessed with lock "divert_lock" held.
drivers/isdn/divert/isdn_divert.c:258: example_lock: Locking "divert_lock".
drivers/isdn/divert/isdn_divert.c:259: example_access: call_struc.akt_state is being accessed with lock "divert_lock" held.
drivers/isdn/divert/isdn_divert.c:70: example_lock: Locking "divert_lock".
drivers/isdn/divert/isdn_divert.c:71: example_access: call_struc.akt_state is being accessed with lock "divert_lock" held.
drivers/isdn/divert/isdn_divert.c:82: example_lock: Locking "divert_lock".
drivers/isdn/divert/isdn_divert.c:83: example_access: call_struc.akt_state is being accessed with lock "divert_lock" held.
drivers/isdn/divert/isdn_divert.c:265: missing_lock: Accessing variable "cs->akt_state" (call_struc.akt_state) requires the divert_lock lock.

Error: MISSING_LOCK:
kernel/kthread.c:101: example_lock: Locking "tasklist_lock".
kernel/kthread.c:102: example_access: kthread_create_info.result is being accessed with lock "tasklist_lock" held.
kernel/kthread.c:97: missing_lock: Accessing variable "create->result" (kthread_create_info.result) requires the tasklist_lock lock.

Error: MISSING_LOCK:
drivers/net/wireless/iwlwifi/iwl-agn.c:3269: example_lock: Locking "priv->sta_lock".
drivers/net/wireless/iwlwifi/iwl-agn.c:3278: example_access: sta_id_modify.modify_mask is being accessed with lock "priv->sta_lock" held.
drivers/net/wireless/iwlwifi/iwl-rx.c:497: example_lock: Locking "priv->sta_lock".
drivers/net/wireless/iwlwifi/iwl-rx.c:499: example_access: sta_id_modify.modify_mask is being accessed with lock "priv->sta_lock" held.
drivers/net/wireless/iwlwifi/iwl-rx.c:519: example_lock: Locking "priv->sta_lock".
drivers/net/wireless/iwlwifi/iwl-rx.c:521: example_access: sta_id_modify.modify_mask is being accessed with lock "priv->sta_lock" held.
drivers/net/wireless/iwlwifi/iwl-rx.c:1010: example_lock: Locking "priv->sta_lock".
drivers/net/wireless/iwlwifi/iwl-rx.c:1013: example_access: sta_id_modify.modify_mask is being accessed with lock "priv->sta_lock" held.
drivers/net/wireless/iwlwifi/iwl-sta.c:1009: example_lock: Locking "priv->sta_lock".
drivers/net/wireless/iwlwifi/iwl-sta.c:1010: example_access: sta_id_modify.modify_mask is being accessed with lock "priv->sta_lock" held.
drivers/net/wireless/iwlwifi/iwl3945-base.c:1370: missing_lock: Accessing variable "priv->stations[sta_id].sta.sta.modify_mask" (sta_id_modify.modify_mask) requires the iwl_priv.sta_lock lock.

Error: MISSING_LOCK:
drivers/base/platform.c:553: example_lock: Locking "platform_bus_type.p->klist_drivers.k_lock".
drivers/base/platform.c:554: example_access: platform_driver.probe is being accessed with lock "platform_bus_type.p->klist_drivers.k_lock" held.
drivers/base/platform.c:545: missing_lock: Accessing variable "drv->probe" (platform_driver.probe) requires the klist.k_lock lock.

Error: MISSING_LOCK:
drivers/scsi/lpfc/lpfc_hbadisc.c:1143: example_lock: Locking "phba->hbalock".
drivers/scsi/lpfc/lpfc_hbadisc.c:1144: example_access: lpfc_sli.sli_flag is being accessed with lock "phba->hbalock" held.
drivers/scsi/lpfc/lpfc_hbadisc.c:874: example_lock: Locking "phba->hbalock".
drivers/scsi/lpfc/lpfc_hbadisc.c:875: example_access: lpfc_sli.sli_flag is being accessed with lock "phba->hbalock" held.
drivers/scsi/lpfc/lpfc_hbadisc.c:898: example_lock: Locking "phba->hbalock".
drivers/scsi/lpfc/lpfc_hbadisc.c:899: example_access: lpfc_sli.sli_flag is being accessed with lock "phba->hbalock" held.
drivers/scsi/lpfc/lpfc_init.c:1719: example_lock: Locking "phba->hbalock".
drivers/scsi/lpfc/lpfc_init.c:1720: example_access: lpfc_sli.sli_flag is being accessed with lock "phba->hbalock" held.
drivers/scsi/lpfc/lpfc_init.c:1797: example_lock: Locking "phba->hbalock".
drivers/scsi/lpfc/lpfc_init.c:1798: example_access: lpfc_sli.sli_flag is being accessed with lock "phba->hbalock" held.
drivers/scsi/lpfc/lpfc_sli.c:4032: missing_lock: Accessing variable "psli->sli_flag" (lpfc_sli.sli_flag) requires the lpfc_hba.hbalock lock.

Error: MISSING_LOCK:
drivers/usb/serial/garmin_gps.c:902: example_lock: Locking "garmin_data_p->lock".
drivers/usb/serial/garmin_gps.c:903: example_access: garmin_data.insize is being accessed with lock "garmin_data_p->lock" held.
drivers/usb/serial/garmin_gps.c:587: example_lock: Locking "garmin_data_p->lock".
drivers/usb/serial/garmin_gps.c:589: example_access: garmin_data.insize is being accessed with lock "garmin_data_p->lock" held.
drivers/usb/serial/garmin_gps.c:793: missing_lock: Accessing variable "garmin_data_p->insize" (garmin_data.insize) requires the garmin_data.lock lock.

Error: MISSING_LOCK:
drivers/usb/serial/garmin_gps.c:902: example_lock: Locking "garmin_data_p->lock".
drivers/usb/serial/garmin_gps.c:903: example_access: garmin_data.insize is being accessed with lock "garmin_data_p->lock" held.
drivers/usb/serial/garmin_gps.c:587: example_lock: Locking "garmin_data_p->lock".
drivers/usb/serial/garmin_gps.c:589: example_access: garmin_data.insize is being accessed with lock "garmin_data_p->lock" held.
drivers/usb/serial/garmin_gps.c:804: missing_lock: Accessing variable "garmin_data_p->insize" (garmin_data.insize) requires the garmin_data.lock lock.

Error: MISSING_LOCK:
drivers/usb/serial/garmin_gps.c:902: example_lock: Locking "garmin_data_p->lock".
drivers/usb/serial/garmin_gps.c:903: example_access: garmin_data.insize is being accessed with lock "garmin_data_p->lock" held.
drivers/usb/serial/garmin_gps.c:587: example_lock: Locking "garmin_data_p->lock".
drivers/usb/serial/garmin_gps.c:589: example_access: garmin_data.insize is being accessed with lock "garmin_data_p->lock" held.
drivers/usb/serial/garmin_gps.c:817: missing_lock: Accessing variable "garmin_data_p->insize" (garmin_data.insize) requires the garmin_data.lock lock.

Error: MISSING_LOCK:
drivers/net/lib8390.c:339: example_lock: Locking "ei_local->page_lock".
drivers/net/lib8390.c:341: example_access: ei_device.irqlock is being accessed with lock "ei_local->page_lock" held.
drivers/net/lib8390.c:339: example_lock: Locking "ei_local->page_lock".
drivers/net/lib8390.c:372: example_access: ei_device.irqlock is being accessed with lock "ei_local->page_lock" held.
drivers/net/lib8390.c:339: example_lock: Locking "ei_local->page_lock".
drivers/net/lib8390.c:413: example_access: ei_device.irqlock is being accessed with lock "ei_local->page_lock" held.
drivers/net/pcmcia/axnet_cs.c:1201: example_lock: Locking "ei_local->page_lock".
drivers/net/pcmcia/axnet_cs.c:1222: example_access: ei_device.irqlock is being accessed with lock "ei_local->page_lock" held.
drivers/net/pcmcia/axnet_cs.c:1201: example_lock: Locking "ei_local->page_lock".
drivers/net/pcmcia/axnet_cs.c:1283: example_access: ei_device.irqlock is being accessed with lock "ei_local->page_lock" held.
drivers/net/pcmcia/axnet_cs.c:978: missing_lock: Accessing variable "ei_local->irqlock" (ei_device.irqlock) requires the ei_device.page_lock lock.

Error: MISSING_LOCK:
drivers/scsi/lpfc/lpfc_ct.c:792: example_lock: Locking "shost->host_lock".
drivers/scsi/lpfc/lpfc_ct.c:793: example_access: lpfc_vport.fc_flag is being accessed with lock "shost->host_lock" held.
drivers/scsi/lpfc/lpfc_ct.c:668: example_lock: Locking "shost->host_lock".
drivers/scsi/lpfc/lpfc_ct.c:669: example_access: lpfc_vport.fc_flag is being accessed with lock "shost->host_lock" held.
drivers/scsi/lpfc/lpfc_els.c:108: example_lock: Locking "shost->host_lock".
drivers/scsi/lpfc/lpfc_els.c:109: example_access: lpfc_vport.fc_flag is being accessed with lock "shost->host_lock" held.
drivers/scsi/lpfc/lpfc_els.c:3770: example_lock: Locking "shost->host_lock".
drivers/scsi/lpfc/lpfc_els.c:3772: example_access: lpfc_vport.fc_flag is being accessed with lock "shost->host_lock" held.
drivers/scsi/lpfc/lpfc_els.c:1187: example_lock: Locking "shost->host_lock".
drivers/scsi/lpfc/lpfc_els.c:1188: example_access: lpfc_vport.fc_flag is being accessed with lock "shost->host_lock" held.
drivers/scsi/lpfc/lpfc_init.c:1978: missing_lock: Accessing variable "vport->fc_flag" (lpfc_vport.fc_flag) requires the Scsi_Host.host_lock lock.

Error: MISSING_LOCK:
drivers/isdn/mISDN/l1oip_core.c:340: example_lock: Locking "hc->socket_lock".
drivers/isdn/mISDN/l1oip_core.c:347: example_access: l1oip.socket is being accessed with lock "hc->socket_lock" held.
drivers/isdn/mISDN/l1oip_core.c:723: example_lock: Locking "hc->socket_lock".
drivers/isdn/mISDN/l1oip_core.c:724: example_access: l1oip.socket is being accessed with lock "hc->socket_lock" held.
drivers/isdn/mISDN/l1oip_core.c:753: example_lock: Locking "hc->socket_lock".
drivers/isdn/mISDN/l1oip_core.c:755: example_access: l1oip.socket is being accessed with lock "hc->socket_lock" held.
drivers/isdn/mISDN/l1oip_core.c:360: missing_lock: Accessing variable "hc->socket" (l1oip.socket) requires the l1oip.socket_lock lock.

Error: MISSING_LOCK:
drivers/input/serio/libps2.c:132: example_lock: Locking "ps2dev->serio->lock".
drivers/input/serio/libps2.c:133: example_access: ps2dev.flags is being accessed with lock "ps2dev->serio->lock" held.
drivers/input/serio/libps2.c:143: example_lock: Locking "ps2dev->serio->lock".
drivers/input/serio/libps2.c:144: example_access: ps2dev.flags is being accessed with lock "ps2dev->serio->lock" held.
drivers/input/serio/libps2.c:39: example_lock: Locking "ps2dev->serio->lock".
drivers/input/serio/libps2.c:41: example_access: ps2dev.flags is being accessed with lock "ps2dev->serio->lock" held.
drivers/input/serio/libps2.c:49: example_lock: Locking "ps2dev->serio->lock".
drivers/input/serio/libps2.c:50: example_access: ps2dev.flags is being accessed with lock "ps2dev->serio->lock" held.
drivers/input/serio/libps2.c:184: example_lock: Locking "ps2dev->serio->lock".
drivers/input/serio/libps2.c:185: example_access: ps2dev.flags is being accessed with lock "ps2dev->serio->lock" held.
drivers/input/serio/libps2.c:332: missing_lock: Accessing variable "ps2dev->flags" (ps2dev.flags) requires the serio.lock lock.

Error: MISSING_LOCK:
fs/jbd2/commit.c:257: example_lock: Locking "journal->j_list_lock".
fs/jbd2/commit.c:259: example_access: jbd2_inode.i_flags is being accessed with lock "journal->j_list_lock" held.
fs/jbd2/commit.c:274: example_lock: Locking "journal->j_list_lock".
fs/jbd2/commit.c:275: example_access: jbd2_inode.i_flags is being accessed with lock "journal->j_list_lock" held.
fs/jbd2/commit.c:222: example_lock: Locking "journal->j_list_lock".
fs/jbd2/commit.c:225: example_access: jbd2_inode.i_flags is being accessed with lock "journal->j_list_lock" held.
fs/jbd2/commit.c:236: example_lock: Locking "journal->j_list_lock".
fs/jbd2/commit.c:238: example_access: jbd2_inode.i_flags is being accessed with lock "journal->j_list_lock" held.
fs/jbd2/journal.c:2232: missing_lock: Accessing variable "jinode->i_flags" (jbd2_inode.i_flags) requires the journal_s.j_list_lock lock.

Error: MISSING_LOCK:
fs/jbd2/commit.c:257: example_lock: Locking "journal->j_list_lock".
fs/jbd2/commit.c:284: example_access: jbd2_inode.i_transaction is being accessed with lock "journal->j_list_lock" held.
fs/jbd2/commit.c:257: example_lock: Locking "journal->j_list_lock".
fs/jbd2/commit.c:289: example_access: jbd2_inode.i_transaction is being accessed with lock "journal->j_list_lock" held.
fs/jbd2/journal.c:2249: example_lock: Locking "journal->j_list_lock".
fs/jbd2/journal.c:2267: example_access: jbd2_inode.i_transaction is being accessed with lock "journal->j_list_lock" held.
fs/jbd2/transaction.c:2027: example_lock: Locking "journal->j_list_lock".
fs/jbd2/transaction.c:2044: example_access: jbd2_inode.i_transaction is being accessed with lock "journal->j_list_lock" held.
fs/jbd2/journal.c:2229: missing_lock: Accessing variable "jinode->i_transaction" (jbd2_inode.i_transaction) requires the journal_s.j_list_lock lock.

Error: MISSING_LOCK:
drivers/misc/sgi-xp/xpc_channel.c:43: example_lock: Locking "ch->lock".
drivers/misc/sgi-xp/xpc_channel.c:48: example_access: xpc_channel.flags is being accessed with lock "ch->lock" held.
drivers/misc/sgi-xp/xpc_channel.c:450: example_lock: Locking "ch->lock".
drivers/misc/sgi-xp/xpc_channel.c:498: example_access: xpc_channel.flags is being accessed with lock "ch->lock" held.
drivers/misc/sgi-xp/xpc_channel.c:450: example_lock: Locking "ch->lock".
drivers/misc/sgi-xp/xpc_channel.c:507: example_access: xpc_channel.flags is being accessed with lock "ch->lock" held.
drivers/misc/sgi-xp/xpc_channel.c:703: example_lock: Locking "ch->lock".
drivers/misc/sgi-xp/xpc_channel.c:706: example_access: xpc_channel.flags is being accessed with lock "ch->lock" held.
drivers/misc/sgi-xp/xpc_channel.c:190: example_lock: Locking "ch->lock".
drivers/misc/sgi-xp/xpc_channel.c:225: example_access: xpc_channel.flags is being accessed with lock "ch->lock" held.
drivers/misc/sgi-xp/xpc_main.c:513: missing_lock: Accessing variable "ch->flags" (xpc_channel.flags) requires the xpc_channel.lock lock.

Error: MISSING_LOCK:
drivers/block/ub.c:1847: example_lock: Locking "sc->lock".
drivers/block/ub.c:1848: example_access: ub_scsi_cmd.tag is being accessed with lock "sc->lock" held.
drivers/block/ub.c:1905: example_lock: Locking "sc->lock".
drivers/block/ub.c:1906: example_access: ub_scsi_cmd.tag is being accessed with lock "sc->lock" held.
drivers/block/ub.c:697: missing_lock: Accessing variable "cmd->tag" (ub_scsi_cmd.tag) requires the ub_dev.lock lock.

Error: MISSING_LOCK:
drivers/block/ub.c:1847: example_lock: Locking "sc->lock".
drivers/block/ub.c:1848: example_access: ub_dev.tagcnt is being accessed with lock "sc->lock" held.
drivers/block/ub.c:1905: example_lock: Locking "sc->lock".
drivers/block/ub.c:1906: example_access: ub_dev.tagcnt is being accessed with lock "sc->lock" held.
drivers/block/ub.c:697: missing_lock: Accessing variable "sc->tagcnt" (ub_dev.tagcnt) requires the ub_dev.lock lock.

Error: MISSING_LOCK:
sound/usb/usbaudio.c:451: example_lock: Locking "subs->lock".
sound/usb/usbaudio.c:452: example_access: snd_usb_substream.freqm is being accessed with lock "subs->lock" held.
sound/usb/usbaudio.c:477: example_lock: Locking "subs->lock".
sound/usb/usbaudio.c:478: example_access: snd_usb_substream.freqm is being accessed with lock "subs->lock" held.
sound/usb/usbaudio.c:504: example_lock: Locking "subs->lock".
sound/usb/usbaudio.c:505: example_access: snd_usb_substream.freqm is being accessed with lock "subs->lock" held.
sound/usb/usbaudio.c:1046: missing_lock: Accessing variable "subs->freqm" (snd_usb_substream.freqm) requires the snd_usb_substream.lock lock.

Error: MISSING_LOCK:
drivers/scsi/lpfc/lpfc_hbadisc.c:1143: example_lock: Locking "phba->hbalock".
drivers/scsi/lpfc/lpfc_hbadisc.c:1144: example_access: lpfc_sli.sli_flag is being accessed with lock "phba->hbalock" held.
drivers/scsi/lpfc/lpfc_hbadisc.c:874: example_lock: Locking "phba->hbalock".
drivers/scsi/lpfc/lpfc_hbadisc.c:875: example_access: lpfc_sli.sli_flag is being accessed with lock "phba->hbalock" held.
drivers/scsi/lpfc/lpfc_hbadisc.c:898: example_lock: Locking "phba->hbalock".
drivers/scsi/lpfc/lpfc_hbadisc.c:899: example_access: lpfc_sli.sli_flag is being accessed with lock "phba->hbalock" held.
drivers/scsi/lpfc/lpfc_init.c:1719: example_lock: Locking "phba->hbalock".
drivers/scsi/lpfc/lpfc_init.c:1720: example_access: lpfc_sli.sli_flag is being accessed with lock "phba->hbalock" held.
drivers/scsi/lpfc/lpfc_init.c:1797: example_lock: Locking "phba->hbalock".
drivers/scsi/lpfc/lpfc_init.c:1798: example_access: lpfc_sli.sli_flag is being accessed with lock "phba->hbalock" held.
drivers/scsi/lpfc/lpfc_mem.c:179: missing_lock: Accessing variable "psli->sli_flag" (lpfc_sli.sli_flag) requires the lpfc_hba.hbalock lock.

Error: MISSING_LOCK:
fs/jfs/jfs_logmgr.c:829: example_lock: Locking "log->gclock".
fs/jfs/jfs_logmgr.c:845: example_access: tblock.flag is being accessed with lock "log->gclock" held.
fs/jfs/jfs_logmgr.c:829: example_lock: Locking "log->gclock".
fs/jfs/jfs_logmgr.c:849: example_access: tblock.flag is being accessed with lock "log->gclock" held.
fs/jfs/jfs_logmgr.c:829: example_lock: Locking "log->gclock".
fs/jfs/jfs_logmgr.c:867: example_access: tblock.flag is being accessed with lock "log->gclock" held.
fs/jfs/jfs_logmgr.c:586: example_lock: Locking "log->gclock".
fs/jfs/jfs_logmgr.c:609: example_access: tblock.flag is being accessed with lock "log->gclock" held.
fs/jfs/jfs_logmgr.c:525: example_lock: Locking "log->gclock".
fs/jfs/jfs_logmgr.c:528: example_access: tblock.flag is being accessed with lock "log->gclock" held.
fs/jfs/jfs_txnmgr.c:2734: missing_lock: Accessing variable "tblk->flag" (tblock.flag) requires the jfs_log.gclock lock.

Error: MISSING_LOCK:
drivers/ide/ide-cd.c:509: example_lock: Locking "ide_lock".
drivers/ide/ide-cd.c:511: example_access: hwgroup_s.rq is being accessed with lock "ide_lock" held.
drivers/ide/ide-cd.c:1157: example_lock: Locking "ide_lock".
drivers/ide/ide-cd.c:1160: example_access: hwgroup_s.rq is being accessed with lock "ide_lock" held.
drivers/ide/ide-io.c:274: example_lock: Locking "ide_lock".
drivers/ide/ide-io.c:281: example_access: hwgroup_s.rq is being accessed with lock "ide_lock" held.
drivers/ide/ide-io.c:336: example_lock: Locking "ide_lock".
drivers/ide/ide-io.c:337: example_access: hwgroup_s.rq is being accessed with lock "ide_lock" held.
drivers/ide/ide-io.c:1494: example_lock: Locking "ide_lock".
drivers/ide/ide-io.c:1495: example_access: hwgroup_s.rq is being accessed with lock "ide_lock" held.
drivers/ide/ide-io.c:1158: missing_lock: Accessing variable "drive->hwif->hwgroup->rq" (hwgroup_s.rq) requires the ide_lock lock.

Error: MISSING_LOCK:
drivers/gpu/drm/drm_irq.c:473: example_lock: Locking "dev->vbl_lock".
drivers/gpu/drm/drm_irq.c:474: example_access: drm_device.vblank_disable_allowed is being accessed with lock "dev->vbl_lock" held.
drivers/gpu/drm/drm_irq.c:177: missing_lock: Accessing variable "dev->vblank_disable_allowed" (drm_device.vblank_disable_allowed) requires the drm_device.vbl_lock lock.

Error: MISSING_LOCK:
drivers/infiniband/ulp/ipoib/ipoib_cm.c:789: example_lock: Locking "dev->tx_global_lock".
drivers/infiniband/ulp/ipoib/ipoib_cm.c:791: example_access: ipoib_cm_tx.tx_tail is being accessed with lock "dev->tx_global_lock" held.
drivers/infiniband/ulp/ipoib/ipoib_cm.c:1182: missing_lock: Accessing variable "p->tx_tail" (ipoib_cm_tx.tx_tail) requires the net_device.tx_global_lock lock.

Error: MISSING_LOCK:
fs/ext4/mballoc.c:706: example_lock: Locking "EXT4_SB(sb)->s_bal_lock".
fs/ext4/mballoc.c:707: example_access: ext4_sb_info.s_mb_buddies_generated is being accessed with lock "EXT4_SB(sb)->s_bal_lock" held.
fs/ext4/mballoc.c:2621: missing_lock: Accessing variable "sbi->s_mb_buddies_generated" (ext4_sb_info.s_mb_buddies_generated) requires the ext4_sb_info.s_bal_lock lock.

Error: MISSING_LOCK:
drivers/scsi/libiscsi.c:2015: example_lock: Locking "ihost->lock".
drivers/scsi/libiscsi.c:2016: example_access: iscsi_host.num_sessions is being accessed with lock "ihost->lock" held.
drivers/scsi/libiscsi.c:2049: example_lock: Locking "ihost->lock".
drivers/scsi/libiscsi.c:2054: example_access: iscsi_host.num_sessions is being accessed with lock "ihost->lock" held.
drivers/scsi/libiscsi.c:1954: missing_lock: Accessing variable "ihost->num_sessions" (iscsi_host.num_sessions) requires the iscsi_host.lock lock.

Error: MISSING_LOCK:
drivers/scsi/libiscsi.c:1977: example_lock: Locking "ihost->lock".
drivers/scsi/libiscsi.c:1978: example_access: iscsi_host.state is being accessed with lock "ihost->lock" held.
drivers/scsi/libiscsi.c:1953: missing_lock: Accessing variable "ihost->state" (iscsi_host.state) requires the iscsi_host.lock lock.

Error: MISSING_LOCK:
drivers/scsi/aacraid/commsup.c:497: example_lock: Locking "q->lock".
drivers/scsi/aacraid/commsup.c:498: example_access: aac_queue.numpending is being accessed with lock "q->lock" held.
drivers/scsi/aacraid/dpcsup.c:62: example_lock: Locking "q->lock".
drivers/scsi/aacraid/dpcsup.c:86: example_access: aac_queue.numpending is being accessed with lock "q->lock" held.
drivers/scsi/aacraid/rx.c:416: example_lock: Locking "q->lock".
drivers/scsi/aacraid/rx.c:417: example_access: aac_queue.numpending is being accessed with lock "q->lock" held.
drivers/scsi/aacraid/rx.c:426: example_lock: Locking "q->lock".
drivers/scsi/aacraid/rx.c:427: example_access: aac_queue.numpending is being accessed with lock "q->lock" held.
drivers/scsi/aacraid/rx.c:388: example_lock: Locking "q->lock".
drivers/scsi/aacraid/rx.c:391: example_access: aac_queue.numpending is being accessed with lock "q->lock" held.
drivers/scsi/aacraid/dpcsup.c:283: missing_lock: Accessing variable "dev->queues->queue[2].numpending" (aac_queue.numpending) requires the aac_queue.lock lock.

Error: MISSING_LOCK:
fs/nfsd/nfscache.c:138: example_lock: Locking "cache_lock".
fs/nfsd/nfscache.c:181: example_access: svc_cacherep.c_state is being accessed with lock "cache_lock" held.
fs/nfsd/nfscache.c:138: example_lock: Locking "cache_lock".
fs/nfsd/nfscache.c:233: example_access: svc_cacherep.c_state is being accessed with lock "cache_lock" held.
fs/nfsd/nfscache.c:284: example_lock: Locking "cache_lock".
fs/nfsd/nfscache.c:285: example_access: svc_cacherep.c_state is being accessed with lock "cache_lock" held.
fs/nfsd/nfscache.c:293: example_lock: Locking "cache_lock".
fs/nfsd/nfscache.c:297: example_access: svc_cacherep.c_state is being accessed with lock "cache_lock" held.
fs/nfsd/nfscache.c:270: missing_lock: Accessing variable "rp->c_state" (svc_cacherep.c_state) requires the cache_lock lock.

Error: MISSING_LOCK:
drivers/net/wireless/iwlwifi/iwl-sta.c:654: example_lock: Locking "priv->sta_lock".
drivers/net/wireless/iwlwifi/iwl-sta.c:655: example_access: iwl_hw_key.alg is being accessed with lock "priv->sta_lock" held.
drivers/net/wireless/iwlwifi/iwl-sta.c:695: example_lock: Locking "priv->sta_lock".
drivers/net/wireless/iwlwifi/iwl-sta.c:697: example_access: iwl_hw_key.alg is being accessed with lock "priv->sta_lock" held.
drivers/net/wireless/iwlwifi/iwl-sta.c:604: example_lock: Locking "priv->sta_lock".
drivers/net/wireless/iwlwifi/iwl-sta.c:606: example_access: iwl_hw_key.alg is being accessed with lock "priv->sta_lock" held.
drivers/net/wireless/iwlwifi/iwl-sta.c:562: missing_lock: Accessing variable "priv->stations[0].keyinfo.alg" (iwl_hw_key.alg) requires the iwl_priv.sta_lock lock.

Error: MISSING_LOCK:
drivers/net/wireless/orinoco.c:3466: example_lock: Locking "priv->lock".
drivers/net/wireless/orinoco.c:3467: example_access: orinoco_private.hw_unavailable is being accessed with lock "priv->lock" held.
drivers/net/wireless/orinoco.c:2942: example_lock: Locking "priv->lock".
drivers/net/wireless/orinoco.c:2944: example_access: orinoco_private.hw_unavailable is being accessed with lock "priv->lock" held.
drivers/net/wireless/orinoco_cs.c:338: example_lock: Locking "priv->lock".
drivers/net/wireless/orinoco_cs.c:339: example_access: orinoco_private.hw_unavailable is being accessed with lock "priv->lock" held.
drivers/net/wireless/orinoco_cs.c:391: example_lock: Locking "priv->lock".
drivers/net/wireless/orinoco_cs.c:394: example_access: orinoco_private.hw_unavailable is being accessed with lock "priv->lock" held.
drivers/net/wireless/orinoco_cs.c:359: example_lock: Locking "priv->lock".
drivers/net/wireless/orinoco_cs.c:367: example_access: orinoco_private.hw_unavailable is being accessed with lock "priv->lock" held.
drivers/net/wireless/orinoco.c:3524: missing_lock: Accessing variable "priv->hw_unavailable" (orinoco_private.hw_unavailable) requires the orinoco_private.lock lock.

Error: MISSING_LOCK:
drivers/usb/gadget/printer.c:571: example_lock: Locking "dev->lock".
drivers/usb/gadget/printer.c:576: example_access: printer_dev.reset_printer is being accessed with lock "dev->lock" held.
drivers/usb/gadget/printer.c:701: example_lock: Locking "dev->lock".
drivers/usb/gadget/printer.c:704: example_access: printer_dev.reset_printer is being accessed with lock "dev->lock" held.
drivers/usb/gadget/printer.c:1094: missing_lock: Accessing variable "dev->reset_printer" (printer_dev.reset_printer) requires the printer_dev.lock lock.

Error: MISSING_LOCK:
drivers/infiniband/hw/nes/nes_hw.c:1173: example_lock: Locking "nesdev->cqp.lock".
drivers/infiniband/hw/nes/nes_hw.c:1176: example_access: nes_hw_cqp.sq_head is being accessed with lock "nesdev->cqp.lock" held.
drivers/infiniband/hw/nes/nes_hw.c:1173: example_lock: Locking "nesdev->cqp.lock".
drivers/infiniband/hw/nes/nes_hw.c:1177: example_access: nes_hw_cqp.sq_head is being accessed with lock "nesdev->cqp.lock" held.
drivers/infiniband/hw/nes/nes_hw.c:1173: example_lock: Locking "nesdev->cqp.lock".
drivers/infiniband/hw/nes/nes_hw.c:1184: example_access: nes_hw_cqp.sq_head is being accessed with lock "nesdev->cqp.lock" held.
drivers/infiniband/hw/nes/nes_hw.c:1173: example_lock: Locking "nesdev->cqp.lock".
drivers/infiniband/hw/nes/nes_hw.c:1185: example_access: nes_hw_cqp.sq_head is being accessed with lock "nesdev->cqp.lock" held.
drivers/infiniband/hw/nes/nes_hw.c:1173: example_lock: Locking "nesdev->cqp.lock".
drivers/infiniband/hw/nes/nes_hw.c:1191: example_access: nes_hw_cqp.sq_head is being accessed with lock "nesdev->cqp.lock" held.
drivers/infiniband/hw/nes/nes_hw.c:982: missing_lock: Accessing variable "nesdev->cqp.sq_head" (nes_hw_cqp.sq_head) requires the nes_hw_cqp.lock lock.

Error: MISSING_LOCK:
drivers/net/wireless/iwlwifi/iwl-agn.c:3269: example_lock: Locking "priv->sta_lock".
drivers/net/wireless/iwlwifi/iwl-agn.c:3278: example_access: sta_id_modify.modify_mask is being accessed with lock "priv->sta_lock" held.
drivers/net/wireless/iwlwifi/iwl-rx.c:497: example_lock: Locking "priv->sta_lock".
drivers/net/wireless/iwlwifi/iwl-rx.c:499: example_access: sta_id_modify.modify_mask is being accessed with lock "priv->sta_lock" held.
drivers/net/wireless/iwlwifi/iwl-rx.c:519: example_lock: Locking "priv->sta_lock".
drivers/net/wireless/iwlwifi/iwl-rx.c:521: example_access: sta_id_modify.modify_mask is being accessed with lock "priv->sta_lock" held.
drivers/net/wireless/iwlwifi/iwl-rx.c:1010: example_lock: Locking "priv->sta_lock".
drivers/net/wireless/iwlwifi/iwl-rx.c:1013: example_access: sta_id_modify.modify_mask is being accessed with lock "priv->sta_lock" held.
drivers/net/wireless/iwlwifi/iwl-sta.c:1009: example_lock: Locking "priv->sta_lock".
drivers/net/wireless/iwlwifi/iwl-sta.c:1010: example_access: sta_id_modify.modify_mask is being accessed with lock "priv->sta_lock" held.
drivers/net/wireless/iwlwifi/iwl3945-base.c:1388: missing_lock: Accessing variable "priv->stations[sta_id].sta.sta.modify_mask" (sta_id_modify.modify_mask) requires the iwl_priv.sta_lock lock.

Error: MISSING_LOCK:
arch/x86/kernel/io_apic.c:2184: example_lock: Locking "desc->lock".
arch/x86/kernel/io_apic.c:2187: example_access: irq_desc.status is being accessed with lock "desc->lock" held.
kernel/irq/autoprobe.c:169: example_lock: Locking "desc->lock".
kernel/irq/autoprobe.c:178: example_access: irq_desc.status is being accessed with lock "desc->lock" held.
kernel/irq/autoprobe.c:71: example_lock: Locking "desc->lock".
kernel/irq/autoprobe.c:73: example_access: irq_desc.status is being accessed with lock "desc->lock" held.
kernel/irq/autoprobe.c:71: example_lock: Locking "desc->lock".
kernel/irq/autoprobe.c:75: example_access: irq_desc.status is being accessed with lock "desc->lock" held.
kernel/irq/autoprobe.c:89: example_lock: Locking "desc->lock".
kernel/irq/autoprobe.c:95: example_access: irq_desc.status is being accessed with lock "desc->lock" held.
arch/x86/kernel/io_apic.c:3187: missing_lock: Accessing variable "desc->status" (irq_desc.status) requires the irq_desc.lock lock.

Error: MISSING_LOCK:
drivers/ieee1394/raw1394.c:1167: example_lock: Locking "host_info_lock".
drivers/ieee1394/raw1394.c:1319: example_access: raw1394_request.misc is being accessed with lock "host_info_lock" held.
drivers/ieee1394/raw1394.c:1392: example_lock: Locking "host_info_lock".
drivers/ieee1394/raw1394.c:1547: example_access: raw1394_request.misc is being accessed with lock "host_info_lock" held.
drivers/ieee1394/raw1394.c:866: example_lock: Locking "host_info_lock".
drivers/ieee1394/raw1394.c:949: example_access: raw1394_request.misc is being accessed with lock "host_info_lock" held.
drivers/ieee1394/raw1394.c:1020: example_lock: Locking "host_info_lock".
drivers/ieee1394/raw1394.c:1094: example_access: raw1394_request.misc is being accessed with lock "host_info_lock" held.
drivers/ieee1394/raw1394.c:301: example_lock: Locking "host_info_lock".
drivers/ieee1394/raw1394.c:334: example_access: raw1394_request.misc is being accessed with lock "host_info_lock" held.
drivers/ieee1394/raw1394.c:511: missing_lock: Accessing variable "req->req.misc" (raw1394_request.misc) requires the host_info_lock lock.

Error: MISSING_LOCK:
drivers/serial/8250.c:2082: example_lock: Locking "up->port.lock".
drivers/serial/8250.c:2086: example_access: uart_port.mctrl is being accessed with lock "up->port.lock" held.
drivers/serial/8250.c:2082: example_lock: Locking "up->port.lock".
drivers/serial/8250.c:2088: example_access: uart_port.mctrl is being accessed with lock "up->port.lock" held.
drivers/serial/8250.c:2004: example_lock: Locking "up->port.lock".
drivers/serial/8250.c:2007: example_access: uart_port.mctrl is being accessed with lock "up->port.lock" held.
drivers/serial/8250.c:2004: example_lock: Locking "up->port.lock".
drivers/serial/8250.c:2013: example_access: uart_port.mctrl is being accessed with lock "up->port.lock" held.
drivers/serial/serial_core.c:125: example_lock: Locking "port->lock".
drivers/serial/serial_core.c:127: example_access: uart_port.mctrl is being accessed with lock "port->lock" held.
drivers/serial/serial_core.c:1967: missing_lock: Accessing variable "port->mctrl" (uart_port.mctrl) requires the uart_port.lock lock.

Error: MISSING_LOCK:
net/ipv4/inet_timewait_sock.c:305: example_lock: Locking "twdr->death_lock".
net/ipv4/inet_timewait_sock.c:309: example_access: inet_timewait_death_row.tw_count is being accessed with lock "twdr->death_lock" held.
net/ipv4/inet_timewait_sock.c:305: example_lock: Locking "twdr->death_lock".
net/ipv4/inet_timewait_sock.c:346: example_access: inet_timewait_death_row.tw_count is being accessed with lock "twdr->death_lock" held.
net/ipv4/inet_timewait_sock.c:260: example_lock: Locking "twdr->death_lock".
net/ipv4/inet_timewait_sock.c:263: example_access: inet_timewait_death_row.tw_count is being accessed with lock "twdr->death_lock" held.
net/ipv4/inet_timewait_sock.c:364: example_lock: Locking "twdr->death_lock".
net/ipv4/inet_timewait_sock.c:404: example_access: inet_timewait_death_row.tw_count is being accessed with lock "twdr->death_lock" held.
net/ipv4/inet_timewait_sock.c:184: missing_lock: Accessing variable "twdr->tw_count" (inet_timewait_death_row.tw_count) requires the inet_timewait_death_row.death_lock lock.

Error: MISSING_LOCK:
drivers/scsi/initio.c:720: example_lock: Locking "host->avail_lock".
drivers/scsi/initio.c:721: example_access: scsi_ctrl_blk.srb is being accessed with lock "host->avail_lock" held.
drivers/scsi/initio.c:2572: missing_lock: Accessing variable "cblk->srb" (scsi_ctrl_blk.srb) requires the initio_host.avail_lock lock.

Error: MISSING_LOCK:
drivers/scsi/lpfc/lpfc_els.c:1817: example_lock: Locking "shost->host_lock".
drivers/scsi/lpfc/lpfc_els.c:1818: example_access: lpfc_nodelist.nlp_flag is being accessed with lock "shost->host_lock" held.
drivers/scsi/lpfc/lpfc_els.c:1821: example_lock: Locking "shost->host_lock".
drivers/scsi/lpfc/lpfc_els.c:1822: example_access: lpfc_nodelist.nlp_flag is being accessed with lock "shost->host_lock" held.
drivers/scsi/lpfc/lpfc_els.c:2253: example_lock: Locking "shost->host_lock".
drivers/scsi/lpfc/lpfc_els.c:2254: example_access: lpfc_nodelist.nlp_flag is being accessed with lock "shost->host_lock" held.
drivers/scsi/lpfc/lpfc_els.c:2265: example_lock: Locking "shost->host_lock".
drivers/scsi/lpfc/lpfc_els.c:2266: example_access: lpfc_nodelist.nlp_flag is being accessed with lock "shost->host_lock" held.
drivers/scsi/lpfc/lpfc_els.c:3656: example_lock: Locking "shost->host_lock".
drivers/scsi/lpfc/lpfc_els.c:3657: example_access: lpfc_nodelist.nlp_flag is being accessed with lock "shost->host_lock" held.
drivers/scsi/lpfc/lpfc_nportdisc.c:581: missing_lock: Accessing variable "ndlp->nlp_flag" (lpfc_nodelist.nlp_flag) requires the Scsi_Host.host_lock lock.

Error: MISSING_LOCK:
drivers/scsi/lpfc/lpfc_els.c:1817: example_lock: Locking "shost->host_lock".
drivers/scsi/lpfc/lpfc_els.c:1818: example_access: lpfc_nodelist.nlp_flag is being accessed with lock "shost->host_lock" held.
drivers/scsi/lpfc/lpfc_els.c:1821: example_lock: Locking "shost->host_lock".
drivers/scsi/lpfc/lpfc_els.c:1822: example_access: lpfc_nodelist.nlp_flag is being accessed with lock "shost->host_lock" held.
drivers/scsi/lpfc/lpfc_els.c:2253: example_lock: Locking "shost->host_lock".
drivers/scsi/lpfc/lpfc_els.c:2254: example_access: lpfc_nodelist.nlp_flag is being accessed with lock "shost->host_lock" held.
drivers/scsi/lpfc/lpfc_els.c:2265: example_lock: Locking "shost->host_lock".
drivers/scsi/lpfc/lpfc_els.c:2266: example_access: lpfc_nodelist.nlp_flag is being accessed with lock "shost->host_lock" held.
drivers/scsi/lpfc/lpfc_els.c:3656: example_lock: Locking "shost->host_lock".
drivers/scsi/lpfc/lpfc_els.c:3657: example_access: lpfc_nodelist.nlp_flag is being accessed with lock "shost->host_lock" held.
drivers/scsi/lpfc/lpfc_nportdisc.c:595: missing_lock: Accessing variable "ndlp->nlp_flag" (lpfc_nodelist.nlp_flag) requires the Scsi_Host.host_lock lock.

Error: MISSING_LOCK:
drivers/net/skge.c:2698: example_lock: Locking "hw->hw_lock".
drivers/net/skge.c:2699: example_access: skge_hw.intr_mask is being accessed with lock "hw->hw_lock" held.
drivers/net/skge.c:2651: example_lock: Locking "hw->hw_lock".
drivers/net/skge.c:2652: example_access: skge_hw.intr_mask is being accessed with lock "hw->hw_lock" held.
drivers/net/skge.c:3353: example_lock: Locking "hw->hw_lock".
drivers/net/skge.c:3354: example_access: skge_hw.intr_mask is being accessed with lock "hw->hw_lock" held.
drivers/net/skge.c:3366: example_lock: Locking "hw->hw_lock".
drivers/net/skge.c:3375: example_access: skge_hw.intr_mask is being accessed with lock "hw->hw_lock" held.
drivers/net/skge.c:3366: example_lock: Locking "hw->hw_lock".
drivers/net/skge.c:3381: example_access: skge_hw.intr_mask is being accessed with lock "hw->hw_lock" held.
drivers/net/skge.c:3588: missing_lock: Accessing variable "hw->intr_mask" (skge_hw.intr_mask) requires the skge_hw.hw_lock lock.

Error: MISSING_LOCK:
drivers/net/skge.c:2698: example_lock: Locking "hw->hw_lock".
drivers/net/skge.c:2699: example_access: skge_hw.intr_mask is being accessed with lock "hw->hw_lock" held.
drivers/net/skge.c:2651: example_lock: Locking "hw->hw_lock".
drivers/net/skge.c:2652: example_access: skge_hw.intr_mask is being accessed with lock "hw->hw_lock" held.
drivers/net/skge.c:3353: example_lock: Locking "hw->hw_lock".
drivers/net/skge.c:3354: example_access: skge_hw.intr_mask is being accessed with lock "hw->hw_lock" held.
drivers/net/skge.c:3366: example_lock: Locking "hw->hw_lock".
drivers/net/skge.c:3375: example_access: skge_hw.intr_mask is being accessed with lock "hw->hw_lock" held.
drivers/net/skge.c:3366: example_lock: Locking "hw->hw_lock".
drivers/net/skge.c:3381: example_access: skge_hw.intr_mask is being accessed with lock "hw->hw_lock" held.
drivers/net/skge.c:3592: missing_lock: Accessing variable "hw->intr_mask" (skge_hw.intr_mask) requires the skge_hw.hw_lock lock.

Error: MISSING_LOCK:
drivers/net/skge.c:2698: example_lock: Locking "hw->hw_lock".
drivers/net/skge.c:2699: example_access: skge_hw.intr_mask is being accessed with lock "hw->hw_lock" held.
drivers/net/skge.c:2651: example_lock: Locking "hw->hw_lock".
drivers/net/skge.c:2652: example_access: skge_hw.intr_mask is being accessed with lock "hw->hw_lock" held.
drivers/net/skge.c:3353: example_lock: Locking "hw->hw_lock".
drivers/net/skge.c:3354: example_access: skge_hw.intr_mask is being accessed with lock "hw->hw_lock" held.
drivers/net/skge.c:3366: example_lock: Locking "hw->hw_lock".
drivers/net/skge.c:3375: example_access: skge_hw.intr_mask is being accessed with lock "hw->hw_lock" held.
drivers/net/skge.c:3366: example_lock: Locking "hw->hw_lock".
drivers/net/skge.c:3381: example_access: skge_hw.intr_mask is being accessed with lock "hw->hw_lock" held.
drivers/net/skge.c:3605: missing_lock: Accessing variable "hw->intr_mask" (skge_hw.intr_mask) requires the skge_hw.hw_lock lock.

Error: MISSING_LOCK:
drivers/scsi/lpfc/lpfc_scsi.c:966: example_lock: Locking "sdev->host->host_lock".
drivers/scsi/lpfc/lpfc_scsi.c:967: example_access: lpfc_scsi_buf.pCmd is being accessed with lock "sdev->host->host_lock" held.
drivers/scsi/lpfc/lpfc_scsi.c:1043: example_lock: Locking "sdev->host->host_lock".
drivers/scsi/lpfc/lpfc_scsi.c:1044: example_access: lpfc_scsi_buf.pCmd is being accessed with lock "sdev->host->host_lock" held.
drivers/scsi/lpfc/lpfc_scsi.c:478: missing_lock: Accessing variable "psb->pCmd" (lpfc_scsi_buf.pCmd) requires the Scsi_Host.host_lock lock.

Error: MISSING_LOCK:
fs/ntfs/attrib.c:1712: example_lock: Locking "ni->size_lock".
fs/ntfs/attrib.c:1713: example_access: _ntfs_inode.allocated_size is being accessed with lock "ni->size_lock" held.
fs/ntfs/attrib.c:1813: example_lock: Locking "ni->size_lock".
fs/ntfs/attrib.c:1814: example_access: _ntfs_inode.allocated_size is being accessed with lock "ni->size_lock" held.
fs/ntfs/attrib.c:2055: example_lock: Locking "ni->size_lock".
fs/ntfs/attrib.c:2056: example_access: _ntfs_inode.allocated_size is being accessed with lock "ni->size_lock" held.
fs/ntfs/attrib.c:2337: example_lock: Locking "ni->size_lock".
fs/ntfs/attrib.c:2338: example_access: _ntfs_inode.allocated_size is being accessed with lock "ni->size_lock" held.
fs/ntfs/attrib.c:2391: example_lock: Locking "ni->size_lock".
fs/ntfs/attrib.c:2392: example_access: _ntfs_inode.allocated_size is being accessed with lock "ni->size_lock" held.
fs/ntfs/inode.c:2075: missing_lock: Accessing variable "ni->allocated_size" (_ntfs_inode.allocated_size) requires the _ntfs_inode.size_lock lock.

Error: MISSING_LOCK:
fs/ntfs/attrib.c:1794: example_lock: Locking "ni->size_lock".
fs/ntfs/attrib.c:1795: example_access: _ntfs_inode.initialized_size is being accessed with lock "ni->size_lock" held.
fs/ntfs/file.c:181: example_lock: Locking "ni->size_lock".
fs/ntfs/file.c:183: example_access: _ntfs_inode.initialized_size is being accessed with lock "ni->size_lock" held.
fs/ntfs/file.c:248: example_lock: Locking "ni->size_lock".
fs/ntfs/file.c:249: example_access: _ntfs_inode.initialized_size is being accessed with lock "ni->size_lock" held.
fs/ntfs/file.c:248: example_lock: Locking "ni->size_lock".
fs/ntfs/file.c:251: example_access: _ntfs_inode.initialized_size is being accessed with lock "ni->size_lock" held.
fs/ntfs/file.c:323: example_lock: Locking "ni->size_lock".
fs/ntfs/file.c:324: example_access: _ntfs_inode.initialized_size is being accessed with lock "ni->size_lock" held.
fs/ntfs/inode.c:2073: missing_lock: Accessing variable "ni->initialized_size" (_ntfs_inode.initialized_size) requires the _ntfs_inode.size_lock lock.

Error: MISSING_LOCK:
mm/pdflush.c:208: example_lock: Locking "pdflush_lock".
mm/pdflush.c:218: example_access: pdflush_work.fn is being accessed with lock "pdflush_lock" held.
mm/pdflush.c:111: example_lock: Locking "pdflush_lock".
mm/pdflush.c:118: example_access: pdflush_work.fn is being accessed with lock "pdflush_lock" held.
mm/pdflush.c:142: example_lock: Locking "pdflush_lock".
mm/pdflush.c:143: example_access: pdflush_work.fn is being accessed with lock "pdflush_lock" held.
mm/pdflush.c:96: missing_lock: Accessing variable "my_work->fn" (pdflush_work.fn) requires the pdflush_lock lock.

Error: MISSING_LOCK:
drivers/char/riscom8.c:992: example_lock: Locking "riscom_lock".
drivers/char/riscom8.c:993: example_access: riscom_port.xmit_cnt is being accessed with lock "riscom_lock" held.
drivers/char/riscom8.c:792: example_lock: Locking "riscom_lock".
drivers/char/riscom8.c:797: example_access: riscom_port.xmit_cnt is being accessed with lock "riscom_lock" held.
drivers/char/riscom8.c:1132: example_lock: Locking "riscom_lock".
drivers/char/riscom8.c:1139: example_access: riscom_port.xmit_cnt is being accessed with lock "riscom_lock" held.
drivers/char/riscom8.c:1093: example_lock: Locking "riscom_lock".
drivers/char/riscom8.c:1102: example_access: riscom_port.xmit_cnt is being accessed with lock "riscom_lock" held.
drivers/char/riscom8.c:472: missing_lock: Accessing variable "port->xmit_cnt" (riscom_port.xmit_cnt) requires the riscom_lock lock.

Error: MISSING_LOCK:
drivers/infiniband/ulp/srp/ib_srp.c:545: example_lock: Locking "target->scsi_host->host_lock".
drivers/infiniband/ulp/srp/ib_srp.c:550: example_access: srp_target_port.state is being accessed with lock "target->scsi_host->host_lock" held.
drivers/infiniband/ulp/srp/ib_srp.c:588: example_lock: Locking "target->scsi_host->host_lock".
drivers/infiniband/ulp/srp/ib_srp.c:591: example_access: srp_target_port.state is being accessed with lock "target->scsi_host->host_lock" held.
drivers/infiniband/ulp/srp/ib_srp.c:608: example_lock: Locking "target->scsi_host->host_lock".
drivers/infiniband/ulp/srp/ib_srp.c:610: example_access: srp_target_port.state is being accessed with lock "target->scsi_host->host_lock" held.
drivers/infiniband/ulp/srp/ib_srp.c:2108: example_lock: Locking "target->scsi_host->host_lock".
drivers/infiniband/ulp/srp/ib_srp.c:2109: example_access: srp_target_port.state is being accessed with lock "target->scsi_host->host_lock" held.
drivers/infiniband/ulp/srp/ib_srp.c:432: example_lock: Locking "target->scsi_host->host_lock".
drivers/infiniband/ulp/srp/ib_srp.c:437: example_access: srp_target_port.state is being accessed with lock "target->scsi_host->host_lock" held.
drivers/infiniband/ulp/srp/ib_srp.c:1639: missing_lock: Accessing variable "target->state" (srp_target_port.state) requires the Scsi_Host.host_lock lock.

Error: MISSING_LOCK:
mm/hugetlb.c:692: example_lock: Locking "hugetlb_lock".
mm/hugetlb.c:697: example_access: hstate.nr_huge_pages is being accessed with lock "hugetlb_lock" held.
mm/hugetlb.c:711: example_lock: Locking "hugetlb_lock".
mm/hugetlb.c:728: example_access: hstate.nr_huge_pages is being accessed with lock "hugetlb_lock" held.
mm/hugetlb.c:586: example_lock: Locking "hugetlb_lock".
mm/hugetlb.c:587: example_access: hstate.nr_huge_pages is being accessed with lock "hugetlb_lock" held.
mm/hugetlb.c:1380: missing_lock: Accessing variable "h->nr_huge_pages" (hstate.nr_huge_pages) requires the hugetlb_lock lock.

Error: MISSING_LOCK:
drivers/isdn/gigaset/common.c:857: example_lock: Locking "cs->lock".
drivers/isdn/gigaset/common.c:858: example_access: cardstate.connected is being accessed with lock "cs->lock" held.
drivers/isdn/gigaset/ev-layer.c:1038: example_lock: Locking "cs->lock".
drivers/isdn/gigaset/ev-layer.c:1039: example_access: cardstate.connected is being accessed with lock "cs->lock" held.
drivers/isdn/gigaset/usb-gigaset.c:865: missing_lock: Accessing variable "cs->connected" (cardstate.connected) requires the cardstate.lock lock.

Error: MISSING_LOCK:
drivers/input/serio/libps2.c:132: example_lock: Locking "ps2dev->serio->lock".
drivers/input/serio/libps2.c:133: example_access: ps2dev.flags is being accessed with lock "ps2dev->serio->lock" held.
drivers/input/serio/libps2.c:143: example_lock: Locking "ps2dev->serio->lock".
drivers/input/serio/libps2.c:144: example_access: ps2dev.flags is being accessed with lock "ps2dev->serio->lock" held.
drivers/input/serio/libps2.c:39: example_lock: Locking "ps2dev->serio->lock".
drivers/input/serio/libps2.c:41: example_access: ps2dev.flags is being accessed with lock "ps2dev->serio->lock" held.
drivers/input/serio/libps2.c:49: example_lock: Locking "ps2dev->serio->lock".
drivers/input/serio/libps2.c:50: example_access: ps2dev.flags is being accessed with lock "ps2dev->serio->lock" held.
drivers/input/serio/libps2.c:184: example_lock: Locking "ps2dev->serio->lock".
drivers/input/serio/libps2.c:185: example_access: ps2dev.flags is being accessed with lock "ps2dev->serio->lock" held.
drivers/input/serio/libps2.c:286: missing_lock: Accessing variable "ps2dev->flags" (ps2dev.flags) requires the serio.lock lock.

Error: MISSING_LOCK:
drivers/input/serio/libps2.c:132: example_lock: Locking "ps2dev->serio->lock".
drivers/input/serio/libps2.c:133: example_access: ps2dev.flags is being accessed with lock "ps2dev->serio->lock" held.
drivers/input/serio/libps2.c:143: example_lock: Locking "ps2dev->serio->lock".
drivers/input/serio/libps2.c:144: example_access: ps2dev.flags is being accessed with lock "ps2dev->serio->lock" held.
drivers/input/serio/libps2.c:39: example_lock: Locking "ps2dev->serio->lock".
drivers/input/serio/libps2.c:41: example_access: ps2dev.flags is being accessed with lock "ps2dev->serio->lock" held.
drivers/input/serio/libps2.c:49: example_lock: Locking "ps2dev->serio->lock".
drivers/input/serio/libps2.c:50: example_access: ps2dev.flags is being accessed with lock "ps2dev->serio->lock" held.
drivers/input/serio/libps2.c:184: example_lock: Locking "ps2dev->serio->lock".
drivers/input/serio/libps2.c:185: example_access: ps2dev.flags is being accessed with lock "ps2dev->serio->lock" held.
drivers/input/serio/libps2.c:288: missing_lock: Accessing variable "ps2dev->flags" (ps2dev.flags) requires the serio.lock lock.

Error: MISSING_LOCK:
drivers/scsi/lpfc/lpfc_ct.c:792: example_lock: Locking "shost->host_lock".
drivers/scsi/lpfc/lpfc_ct.c:793: example_access: lpfc_vport.fc_flag is being accessed with lock "shost->host_lock" held.
drivers/scsi/lpfc/lpfc_ct.c:668: example_lock: Locking "shost->host_lock".
drivers/scsi/lpfc/lpfc_ct.c:669: example_access: lpfc_vport.fc_flag is being accessed with lock "shost->host_lock" held.
drivers/scsi/lpfc/lpfc_els.c:108: example_lock: Locking "shost->host_lock".
drivers/scsi/lpfc/lpfc_els.c:109: example_access: lpfc_vport.fc_flag is being accessed with lock "shost->host_lock" held.
drivers/scsi/lpfc/lpfc_els.c:3770: example_lock: Locking "shost->host_lock".
drivers/scsi/lpfc/lpfc_els.c:3772: example_access: lpfc_vport.fc_flag is being accessed with lock "shost->host_lock" held.
drivers/scsi/lpfc/lpfc_els.c:1187: example_lock: Locking "shost->host_lock".
drivers/scsi/lpfc/lpfc_els.c:1188: example_access: lpfc_vport.fc_flag is being accessed with lock "shost->host_lock" held.
drivers/scsi/lpfc/lpfc_vport.c:501: missing_lock: Accessing variable "vport->fc_flag" (lpfc_vport.fc_flag) requires the Scsi_Host.host_lock lock.

Error: MISSING_LOCK:
drivers/scsi/lpfc/lpfc_sli.c:2134: example_lock: Locking "phba->hbalock".
drivers/scsi/lpfc/lpfc_sli.c:2135: example_access: lpfc_sli_ring_stat.iocb_event is being accessed with lock "phba->hbalock" held.
drivers/scsi/lpfc/lpfc_sli.c:1939: example_lock: Locking "phba->hbalock".
drivers/scsi/lpfc/lpfc_sli.c:1940: example_access: lpfc_sli_ring_stat.iocb_event is being accessed with lock "phba->hbalock" held.
drivers/scsi/lpfc/lpfc_sli.c:1774: missing_lock: Accessing variable "pring->stats.iocb_event" (lpfc_sli_ring_stat.iocb_event) requires the lpfc_hba.hbalock lock.

Error: MISSING_LOCK:
drivers/block/ub.c:1847: example_lock: Locking "sc->lock".
drivers/block/ub.c:1848: example_access: ub_scsi_cmd.tag is being accessed with lock "sc->lock" held.
drivers/block/ub.c:1905: example_lock: Locking "sc->lock".
drivers/block/ub.c:1906: example_access: ub_scsi_cmd.tag is being accessed with lock "sc->lock" held.
drivers/block/ub.c:874: missing_lock: Accessing variable "cmd->tag" (ub_scsi_cmd.tag) requires the ub_dev.lock lock.

Error: MISSING_LOCK:
drivers/block/ub.c:1847: example_lock: Locking "sc->lock".
drivers/block/ub.c:1848: example_access: ub_dev.tagcnt is being accessed with lock "sc->lock" held.
drivers/block/ub.c:1905: example_lock: Locking "sc->lock".
drivers/block/ub.c:1906: example_access: ub_dev.tagcnt is being accessed with lock "sc->lock" held.
drivers/block/ub.c:874: missing_lock: Accessing variable "sc->tagcnt" (ub_dev.tagcnt) requires the ub_dev.lock lock.

Error: MISSING_LOCK:
net/atm/lec.c:2372: example_lock: Locking "priv->lec_arp_lock".
net/atm/lec.c:2381: example_access: lec_arp_table.status is being accessed with lock "priv->lec_arp_lock" held.
net/atm/lec.c:2158: example_lock: Locking "priv->lec_arp_lock".
net/atm/lec.c:2207: example_access: lec_arp_table.status is being accessed with lock "priv->lec_arp_lock" held.
net/atm/lec.c:2158: example_lock: Locking "priv->lec_arp_lock".
net/atm/lec.c:2245: example_access: lec_arp_table.status is being accessed with lock "priv->lec_arp_lock" held.
net/atm/lec.c:2158: example_lock: Locking "priv->lec_arp_lock".
net/atm/lec.c:2249: example_access: lec_arp_table.status is being accessed with lock "priv->lec_arp_lock" held.
net/atm/lec.c:2158: example_lock: Locking "priv->lec_arp_lock".
net/atm/lec.c:2291: example_access: lec_arp_table.status is being accessed with lock "priv->lec_arp_lock" held.
net/atm/lec.c:2324: missing_lock: Accessing variable "entry->status" (lec_arp_table.status) requires the lec_priv.lec_arp_lock lock.

Error: MISSING_LOCK:
drivers/message/fusion/mptfc.c:1225: example_lock: Locking "ioc->FreeQlock".
drivers/message/fusion/mptfc.c:1229: example_access: _MPT_ADAPTER.sh is being accessed with lock "ioc->FreeQlock" held.
drivers/message/fusion/mptsas.c:3178: example_lock: Locking "ioc->FreeQlock".
drivers/message/fusion/mptsas.c:3182: example_access: _MPT_ADAPTER.sh is being accessed with lock "ioc->FreeQlock" held.
drivers/message/fusion/mptspi.c:1378: example_lock: Locking "ioc->FreeQlock".
drivers/message/fusion/mptspi.c:1382: example_access: _MPT_ADAPTER.sh is being accessed with lock "ioc->FreeQlock" held.
drivers/message/fusion/mptscsih.c:1145: missing_lock: Accessing variable "ioc->sh" (_MPT_ADAPTER.sh) requires the _MPT_ADAPTER.FreeQlock lock.

Error: MISSING_LOCK:
arch/x86/kernel/io_apic.c:2184: example_lock: Locking "desc->lock".
arch/x86/kernel/io_apic.c:2187: example_access: irq_desc.status is being accessed with lock "desc->lock" held.
kernel/irq/autoprobe.c:169: example_lock: Locking "desc->lock".
kernel/irq/autoprobe.c:178: example_access: irq_desc.status is being accessed with lock "desc->lock" held.
kernel/irq/autoprobe.c:71: example_lock: Locking "desc->lock".
kernel/irq/autoprobe.c:73: example_access: irq_desc.status is being accessed with lock "desc->lock" held.
kernel/irq/autoprobe.c:71: example_lock: Locking "desc->lock".
kernel/irq/autoprobe.c:75: example_access: irq_desc.status is being accessed with lock "desc->lock" held.
kernel/irq/autoprobe.c:89: example_lock: Locking "desc->lock".
kernel/irq/autoprobe.c:95: example_access: irq_desc.status is being accessed with lock "desc->lock" held.
arch/x86/kernel/irqinit_64.c:149: missing_lock: Accessing variable "desc->status" (irq_desc.status) requires the irq_desc.lock lock.

Error: MISSING_LOCK:
sound/pci/oxygen/oxygen_lib.c:549: example_lock: Locking "chip->reg_lock".
sound/pci/oxygen/oxygen_lib.c:551: example_access: oxygen.interrupt_mask is being accessed with lock "chip->reg_lock" held.
sound/pci/oxygen/oxygen_lib.c:549: example_lock: Locking "chip->reg_lock".
sound/pci/oxygen/oxygen_lib.c:553: example_access: oxygen.interrupt_mask is being accessed with lock "chip->reg_lock" held.
sound/pci/oxygen/oxygen_lib.c:439: example_lock: Locking "chip->reg_lock".
sound/pci/oxygen/oxygen_lib.c:440: example_access: oxygen.interrupt_mask is being accessed with lock "chip->reg_lock" held.
sound/pci/oxygen/oxygen_lib.c:71: example_lock: Locking "chip->reg_lock".
sound/pci/oxygen/oxygen_lib.c:84: example_access: oxygen.interrupt_mask is being accessed with lock "chip->reg_lock" held.
sound/pci/oxygen/oxygen_lib.c:597: example_lock: Locking "chip->reg_lock".
sound/pci/oxygen/oxygen_lib.c:599: example_access: oxygen.interrupt_mask is being accessed with lock "chip->reg_lock" held.
sound/pci/oxygen/virtuoso.c:281: missing_lock: Accessing variable "chip->interrupt_mask" (oxygen.interrupt_mask) requires the oxygen.reg_lock lock.

Error: MISSING_LOCK:
drivers/misc/sgi-xp/xpc_main.c:655: example_lock: Locking "part->act_lock".
drivers/misc/sgi-xp/xpc_main.c:659: example_access: xpc_partition.act_state is being accessed with lock "part->act_lock" held.
drivers/misc/sgi-xp/xpc_main.c:667: example_lock: Locking "part->act_lock".
drivers/misc/sgi-xp/xpc_main.c:668: example_access: xpc_partition.act_state is being accessed with lock "part->act_lock" held.
drivers/misc/sgi-xp/xpc_main.c:604: example_lock: Locking "part->act_lock".
drivers/misc/sgi-xp/xpc_main.c:607: example_access: xpc_partition.act_state is being accessed with lock "part->act_lock" held.
drivers/misc/sgi-xp/xpc_main.c:604: example_lock: Locking "part->act_lock".
drivers/misc/sgi-xp/xpc_main.c:615: example_access: xpc_partition.act_state is being accessed with lock "part->act_lock" held.
drivers/misc/sgi-xp/xpc_partition.c:313: example_lock: Locking "part->act_lock".
drivers/misc/sgi-xp/xpc_partition.c:315: example_access: xpc_partition.act_state is being accessed with lock "part->act_lock" held.
drivers/misc/sgi-xp/xpc_main.c:982: missing_lock: Accessing variable "part->act_state" (xpc_partition.act_state) requires the xpc_partition.act_lock lock.

Error: MISSING_LOCK:
drivers/misc/sgi-xp/xpc_main.c:655: example_lock: Locking "part->act_lock".
drivers/misc/sgi-xp/xpc_main.c:660: example_access: xpc_partition.reason is being accessed with lock "part->act_lock" held.
drivers/misc/sgi-xp/xpc_main.c:667: example_lock: Locking "part->act_lock".
drivers/misc/sgi-xp/xpc_main.c:669: example_access: xpc_partition.reason is being accessed with lock "part->act_lock" held.
drivers/misc/sgi-xp/xpc_main.c:604: example_lock: Locking "part->act_lock".
drivers/misc/sgi-xp/xpc_main.c:617: example_access: xpc_partition.reason is being accessed with lock "part->act_lock" held.
drivers/misc/sgi-xp/xpc_partition.c:335: example_lock: Locking "part->act_lock".
drivers/misc/sgi-xp/xpc_partition.c:338: example_access: xpc_partition.reason is being accessed with lock "part->act_lock" held.
drivers/misc/sgi-xp/xpc_partition.c:335: example_lock: Locking "part->act_lock".
drivers/misc/sgi-xp/xpc_partition.c:349: example_access: xpc_partition.reason is being accessed with lock "part->act_lock" held.
drivers/misc/sgi-xp/xpc_main.c:983: missing_lock: Accessing variable "part->reason" (xpc_partition.reason) requires the xpc_partition.act_lock lock.

Error: MISSING_LOCK:
drivers/misc/sgi-xp/xpc_main.c:655: example_lock: Locking "part->act_lock".
drivers/misc/sgi-xp/xpc_main.c:660: example_access: xpc_partition.reason_line is being accessed with lock "part->act_lock" held.
drivers/misc/sgi-xp/xpc_main.c:667: example_lock: Locking "part->act_lock".
drivers/misc/sgi-xp/xpc_main.c:669: example_access: xpc_partition.reason_line is being accessed with lock "part->act_lock" held.
drivers/misc/sgi-xp/xpc_main.c:604: example_lock: Locking "part->act_lock".
drivers/misc/sgi-xp/xpc_main.c:617: example_access: xpc_partition.reason_line is being accessed with lock "part->act_lock" held.
drivers/misc/sgi-xp/xpc_partition.c:335: example_lock: Locking "part->act_lock".
drivers/misc/sgi-xp/xpc_partition.c:338: example_access: xpc_partition.reason_line is being accessed with lock "part->act_lock" held.
drivers/misc/sgi-xp/xpc_partition.c:335: example_lock: Locking "part->act_lock".
drivers/misc/sgi-xp/xpc_partition.c:349: example_access: xpc_partition.reason_line is being accessed with lock "part->act_lock" held.
drivers/misc/sgi-xp/xpc_main.c:983: missing_lock: Accessing variable "part->reason_line" (xpc_partition.reason_line) requires the xpc_partition.act_lock lock.

Error: MISSING_LOCK:
kernel/exit.c:549: example_lock: Locking "tsk->alloc_lock".
kernel/exit.c:550: example_access: task_struct.files is being accessed with lock "tsk->alloc_lock" held.
kernel/exit.c:538: example_lock: Locking "tsk->alloc_lock".
kernel/exit.c:539: example_access: task_struct.files is being accessed with lock "tsk->alloc_lock" held.
kernel/fork.c:1715: example_lock: Locking "task->alloc_lock".
kernel/fork.c:1716: example_access: task_struct.files is being accessed with lock "task->alloc_lock" held.
kernel/fork.c:1646: example_lock: Locking "get_current()->alloc_lock".
kernel/fork.c:1665: example_access: task_struct.files is being accessed with lock "get_current()->alloc_lock" held.
kernel/exit.c:459: missing_lock: Accessing variable "get_current()->files" (task_struct.files) requires the task_struct.alloc_lock lock.

Error: MISSING_LOCK:
drivers/net/wireless/iwlwifi/iwl-agn.c:3386: example_lock: Locking "priv->lock".
drivers/net/wireless/iwlwifi/iwl-agn.c:3395: example_access: iwl_qos_info.qos_active is being accessed with lock "priv->lock" held.
drivers/net/wireless/iwlwifi/iwl-core.c:309: example_lock: Locking "priv->lock".
drivers/net/wireless/iwlwifi/iwl-core.c:310: example_access: iwl_qos_info.qos_active is being accessed with lock "priv->lock" held.
drivers/net/wireless/iwlwifi/iwl-core.c:309: example_lock: Locking "priv->lock".
drivers/net/wireless/iwlwifi/iwl-core.c:314: example_access: iwl_qos_info.qos_active is being accessed with lock "priv->lock" held.
drivers/net/wireless/iwlwifi/iwl-core.c:309: example_lock: Locking "priv->lock".
drivers/net/wireless/iwlwifi/iwl-core.c:321: example_access: iwl_qos_info.qos_active is being accessed with lock "priv->lock" held.
drivers/net/wireless/iwlwifi/iwl-core.c:963: missing_lock: Accessing variable "priv->qos_data.qos_active" (iwl_qos_info.qos_active) requires the iwl_priv.lock lock.

Error: MISSING_LOCK:
drivers/isdn/gigaset/bas-gigaset.c:1948: example_lock: Locking "cs->cmdlock".
drivers/isdn/gigaset/bas-gigaset.c:1956: example_access: cardstate.cmdbytes is being accessed with lock "cs->cmdlock" held.
drivers/isdn/gigaset/ser-gigaset.c:207: example_lock: Locking "cs->cmdlock".
drivers/isdn/gigaset/ser-gigaset.c:215: example_access: cardstate.cmdbytes is being accessed with lock "cs->cmdlock" held.
drivers/isdn/gigaset/ser-gigaset.c:138: example_lock: Locking "cs->cmdlock".
drivers/isdn/gigaset/ser-gigaset.c:139: example_access: cardstate.cmdbytes is being accessed with lock "cs->cmdlock" held.
drivers/isdn/gigaset/ser-gigaset.c:263: example_lock: Locking "cs->cmdlock".
drivers/isdn/gigaset/ser-gigaset.c:271: example_access: cardstate.cmdbytes is being accessed with lock "cs->cmdlock" held.
drivers/isdn/gigaset/usb-gigaset.c:463: example_lock: Locking "cs->cmdlock".
drivers/isdn/gigaset/usb-gigaset.c:464: example_access: cardstate.cmdbytes is being accessed with lock "cs->cmdlock" held.
drivers/isdn/gigaset/common.c:719: missing_lock: Accessing variable "cs->cmdbytes" (cardstate.cmdbytes) requires the cardstate.cmdlock lock.

Error: MISSING_LOCK:
drivers/isdn/gigaset/common.c:857: example_lock: Locking "cs->lock".
drivers/isdn/gigaset/common.c:858: example_access: cardstate.connected is being accessed with lock "cs->lock" held.
drivers/isdn/gigaset/ev-layer.c:1038: example_lock: Locking "cs->lock".
drivers/isdn/gigaset/ev-layer.c:1039: example_access: cardstate.connected is being accessed with lock "cs->lock" held.
drivers/isdn/gigaset/common.c:712: missing_lock: Accessing variable "cs->connected" (cardstate.connected) requires the cardstate.lock lock.

Error: MISSING_LOCK:
drivers/isdn/gigaset/common.c:416: example_lock: Locking "cs->lock".
drivers/isdn/gigaset/common.c:417: example_access: cardstate.running is being accessed with lock "cs->lock" held.
drivers/isdn/gigaset/common.c:743: example_lock: Locking "cs->lock".
drivers/isdn/gigaset/common.c:744: example_access: cardstate.running is being accessed with lock "cs->lock" held.
drivers/isdn/gigaset/common.c:659: missing_lock: Accessing variable "cs->running" (cardstate.running) requires the cardstate.lock lock.

Error: MISSING_LOCK:
drivers/isdn/gigaset/interface.c:203: example_lock: Locking "cs->lock".
drivers/isdn/gigaset/interface.c:204: example_access: cardstate.tty is being accessed with lock "cs->lock" held.
drivers/isdn/gigaset/interface.c:174: example_lock: Locking "cs->lock".
drivers/isdn/gigaset/interface.c:175: example_access: cardstate.tty is being accessed with lock "cs->lock" held.
drivers/isdn/gigaset/common.c:672: missing_lock: Accessing variable "cs->tty" (cardstate.tty) requires the cardstate.lock lock.

Error: MISSING_LOCK:
sound/pci/bt87x.c:617: example_lock: Locking "chip->reg_lock".
sound/pci/bt87x.c:619: example_access: snd_bt87x.reg_control is being accessed with lock "chip->reg_lock" held.
sound/pci/bt87x.c:665: example_lock: Locking "chip->reg_lock".
sound/pci/bt87x.c:667: example_access: snd_bt87x.reg_control is being accessed with lock "chip->reg_lock" held.
sound/pci/bt87x.c:581: example_lock: Locking "chip->reg_lock".
sound/pci/bt87x.c:583: example_access: snd_bt87x.reg_control is being accessed with lock "chip->reg_lock" held.
sound/pci/bt87x.c:444: example_lock: Locking "chip->reg_lock".
sound/pci/bt87x.c:445: example_access: snd_bt87x.reg_control is being accessed with lock "chip->reg_lock" held.
sound/pci/bt87x.c:512: example_lock: Locking "chip->reg_lock".
sound/pci/bt87x.c:513: example_access: snd_bt87x.reg_control is being accessed with lock "chip->reg_lock" held.
sound/pci/bt87x.c:405: missing_lock: Accessing variable "chip->reg_control" (snd_bt87x.reg_control) requires the snd_bt87x.reg_lock lock.

Error: MISSING_LOCK:
drivers/scsi/lpfc/lpfc_ct.c:792: example_lock: Locking "shost->host_lock".
drivers/scsi/lpfc/lpfc_ct.c:793: example_access: lpfc_vport.fc_flag is being accessed with lock "shost->host_lock" held.
drivers/scsi/lpfc/lpfc_ct.c:668: example_lock: Locking "shost->host_lock".
drivers/scsi/lpfc/lpfc_ct.c:669: example_access: lpfc_vport.fc_flag is being accessed with lock "shost->host_lock" held.
drivers/scsi/lpfc/lpfc_els.c:108: example_lock: Locking "shost->host_lock".
drivers/scsi/lpfc/lpfc_els.c:109: example_access: lpfc_vport.fc_flag is being accessed with lock "shost->host_lock" held.
drivers/scsi/lpfc/lpfc_els.c:3770: example_lock: Locking "shost->host_lock".
drivers/scsi/lpfc/lpfc_els.c:3772: example_access: lpfc_vport.fc_flag is being accessed with lock "shost->host_lock" held.
drivers/scsi/lpfc/lpfc_els.c:1187: example_lock: Locking "shost->host_lock".
drivers/scsi/lpfc/lpfc_els.c:1188: example_access: lpfc_vport.fc_flag is being accessed with lock "shost->host_lock" held.
drivers/scsi/lpfc/lpfc_hbadisc.c:1049: missing_lock: Accessing variable "vport->fc_flag" (lpfc_vport.fc_flag) requires the Scsi_Host.host_lock lock.

Error: MISSING_LOCK:
drivers/scsi/lpfc/lpfc_ct.c:792: example_lock: Locking "shost->host_lock".
drivers/scsi/lpfc/lpfc_ct.c:793: example_access: lpfc_vport.fc_flag is being accessed with lock "shost->host_lock" held.
drivers/scsi/lpfc/lpfc_ct.c:668: example_lock: Locking "shost->host_lock".
drivers/scsi/lpfc/lpfc_ct.c:669: example_access: lpfc_vport.fc_flag is being accessed with lock "shost->host_lock" held.
drivers/scsi/lpfc/lpfc_els.c:108: example_lock: Locking "shost->host_lock".
drivers/scsi/lpfc/lpfc_els.c:109: example_access: lpfc_vport.fc_flag is being accessed with lock "shost->host_lock" held.
drivers/scsi/lpfc/lpfc_els.c:3770: example_lock: Locking "shost->host_lock".
drivers/scsi/lpfc/lpfc_els.c:3772: example_access: lpfc_vport.fc_flag is being accessed with lock "shost->host_lock" held.
drivers/scsi/lpfc/lpfc_els.c:1187: example_lock: Locking "shost->host_lock".
drivers/scsi/lpfc/lpfc_els.c:1188: example_access: lpfc_vport.fc_flag is being accessed with lock "shost->host_lock" held.
drivers/scsi/lpfc/lpfc_hbadisc.c:1098: missing_lock: Accessing variable "vport->fc_flag" (lpfc_vport.fc_flag) requires the Scsi_Host.host_lock lock.

Error: MISSING_LOCK:
sound/pci/emu10k1/voice.c:152: example_lock: Locking "emu->voice_lock".
sound/pci/emu10k1/voice.c:153: example_access: snd_emu10k1_voice.interrupt is being accessed with lock "emu->voice_lock" held.
sound/pci/emu10k1/voice.c:119: example_lock: Locking "emu->voice_lock".
sound/pci/emu10k1/voice.c:130: example_access: snd_emu10k1_voice.interrupt is being accessed with lock "emu->voice_lock" held.
sound/pci/emu10k1/emupcm.c:157: missing_lock: Accessing variable "epcm->extra->interrupt" (snd_emu10k1_voice.interrupt) requires the snd_emu10k1.voice_lock lock.

Error: MISSING_LOCK:
drivers/spi/spi_bitbang.c:273: example_lock: Locking "bitbang->lock".
drivers/spi/spi_bitbang.c:274: example_access: spi_bitbang.busy is being accessed with lock "bitbang->lock" held.
drivers/spi/spi_bitbang.c:391: example_lock: Locking "bitbang->lock".
drivers/spi/spi_bitbang.c:393: example_access: spi_bitbang.busy is being accessed with lock "bitbang->lock" held.
drivers/spi/spi_bitbang.c:476: missing_lock: Accessing variable "bitbang->busy" (spi_bitbang.busy) requires the spi_bitbang.lock lock.

Error: MISSING_LOCK:
drivers/pcmcia/pcmcia_ioctl.c:217: example_lock: Locking "s->lock".
drivers/pcmcia/pcmcia_ioctl.c:218: example_access: pcmcia_socket.resource_setup_done is being accessed with lock "s->lock" held.
drivers/pcmcia/rsrc_mgr.c:74: example_lock: Locking "s->lock".
drivers/pcmcia/rsrc_mgr.c:75: example_access: pcmcia_socket.resource_setup_done is being accessed with lock "s->lock" held.
drivers/pcmcia/socket_sysfs.c:196: example_lock: Locking "s->lock".
drivers/pcmcia/socket_sysfs.c:198: example_access: pcmcia_socket.resource_setup_done is being accessed with lock "s->lock" held.
drivers/pcmcia/rsrc_nonstatic.c:830: missing_lock: Accessing variable "s->resource_setup_done" (pcmcia_socket.resource_setup_done) requires the pcmcia_socket.lock lock.

Error: MISSING_LOCK:
drivers/scsi/lpfc/lpfc_scsi.c:1779: example_lock: Locking "phba->scsi_buf_list_lock".
drivers/scsi/lpfc/lpfc_scsi.c:1780: example_access: lpfc_hba.total_scsi_bufs is being accessed with lock "phba->scsi_buf_list_lock" held.
drivers/scsi/lpfc/lpfc_init.c:1928: missing_lock: Accessing variable "phba->total_scsi_bufs" (lpfc_hba.total_scsi_bufs) requires the lpfc_hba.scsi_buf_list_lock lock.

Error: MISSING_LOCK:
drivers/net/sungem.c:1541: example_lock: Locking "gp->tx_lock".
drivers/net/sungem.c:1597: example_access: gem.reset_task_pending is being accessed with lock "gp->tx_lock" held.
drivers/net/sungem.c:2307: example_lock: Locking "gp->tx_lock".
drivers/net/sungem.c:2319: example_access: gem.reset_task_pending is being accessed with lock "gp->tx_lock" held.
drivers/net/sungem.c:1001: example_lock: Locking "gp->tx_lock".
drivers/net/sungem.c:1003: example_access: gem.reset_task_pending is being accessed with lock "gp->tx_lock" held.
drivers/net/sungem.c:661: missing_lock: Accessing variable "gp->reset_task_pending" (gem.reset_task_pending) requires the gem.tx_lock lock.

Error: MISSING_LOCK:
drivers/ieee1394/raw1394.c:1167: example_lock: Locking "host_info_lock".
drivers/ieee1394/raw1394.c:1319: example_access: raw1394_request.misc is being accessed with lock "host_info_lock" held.
drivers/ieee1394/raw1394.c:1392: example_lock: Locking "host_info_lock".
drivers/ieee1394/raw1394.c:1547: example_access: raw1394_request.misc is being accessed with lock "host_info_lock" held.
drivers/ieee1394/raw1394.c:866: example_lock: Locking "host_info_lock".
drivers/ieee1394/raw1394.c:949: example_access: raw1394_request.misc is being accessed with lock "host_info_lock" held.
drivers/ieee1394/raw1394.c:1020: example_lock: Locking "host_info_lock".
drivers/ieee1394/raw1394.c:1094: example_access: raw1394_request.misc is being accessed with lock "host_info_lock" held.
drivers/ieee1394/raw1394.c:301: example_lock: Locking "host_info_lock".
drivers/ieee1394/raw1394.c:334: example_access: raw1394_request.misc is being accessed with lock "host_info_lock" held.
drivers/ieee1394/raw1394.c:2183: missing_lock: Accessing variable "req->req.misc" (raw1394_request.misc) requires the host_info_lock lock.

Error: MISSING_LOCK:
kernel/exit.c:382: example_lock: Locking "get_current()->sighand->siglock".
kernel/exit.c:389: example_access: sigaction.sa_handler is being accessed with lock "get_current()->sighand->siglock" held.
kernel/exit.c:403: example_lock: Locking "get_current()->sighand->siglock".
kernel/exit.c:404: example_access: sigaction.sa_handler is being accessed with lock "get_current()->sighand->siglock" held.
kernel/signal.c:938: example_lock: Locking "t->sighand->siglock".
kernel/signal.c:943: example_access: sigaction.sa_handler is being accessed with lock "t->sighand->siglock" held.
kernel/signal.c:1214: example_lock: Locking "p->sighand->siglock".
kernel/signal.c:1215: example_access: sigaction.sa_handler is being accessed with lock "p->sighand->siglock" held.
kernel/signal.c:281: missing_lock: Accessing variable "t->sighand->action[i].sa.sa_handler" (sigaction.sa_handler) requires the sighand_struct.siglock lock.

Error: MISSING_LOCK:
drivers/ieee1394/raw1394.c:1167: example_lock: Locking "host_info_lock".
drivers/ieee1394/raw1394.c:1289: example_access: pending_request.free_data is being accessed with lock "host_info_lock" held.
drivers/ieee1394/raw1394.c:1392: example_lock: Locking "host_info_lock".
drivers/ieee1394/raw1394.c:1517: example_access: pending_request.free_data is being accessed with lock "host_info_lock" held.
drivers/ieee1394/raw1394.c:866: example_lock: Locking "host_info_lock".
drivers/ieee1394/raw1394.c:945: example_access: pending_request.free_data is being accessed with lock "host_info_lock" held.
drivers/ieee1394/raw1394.c:1020: example_lock: Locking "host_info_lock".
drivers/ieee1394/raw1394.c:1090: example_access: pending_request.free_data is being accessed with lock "host_info_lock" held.
drivers/ieee1394/raw1394.c:559: missing_lock: Accessing variable "req->free_data" (pending_request.free_data) requires the host_info_lock lock.

Error: MISSING_LOCK:
drivers/mtd/onenand/onenand_base.c:739: example_lock: Locking "this->chip_lock".
drivers/mtd/onenand/onenand_base.c:741: example_access: onenand_chip.state is being accessed with lock "this->chip_lock" held.
drivers/mtd/onenand/onenand_base.c:770: example_lock: Locking "this->chip_lock".
drivers/mtd/onenand/onenand_base.c:771: example_access: onenand_chip.state is being accessed with lock "this->chip_lock" held.
drivers/mtd/onenand/onenand_base.c:2744: missing_lock: Accessing variable "this->state" (onenand_chip.state) requires the onenand_chip.chip_lock lock.

Error: MISSING_LOCK:
drivers/net/sis900.c:1585: example_lock: Locking "sis_priv->lock".
drivers/net/sis900.c:1597: example_access: sis900_private.cur_tx is being accessed with lock "sis_priv->lock" held.
drivers/net/sis900.c:1526: example_lock: Locking "sis_priv->lock".
drivers/net/sis900.c:1529: example_access: sis900_private.cur_tx is being accessed with lock "sis_priv->lock" held.
drivers/net/sis900.c:1101: missing_lock: Accessing variable "sis_priv->cur_tx" (sis900_private.cur_tx) requires the sis900_private.lock lock.

Error: MISSING_LOCK:
sound/pci/rme9652/hdsp.c:1417: example_lock: Locking "hmidi->lock".
sound/pci/rme9652/hdsp.c:1418: example_access: hdsp_midi.output is being accessed with lock "hmidi->lock" held.
sound/pci/rme9652/hdsp.c:1389: example_lock: Locking "hmidi->lock".
sound/pci/rme9652/hdsp.c:1390: example_access: hdsp_midi.output is being accessed with lock "hmidi->lock" held.
sound/pci/rme9652/hdsp.c:4984: missing_lock: Accessing variable "hdsp->midi[0].output" (hdsp_midi.output) requires the hdsp_midi.lock lock.

Error: MISSING_LOCK:
sound/pci/rme9652/hdsp.c:1417: example_lock: Locking "hmidi->lock".
sound/pci/rme9652/hdsp.c:1418: example_access: hdsp_midi.output is being accessed with lock "hmidi->lock" held.
sound/pci/rme9652/hdsp.c:1389: example_lock: Locking "hmidi->lock".
sound/pci/rme9652/hdsp.c:1390: example_access: hdsp_midi.output is being accessed with lock "hmidi->lock" held.
sound/pci/rme9652/hdsp.c:4985: missing_lock: Accessing variable "hdsp->midi[1].output" (hdsp_midi.output) requires the hdsp_midi.lock lock.

Error: MISSING_LOCK:
drivers/scsi/initio.c:963: example_lock: Locking "host->semaph_lock".
drivers/scsi/initio.c:964: example_access: initio_host.semaph is being accessed with lock "host->semaph_lock" held.
drivers/scsi/initio.c:1061: example_lock: Locking "host->semaph_lock".
drivers/scsi/initio.c:1069: example_access: initio_host.semaph is being accessed with lock "host->semaph_lock" held.
drivers/scsi/initio.c:1074: example_lock: Locking "host->semaph_lock".
drivers/scsi/initio.c:1075: example_access: initio_host.semaph is being accessed with lock "host->semaph_lock" held.
drivers/scsi/initio.c:1089: missing_lock: Accessing variable "host->semaph" (initio_host.semaph) requires the initio_host.semaph_lock lock.

Error: MISSING_LOCK:
drivers/scsi/initio.c:963: example_lock: Locking "host->semaph_lock".
drivers/scsi/initio.c:964: example_access: initio_host.semaph is being accessed with lock "host->semaph_lock" held.
drivers/scsi/initio.c:1061: example_lock: Locking "host->semaph_lock".
drivers/scsi/initio.c:1069: example_access: initio_host.semaph is being accessed with lock "host->semaph_lock" held.
drivers/scsi/initio.c:1074: example_lock: Locking "host->semaph_lock".
drivers/scsi/initio.c:1075: example_access: initio_host.semaph is being accessed with lock "host->semaph_lock" held.
drivers/scsi/initio.c:1093: missing_lock: Accessing variable "host->semaph" (initio_host.semaph) requires the initio_host.semaph_lock lock.

Error: MISSING_LOCK:
drivers/net/irda/ksdazzle-sir.c:317: example_lock: Locking "kingsun->lock".
drivers/net/irda/ksdazzle-sir.c:318: example_access: ksdazzle_cb.new_speed is being accessed with lock "kingsun->lock" held.
drivers/net/irda/ksdazzle-sir.c:424: missing_lock: Accessing variable "kingsun->new_speed" (ksdazzle_cb.new_speed) requires the ksdazzle_cb.lock lock.

Error: MISSING_LOCK:
drivers/net/eepro100.c:2098: example_lock: Locking "sp->lock".
drivers/net/eepro100.c:2099: example_access: speedo_private.cur_tx is being accessed with lock "sp->lock" held.
drivers/net/eepro100.c:2141: example_lock: Locking "sp->lock".
drivers/net/eepro100.c:2142: example_access: speedo_private.cur_tx is being accessed with lock "sp->lock" held.
drivers/net/eepro100.c:2213: example_lock: Locking "sp->lock".
drivers/net/eepro100.c:2222: example_access: speedo_private.cur_tx is being accessed with lock "sp->lock" held.
drivers/net/eepro100.c:1412: example_lock: Locking "sp->lock".
drivers/net/eepro100.c:1424: example_access: speedo_private.cur_tx is being accessed with lock "sp->lock" held.
drivers/net/eepro100.c:963: missing_lock: Accessing variable "sp->cur_tx" (speedo_private.cur_tx) requires the speedo_private.lock lock.

Error: MISSING_LOCK:
drivers/net/8139cp.c:1459: example_lock: Locking "cp->lock".
drivers/net/8139cp.c:1460: example_access: cp_private.cpcmd is being accessed with lock "cp->lock" held.
drivers/net/8139cp.c:430: example_lock: Locking "cp->lock".
drivers/net/8139cp.c:433: example_access: cp_private.cpcmd is being accessed with lock "cp->lock" held.
drivers/net/8139cp.c:430: example_lock: Locking "cp->lock".
drivers/net/8139cp.c:435: example_access: cp_private.cpcmd is being accessed with lock "cp->lock" held.
drivers/net/8139cp.c:1911: missing_lock: Accessing variable "cp->cpcmd" (cp_private.cpcmd) requires the cp_private.lock lock.

Error: MISSING_LOCK:
drivers/usb/gadget/file_storage.c:1070: example_lock: Locking "fsg->lock".
drivers/usb/gadget/file_storage.c:1073: example_access: fsg_dev.state is being accessed with lock "fsg->lock" held.
drivers/usb/gadget/file_storage.c:3332: example_lock: Locking "fsg->lock".
drivers/usb/gadget/file_storage.c:3346: example_access: fsg_dev.state is being accessed with lock "fsg->lock" held.
drivers/usb/gadget/file_storage.c:3332: example_lock: Locking "fsg->lock".
drivers/usb/gadget/file_storage.c:3356: example_access: fsg_dev.state is being accessed with lock "fsg->lock" held.
drivers/usb/gadget/file_storage.c:3367: example_lock: Locking "fsg->lock".
drivers/usb/gadget/file_storage.c:3369: example_access: fsg_dev.state is being accessed with lock "fsg->lock" held.
drivers/usb/gadget/file_storage.c:3422: example_lock: Locking "fsg->lock".
drivers/usb/gadget/file_storage.c:3423: example_access: fsg_dev.state is being accessed with lock "fsg->lock" held.
drivers/usb/gadget/file_storage.c:4066: missing_lock: Accessing variable "fsg->state" (fsg_dev.state) requires the fsg_dev.lock lock.

Error: MISSING_LOCK:
fs/jffs2/background.c:145: example_lock: Locking "c->erase_completion_lock".
fs/jffs2/background.c:146: example_access: jffs2_sb_info.gc_task is being accessed with lock "c->erase_completion_lock" held.
fs/jffs2/background.c:79: missing_lock: Accessing variable "c->gc_task" (jffs2_sb_info.gc_task) requires the jffs2_sb_info.erase_completion_lock lock.

Error: MISSING_LOCK:
drivers/net/irda/ks959-sir.c:404: example_lock: Locking "kingsun->lock".
drivers/net/irda/ks959-sir.c:405: example_access: ks959_cb.new_speed is being accessed with lock "kingsun->lock" held.
drivers/net/irda/ks959-sir.c:531: missing_lock: Accessing variable "kingsun->new_speed" (ks959_cb.new_speed) requires the ks959_cb.lock lock.

Error: MISSING_LOCK:
drivers/scsi/lpfc/lpfc_els.c:1144: example_lock: Locking "phba->ndlp_lock".
drivers/scsi/lpfc/lpfc_els.c:1145: example_access: lpfc_nodelist.nlp_usg_map is being accessed with lock "phba->ndlp_lock" held.
drivers/scsi/lpfc/lpfc_hbadisc.c:3233: example_lock: Locking "phba->ndlp_lock".
drivers/scsi/lpfc/lpfc_hbadisc.c:3267: example_access: lpfc_nodelist.nlp_usg_map is being accessed with lock "phba->ndlp_lock" held.
drivers/scsi/lpfc/lpfc_hbadisc.c:3233: example_lock: Locking "phba->ndlp_lock".
drivers/scsi/lpfc/lpfc_hbadisc.c:3270: example_access: lpfc_nodelist.nlp_usg_map is being accessed with lock "phba->ndlp_lock" held.
drivers/scsi/lpfc/lpfc_hbadisc.c:1867: example_lock: Locking "phba->ndlp_lock".
drivers/scsi/lpfc/lpfc_hbadisc.c:1905: example_access: lpfc_nodelist.nlp_usg_map is being accessed with lock "phba->ndlp_lock" held.
drivers/scsi/lpfc/lpfc_hbadisc.c:3166: example_lock: Locking "phba->ndlp_lock".
drivers/scsi/lpfc/lpfc_hbadisc.c:3167: example_access: lpfc_nodelist.nlp_usg_map is being accessed with lock "phba->ndlp_lock" held.
drivers/scsi/lpfc/lpfc_vport.c:653: missing_lock: Accessing variable "ndlp->nlp_usg_map" (lpfc_nodelist.nlp_usg_map) requires the lpfc_hba.ndlp_lock lock.

Error: MISSING_LOCK:
drivers/scsi/lpfc/lpfc_ct.c:1685: example_lock: Locking "vport->work_port_lock".
drivers/scsi/lpfc/lpfc_ct.c:1688: example_access: lpfc_vport.work_port_events is being accessed with lock "vport->work_port_lock" held.
drivers/scsi/lpfc/lpfc_els.c:4855: example_lock: Locking "vport->work_port_lock".
drivers/scsi/lpfc/lpfc_els.c:4858: example_access: lpfc_vport.work_port_events is being accessed with lock "vport->work_port_lock" held.
drivers/scsi/lpfc/lpfc_els.c:6128: example_lock: Locking "phba->pport->work_port_lock".
drivers/scsi/lpfc/lpfc_els.c:6131: example_access: lpfc_vport.work_port_events is being accessed with lock "phba->pport->work_port_lock" held.
drivers/scsi/lpfc/lpfc_hbadisc.c:1997: example_lock: Locking "vport->work_port_lock".
drivers/scsi/lpfc/lpfc_hbadisc.c:1998: example_access: lpfc_vport.work_port_events is being accessed with lock "vport->work_port_lock" held.
drivers/scsi/lpfc/lpfc_hbadisc.c:2790: example_lock: Locking "vport->work_port_lock".
drivers/scsi/lpfc/lpfc_hbadisc.c:2793: example_access: lpfc_vport.work_port_events is being accessed with lock "vport->work_port_lock" held.
drivers/scsi/lpfc/lpfc_vport.c:705: missing_lock: Accessing variable "vport->work_port_events" (lpfc_vport.work_port_events) requires the lpfc_vport.work_port_lock lock.

Error: MISSING_LOCK:
drivers/message/fusion/mptlan.c:937: example_lock: Locking "priv->rxfidx_lock".
drivers/message/fusion/mptlan.c:954: example_access: mpt_lan_priv.mpt_rxfidx_tail is being accessed with lock "priv->rxfidx_lock" held.
drivers/message/fusion/mptlan.c:1037: example_lock: Locking "priv->rxfidx_lock".
drivers/message/fusion/mptlan.c:1062: example_access: mpt_lan_priv.mpt_rxfidx_tail is being accessed with lock "priv->rxfidx_lock" held.
drivers/message/fusion/mptlan.c:1091: example_lock: Locking "priv->rxfidx_lock".
drivers/message/fusion/mptlan.c:1092: example_access: mpt_lan_priv.mpt_rxfidx_tail is being accessed with lock "priv->rxfidx_lock" held.
drivers/message/fusion/mptlan.c:1096: example_lock: Locking "priv->rxfidx_lock".
drivers/message/fusion/mptlan.c:1104: example_access: mpt_lan_priv.mpt_rxfidx_tail is being accessed with lock "priv->rxfidx_lock" held.
drivers/message/fusion/mptlan.c:909: example_lock: Locking "priv->rxfidx_lock".
drivers/message/fusion/mptlan.c:910: example_access: mpt_lan_priv.mpt_rxfidx_tail is being accessed with lock "priv->rxfidx_lock" held.
drivers/message/fusion/mptlan.c:414: missing_lock: Accessing variable "priv->mpt_rxfidx_tail" (mpt_lan_priv.mpt_rxfidx_tail) requires the mpt_lan_priv.rxfidx_lock lock.

Error: MISSING_LOCK:
drivers/message/fusion/mptlan.c:937: example_lock: Locking "priv->rxfidx_lock".
drivers/message/fusion/mptlan.c:954: example_access: mpt_lan_priv.mpt_rxfidx_tail is being accessed with lock "priv->rxfidx_lock" held.
drivers/message/fusion/mptlan.c:1037: example_lock: Locking "priv->rxfidx_lock".
drivers/message/fusion/mptlan.c:1062: example_access: mpt_lan_priv.mpt_rxfidx_tail is being accessed with lock "priv->rxfidx_lock" held.
drivers/message/fusion/mptlan.c:1091: example_lock: Locking "priv->rxfidx_lock".
drivers/message/fusion/mptlan.c:1092: example_access: mpt_lan_priv.mpt_rxfidx_tail is being accessed with lock "priv->rxfidx_lock" held.
drivers/message/fusion/mptlan.c:1096: example_lock: Locking "priv->rxfidx_lock".
drivers/message/fusion/mptlan.c:1104: example_access: mpt_lan_priv.mpt_rxfidx_tail is being accessed with lock "priv->rxfidx_lock" held.
drivers/message/fusion/mptlan.c:909: example_lock: Locking "priv->rxfidx_lock".
drivers/message/fusion/mptlan.c:910: example_access: mpt_lan_priv.mpt_rxfidx_tail is being accessed with lock "priv->rxfidx_lock" held.
drivers/message/fusion/mptlan.c:422: missing_lock: Accessing variable "priv->mpt_rxfidx_tail" (mpt_lan_priv.mpt_rxfidx_tail) requires the mpt_lan_priv.rxfidx_lock lock.

Error: MISSING_LOCK:
drivers/message/fusion/mptlan.c:659: example_lock: Locking "priv->txfidx_lock".
drivers/message/fusion/mptlan.c:675: example_access: mpt_lan_priv.mpt_txfidx_tail is being accessed with lock "priv->txfidx_lock" held.
drivers/message/fusion/mptlan.c:609: example_lock: Locking "priv->txfidx_lock".
drivers/message/fusion/mptlan.c:610: example_access: mpt_lan_priv.mpt_txfidx_tail is being accessed with lock "priv->txfidx_lock" held.
drivers/message/fusion/mptlan.c:709: example_lock: Locking "priv->txfidx_lock".
drivers/message/fusion/mptlan.c:729: example_access: mpt_lan_priv.mpt_txfidx_tail is being accessed with lock "priv->txfidx_lock" held.
drivers/message/fusion/mptlan.c:399: missing_lock: Accessing variable "priv->mpt_txfidx_tail" (mpt_lan_priv.mpt_txfidx_tail) requires the mpt_lan_priv.txfidx_lock lock.

Error: MISSING_LOCK:
drivers/message/fusion/mptlan.c:659: example_lock: Locking "priv->txfidx_lock".
drivers/message/fusion/mptlan.c:675: example_access: mpt_lan_priv.mpt_txfidx_tail is being accessed with lock "priv->txfidx_lock" held.
drivers/message/fusion/mptlan.c:609: example_lock: Locking "priv->txfidx_lock".
drivers/message/fusion/mptlan.c:610: example_access: mpt_lan_priv.mpt_txfidx_tail is being accessed with lock "priv->txfidx_lock" held.
drivers/message/fusion/mptlan.c:709: example_lock: Locking "priv->txfidx_lock".
drivers/message/fusion/mptlan.c:729: example_access: mpt_lan_priv.mpt_txfidx_tail is being accessed with lock "priv->txfidx_lock" held.
drivers/message/fusion/mptlan.c:406: missing_lock: Accessing variable "priv->mpt_txfidx_tail" (mpt_lan_priv.mpt_txfidx_tail) requires the mpt_lan_priv.txfidx_lock lock.

Error: MISSING_LOCK:
drivers/net/plip.c:408: example_lock: Locking "nl->lock".
drivers/net/plip.c:412: example_access: net_local.timeout_count is being accessed with lock "nl->lock" held.
drivers/net/plip.c:408: example_lock: Locking "nl->lock".
drivers/net/plip.c:434: example_access: net_local.timeout_count is being accessed with lock "nl->lock" held.
drivers/net/plip.c:911: example_lock: Locking "nl->lock".
drivers/net/plip.c:931: example_access: net_local.timeout_count is being accessed with lock "nl->lock" held.
drivers/net/plip.c:976: example_lock: Locking "nl->lock".
drivers/net/plip.c:983: example_access: net_local.timeout_count is being accessed with lock "nl->lock" held.
drivers/net/plip.c:795: missing_lock: Accessing variable "nl->timeout_count" (net_local.timeout_count) requires the net_local.lock lock.

Error: MISSING_LOCK:
drivers/usb/host/u132-hcd.c:1979: example_lock: Locking "endp->queue_lock.slock".
drivers/usb/host/u132-hcd.c:1992: example_access: u132_endp.edset_flush is being accessed with lock "endp->queue_lock.slock" held.
drivers/usb/host/u132-hcd.c:2075: example_lock: Locking "endp->queue_lock.slock".
drivers/usb/host/u132-hcd.c:2096: example_access: u132_endp.edset_flush is being accessed with lock "endp->queue_lock.slock" held.
drivers/usb/host/u132-hcd.c:1880: example_lock: Locking "endp->queue_lock.slock".
drivers/usb/host/u132-hcd.c:1901: example_access: u132_endp.edset_flush is being accessed with lock "endp->queue_lock.slock" held.
drivers/usb/host/u132-hcd.c:2434: example_lock: Locking "endp->queue_lock.slock".
drivers/usb/host/u132-hcd.c:2452: example_access: u132_endp.edset_flush is being accessed with lock "endp->queue_lock.slock" held.
drivers/usb/host/u132-hcd.c:1376: missing_lock: Accessing variable "endp->edset_flush" (u132_endp.edset_flush) requires the u132_spin.slock lock.

Error: MISSING_LOCK:
drivers/scsi/lpfc/lpfc_scsi.c:966: example_lock: Locking "sdev->host->host_lock".
drivers/scsi/lpfc/lpfc_scsi.c:967: example_access: lpfc_scsi_buf.pCmd is being accessed with lock "sdev->host->host_lock" held.
drivers/scsi/lpfc/lpfc_scsi.c:1043: example_lock: Locking "sdev->host->host_lock".
drivers/scsi/lpfc/lpfc_scsi.c:1044: example_access: lpfc_scsi_buf.pCmd is being accessed with lock "sdev->host->host_lock" held.
drivers/scsi/lpfc/lpfc_scsi.c:1369: missing_lock: Accessing variable "lpfc_cmd->pCmd" (lpfc_scsi_buf.pCmd) requires the Scsi_Host.host_lock lock.

Error: MISSING_LOCK:
drivers/usb/host/u132-hcd.c:1979: example_lock: Locking "endp->queue_lock.slock".
drivers/usb/host/u132-hcd.c:2027: example_access: u132_endp.usb_addr is being accessed with lock "endp->queue_lock.slock" held.
drivers/usb/host/u132-hcd.c:2075: example_lock: Locking "endp->queue_lock.slock".
drivers/usb/host/u132-hcd.c:2108: example_access: u132_endp.usb_addr is being accessed with lock "endp->queue_lock.slock" held.
drivers/usb/host/u132-hcd.c:2075: example_lock: Locking "endp->queue_lock.slock".
drivers/usb/host/u132-hcd.c:2129: example_access: u132_endp.usb_addr is being accessed with lock "endp->queue_lock.slock" held.
drivers/usb/host/u132-hcd.c:1880: example_lock: Locking "endp->queue_lock.slock".
drivers/usb/host/u132-hcd.c:1928: example_access: u132_endp.usb_addr is being accessed with lock "endp->queue_lock.slock" held.
drivers/usb/host/u132-hcd.c:1112: missing_lock: Accessing variable "endp->usb_addr" (u132_endp.usb_addr) requires the u132_spin.slock lock.

Error: MISSING_LOCK:
drivers/scsi/st.c:1136: example_lock: Locking "st_dev_arr_lock".
drivers/scsi/st.c:1148: example_access: scsi_tape.in_use is being accessed with lock "st_dev_arr_lock" held.
drivers/scsi/st.c:3951: example_lock: Locking "st_dev_arr_lock".
drivers/scsi/st.c:4015: example_access: scsi_tape.in_use is being accessed with lock "st_dev_arr_lock" held.
drivers/scsi/st.c:1328: example_lock: Locking "st_dev_arr_lock".
drivers/scsi/st.c:1329: example_access: scsi_tape.in_use is being accessed with lock "st_dev_arr_lock" held.
drivers/scsi/st.c:1197: missing_lock: Accessing variable "STp->in_use" (scsi_tape.in_use) requires the st_dev_arr_lock lock.

Error: MISSING_LOCK:
drivers/serial/jsm/jsm_tty.c:308: example_lock: Locking "port->lock".
drivers/serial/jsm/jsm_tty.c:309: example_access: jsm_channel.ch_c_cflag is being accessed with lock "port->lock" held.
drivers/serial/jsm/jsm_tty.c:243: missing_lock: Accessing variable "channel->ch_c_cflag" (jsm_channel.ch_c_cflag) requires the uart_port.lock lock.

Error: MISSING_LOCK:
fs/afs/dir.c:668: example_lock: Locking "dentry->d_lock".
fs/afs/dir.c:669: example_access: dentry.d_flags is being accessed with lock "dentry->d_lock" held.
fs/autofs4/root.c:129: example_lock: Locking "dentry->d_lock".
fs/autofs4/root.c:130: example_access: dentry.d_flags is being accessed with lock "dentry->d_lock" held.
fs/autofs4/root.c:144: example_lock: Locking "dentry->d_lock".
fs/autofs4/root.c:145: example_access: dentry.d_flags is being accessed with lock "dentry->d_lock" held.
fs/autofs4/root.c:152: example_lock: Locking "dentry->d_lock".
fs/autofs4/root.c:153: example_access: dentry.d_flags is being accessed with lock "dentry->d_lock" held.
fs/autofs4/root.c:163: example_lock: Locking "dentry->d_lock".
fs/autofs4/root.c:164: example_access: dentry.d_flags is being accessed with lock "dentry->d_lock" held.
net/socket.c:319: missing_lock: Accessing variable "dentry->d_flags" (dentry.d_flags) requires the dentry.d_lock lock.

Error: MISSING_LOCK:
drivers/usb/serial/ti_usb_3410_5052.c:1214: example_lock: Locking "tport->tp_lock".
drivers/usb/serial/ti_usb_3410_5052.c:1219: example_access: ti_port.tp_read_urb_state is being accessed with lock "tport->tp_lock" held.
drivers/usb/serial/ti_usb_3410_5052.c:1549: example_lock: Locking "tport->tp_lock".
drivers/usb/serial/ti_usb_3410_5052.c:1552: example_access: ti_port.tp_read_urb_state is being accessed with lock "tport->tp_lock" held.
drivers/usb/serial/ti_usb_3410_5052.c:1549: example_lock: Locking "tport->tp_lock".
drivers/usb/serial/ti_usb_3410_5052.c:1560: example_access: ti_port.tp_read_urb_state is being accessed with lock "tport->tp_lock" held.
drivers/usb/serial/ti_usb_3410_5052.c:1534: example_lock: Locking "tport->tp_lock".
drivers/usb/serial/ti_usb_3410_5052.c:1537: example_access: ti_port.tp_read_urb_state is being accessed with lock "tport->tp_lock" held.
drivers/usb/serial/ti_usb_3410_5052.c:612: missing_lock: Accessing variable "tport->tp_read_urb_state" (ti_port.tp_read_urb_state) requires the ti_port.tp_lock lock.

Error: MISSING_LOCK:
drivers/scsi/scsi_transport_fc.c:2647: example_lock: Locking "shost->host_lock".
drivers/scsi/scsi_transport_fc.c:2649: example_access: fc_rport.flags is being accessed with lock "shost->host_lock" held.
drivers/scsi/scsi_transport_fc.c:2647: example_lock: Locking "shost->host_lock".
drivers/scsi/scsi_transport_fc.c:2654: example_access: fc_rport.flags is being accessed with lock "shost->host_lock" held.
drivers/scsi/scsi_transport_fc.c:2576: example_lock: Locking "shost->host_lock".
drivers/scsi/scsi_transport_fc.c:2713: example_access: fc_rport.flags is being accessed with lock "shost->host_lock" held.
drivers/scsi/scsi_transport_fc.c:2576: example_lock: Locking "shost->host_lock".
drivers/scsi/scsi_transport_fc.c:2721: example_access: fc_rport.flags is being accessed with lock "shost->host_lock" held.
drivers/scsi/scsi_transport_fc.c:2916: example_lock: Locking "shost->host_lock".
drivers/scsi/scsi_transport_fc.c:2917: example_access: fc_rport.flags is being accessed with lock "shost->host_lock" held.
drivers/scsi/scsi_transport_fc.c:3060: missing_lock: Accessing variable "rport->flags" (fc_rport.flags) requires the Scsi_Host.host_lock lock.

Error: MISSING_LOCK:
drivers/scsi/qla4xxx/ql4_isr.c:619: example_lock: Locking "ha->hardware_lock".
drivers/scsi/qla4xxx/ql4_isr.c:621: example_access: scsi_qla_host.isr_count is being accessed with lock "ha->hardware_lock" held.
drivers/scsi/qla1280.c:1121: missing_lock: Accessing variable "ha->isr_count" (scsi_qla_host.isr_count) requires the scsi_qla_host.hardware_lock lock.

Error: MISSING_LOCK:
drivers/scsi/lpfc/lpfc_els.c:1817: example_lock: Locking "shost->host_lock".
drivers/scsi/lpfc/lpfc_els.c:1818: example_access: lpfc_nodelist.nlp_flag is being accessed with lock "shost->host_lock" held.
drivers/scsi/lpfc/lpfc_els.c:1821: example_lock: Locking "shost->host_lock".
drivers/scsi/lpfc/lpfc_els.c:1822: example_access: lpfc_nodelist.nlp_flag is being accessed with lock "shost->host_lock" held.
drivers/scsi/lpfc/lpfc_els.c:2253: example_lock: Locking "shost->host_lock".
drivers/scsi/lpfc/lpfc_els.c:2254: example_access: lpfc_nodelist.nlp_flag is being accessed with lock "shost->host_lock" held.
drivers/scsi/lpfc/lpfc_els.c:2265: example_lock: Locking "shost->host_lock".
drivers/scsi/lpfc/lpfc_els.c:2266: example_access: lpfc_nodelist.nlp_flag is being accessed with lock "shost->host_lock" held.
drivers/scsi/lpfc/lpfc_els.c:3656: example_lock: Locking "shost->host_lock".
drivers/scsi/lpfc/lpfc_els.c:3657: example_access: lpfc_nodelist.nlp_flag is being accessed with lock "shost->host_lock" held.
drivers/scsi/lpfc/lpfc_nportdisc.c:1829: missing_lock: Accessing variable "ndlp->nlp_flag" (lpfc_nodelist.nlp_flag) requires the Scsi_Host.host_lock lock.

Error: MISSING_LOCK:
drivers/isdn/hysdn/hysdn_proclog.c:271: example_lock: Locking "card->hysdn_lock".
drivers/isdn/hysdn/hysdn_proclog.c:272: example_access: procdata.if_used is being accessed with lock "card->hysdn_lock" held.
drivers/isdn/hysdn/hysdn_proclog.c:325: missing_lock: Accessing variable "pd->if_used" (procdata.if_used) requires the HYSDN_CARD.hysdn_lock lock.

Error: MISSING_LOCK:
drivers/net/wireless/iwlwifi/iwl-agn.c:3386: example_lock: Locking "priv->lock".
drivers/net/wireless/iwlwifi/iwl-agn.c:3395: example_access: iwl_qos_info.qos_active is being accessed with lock "priv->lock" held.
drivers/net/wireless/iwlwifi/iwl-core.c:309: example_lock: Locking "priv->lock".
drivers/net/wireless/iwlwifi/iwl-core.c:310: example_access: iwl_qos_info.qos_active is being accessed with lock "priv->lock" held.
drivers/net/wireless/iwlwifi/iwl-core.c:309: example_lock: Locking "priv->lock".
drivers/net/wireless/iwlwifi/iwl-core.c:314: example_access: iwl_qos_info.qos_active is being accessed with lock "priv->lock" held.
drivers/net/wireless/iwlwifi/iwl-core.c:309: example_lock: Locking "priv->lock".
drivers/net/wireless/iwlwifi/iwl-core.c:321: example_access: iwl_qos_info.qos_active is being accessed with lock "priv->lock" held.
drivers/net/wireless/iwlwifi/iwl-agn.c:3380: missing_lock: Accessing variable "priv->qos_data.qos_active" (iwl_qos_info.qos_active) requires the iwl_priv.lock lock.

Error: MISSING_LOCK:
drivers/usb/serial/io_edgeport.c:1293: example_lock: Locking "edge_port->ep_lock".
drivers/usb/serial/io_edgeport.c:1372: example_access: edgeport_port.txCredits is being accessed with lock "edge_port->ep_lock" held.
drivers/usb/serial/io_edgeport.c:1293: example_lock: Locking "edge_port->ep_lock".
drivers/usb/serial/io_edgeport.c:1385: example_access: edgeport_port.txCredits is being accessed with lock "edge_port->ep_lock" held.
drivers/usb/serial/io_edgeport.c:670: example_lock: Locking "edge_port->ep_lock".
drivers/usb/serial/io_edgeport.c:671: example_access: edgeport_port.txCredits is being accessed with lock "edge_port->ep_lock" held.
drivers/usb/serial/io_edgeport.c:936: missing_lock: Accessing variable "edge_port->txCredits" (edgeport_port.txCredits) requires the edgeport_port.ep_lock lock.

Error: MISSING_LOCK:
drivers/char/pcmcia/synclink_cs.c:1424: example_lock: Locking "info->lock".
drivers/char/pcmcia/synclink_cs.c:1428: example_access: _mgslpc_info.tx_count is being accessed with lock "info->lock" held.
drivers/char/pcmcia/synclink_cs.c:1973: example_lock: Locking "info->lock".
drivers/char/pcmcia/synclink_cs.c:1979: example_access: _mgslpc_info.tx_count is being accessed with lock "info->lock" held.
drivers/char/pcmcia/synclink_cs.c:1740: example_lock: Locking "info->lock".
drivers/char/pcmcia/synclink_cs.c:1741: example_access: _mgslpc_info.tx_count is being accessed with lock "info->lock" held.
drivers/char/pcmcia/synclink_cs.c:1561: example_lock: Locking "info->lock".
drivers/char/pcmcia/synclink_cs.c:1567: example_access: _mgslpc_info.tx_count is being accessed with lock "info->lock" held.
drivers/char/pcmcia/synclink_cs.c:1649: example_lock: Locking "info->lock".
drivers/char/pcmcia/synclink_cs.c:1651: example_access: _mgslpc_info.tx_count is being accessed with lock "info->lock" held.
drivers/char/pcmcia/synclink_cs.c:4154: missing_lock: Accessing variable "info->tx_count" (_mgslpc_info.tx_count) requires the _mgslpc_info.lock lock.

Error: MISSING_LOCK:
drivers/char/pcmcia/synclink_cs.c:1424: example_lock: Locking "info->lock".
drivers/char/pcmcia/synclink_cs.c:1428: example_access: _mgslpc_info.tx_put is being accessed with lock "info->lock" held.
drivers/char/pcmcia/synclink_cs.c:1973: example_lock: Locking "info->lock".
drivers/char/pcmcia/synclink_cs.c:1979: example_access: _mgslpc_info.tx_put is being accessed with lock "info->lock" held.
drivers/char/pcmcia/synclink_cs.c:1740: example_lock: Locking "info->lock".
drivers/char/pcmcia/synclink_cs.c:1741: example_access: _mgslpc_info.tx_put is being accessed with lock "info->lock" held.
drivers/char/pcmcia/synclink_cs.c:1561: example_lock: Locking "info->lock".
drivers/char/pcmcia/synclink_cs.c:1565: example_access: _mgslpc_info.tx_put is being accessed with lock "info->lock" held.
drivers/char/pcmcia/synclink_cs.c:1561: example_lock: Locking "info->lock".
drivers/char/pcmcia/synclink_cs.c:1566: example_access: _mgslpc_info.tx_put is being accessed with lock "info->lock" held.
drivers/char/pcmcia/synclink_cs.c:4154: missing_lock: Accessing variable "info->tx_put" (_mgslpc_info.tx_put) requires the _mgslpc_info.lock lock.

Error: MISSING_LOCK:
drivers/isdn/i4l/isdn_net.h:133: example_lock: Locking "master_lp->netdev->queue_lock".
drivers/isdn/i4l/isdn_net.h:134: example_access: isdn_net_local_s.next is being accessed with lock "master_lp->netdev->queue_lock" held.
drivers/isdn/i4l/isdn_net.h:133: example_lock: Locking "master_lp->netdev->queue_lock".
drivers/isdn/i4l/isdn_net.h:142: example_access: isdn_net_local_s.next is being accessed with lock "master_lp->netdev->queue_lock" held.
drivers/isdn/i4l/isdn_net.h:107: example_lock: Locking "nd->queue_lock".
drivers/isdn/i4l/isdn_net.h:113: example_access: isdn_net_local_s.next is being accessed with lock "nd->queue_lock" held.
drivers/isdn/i4l/isdn_net.h:107: example_lock: Locking "nd->queue_lock".
drivers/isdn/i4l/isdn_net.h:115: example_access: isdn_net_local_s.next is being accessed with lock "nd->queue_lock" held.
drivers/isdn/i4l/isdn_net.c:2528: missing_lock: Accessing variable "lp->next" (isdn_net_local_s.next) requires the isdn_net_dev_s.queue_lock lock.

Error: MISSING_LOCK:
drivers/acpi/events/evxface.c:628: example_lock: Locking "_acpi_gbl_gpe_lock".
drivers/acpi/events/evxface.c:629: example_access: acpi_gpe_dispatch_info.handler is being accessed with lock "_acpi_gbl_gpe_lock" held.
drivers/acpi/events/evgpeblk.c:212: missing_lock: Accessing variable "gpe_event_info->dispatch.handler" (acpi_gpe_dispatch_info.handler) requires the _acpi_gbl_gpe_lock lock.

Error: MISSING_LOCK:
drivers/char/rocket.c:445: example_lock: Locking "info->slock".
drivers/char/rocket.c:447: example_access: r_port.xmit_fifo_room is being accessed with lock "info->slock" held.
drivers/char/rocket.c:445: example_lock: Locking "info->slock".
drivers/char/rocket.c:463: example_access: r_port.xmit_fifo_room is being accessed with lock "info->slock" held.
drivers/char/rocket.c:1687: example_lock: Locking "info->slock".
drivers/char/rocket.c:1691: example_access: r_port.xmit_fifo_room is being accessed with lock "info->slock" held.
drivers/char/rocket.c:1687: example_lock: Locking "info->slock".
drivers/char/rocket.c:1700: example_access: r_port.xmit_fifo_room is being accessed with lock "info->slock" held.
drivers/char/rocket.c:1756: example_lock: Locking "info->slock".
drivers/char/rocket.c:1757: example_access: r_port.xmit_fifo_room is being accessed with lock "info->slock" held.
drivers/char/rocket.c:1735: missing_lock: Accessing variable "info->xmit_fifo_room" (r_port.xmit_fifo_room) requires the r_port.slock lock.

Error: MISSING_LOCK:
drivers/net/wireless/iwlwifi/iwl3945-base.c:1746: example_lock: Locking "priv->lock".
drivers/net/wireless/iwlwifi/iwl3945-base.c:1747: example_access: iwl3945_qos_info.qos_active is being accessed with lock "priv->lock" held.
drivers/net/wireless/iwlwifi/iwl3945-base.c:1746: example_lock: Locking "priv->lock".
drivers/net/wireless/iwlwifi/iwl3945-base.c:1751: example_access: iwl3945_qos_info.qos_active is being accessed with lock "priv->lock" held.
drivers/net/wireless/iwlwifi/iwl3945-base.c:1746: example_lock: Locking "priv->lock".
drivers/net/wireless/iwlwifi/iwl3945-base.c:1758: example_access: iwl3945_qos_info.qos_active is being accessed with lock "priv->lock" held.
drivers/net/wireless/iwlwifi/iwl3945-base.c:7153: example_lock: Locking "priv->lock".
drivers/net/wireless/iwlwifi/iwl3945-base.c:7162: example_access: iwl3945_qos_info.qos_active is being accessed with lock "priv->lock" held.
drivers/net/wireless/iwlwifi/iwl3945-base.c:7147: missing_lock: Accessing variable "priv->qos_data.qos_active" (iwl3945_qos_info.qos_active) requires the iwl3945_priv.lock lock.

Error: MISSING_LOCK:
net/irda/irttp.c:1808: example_lock: Locking "irttp->tsaps->hb_spinlock".
net/irda/irttp.c:1809: example_access: irttp_iter_state.id is being accessed with lock "irttp->tsaps->hb_spinlock" held.
net/irda/irttp.c:1808: example_lock: Locking "irttp->tsaps->hb_spinlock".
net/irda/irttp.c:1816: example_access: irttp_iter_state.id is being accessed with lock "irttp->tsaps->hb_spinlock" held.
net/irda/irttp.c:1827: missing_lock: Accessing variable "iter->id" (irttp_iter_state.id) requires the hashbin_t.hb_spinlock lock.

Error: MISSING_LOCK:
drivers/net/wireless/libertas/cmd.c:1835: example_lock: Locking "priv->driver_lock".
drivers/net/wireless/libertas/cmd.c:1838: example_access: lbs_private.dnld_sent is being accessed with lock "priv->driver_lock" held.
drivers/net/wireless/libertas/if_cs.c:404: example_lock: Locking "priv->driver_lock".
drivers/net/wireless/libertas/if_cs.c:405: example_access: lbs_private.dnld_sent is being accessed with lock "priv->driver_lock" held.
drivers/net/wireless/libertas/if_usb.c:911: example_lock: Locking "priv->driver_lock".
drivers/net/wireless/libertas/if_usb.c:913: example_access: lbs_private.dnld_sent is being accessed with lock "priv->driver_lock" held.
drivers/net/wireless/libertas/if_usb.c:918: example_lock: Locking "priv->driver_lock".
drivers/net/wireless/libertas/if_usb.c:919: example_access: lbs_private.dnld_sent is being accessed with lock "priv->driver_lock" held.
drivers/net/wireless/libertas/main.c:513: example_lock: Locking "priv->driver_lock".
drivers/net/wireless/libertas/main.c:515: example_access: lbs_private.dnld_sent is being accessed with lock "priv->driver_lock" held.
drivers/net/wireless/libertas/if_usb.c:800: missing_lock: Accessing variable "priv->dnld_sent" (lbs_private.dnld_sent) requires the lbs_private.driver_lock lock.

Error: MISSING_LOCK:
drivers/net/wireless/libertas/cmd.c:1835: example_lock: Locking "priv->driver_lock".
drivers/net/wireless/libertas/cmd.c:1838: example_access: lbs_private.dnld_sent is being accessed with lock "priv->driver_lock" held.
drivers/net/wireless/libertas/if_cs.c:404: example_lock: Locking "priv->driver_lock".
drivers/net/wireless/libertas/if_cs.c:405: example_access: lbs_private.dnld_sent is being accessed with lock "priv->driver_lock" held.
drivers/net/wireless/libertas/if_usb.c:911: example_lock: Locking "priv->driver_lock".
drivers/net/wireless/libertas/if_usb.c:913: example_access: lbs_private.dnld_sent is being accessed with lock "priv->driver_lock" held.
drivers/net/wireless/libertas/if_usb.c:918: example_lock: Locking "priv->driver_lock".
drivers/net/wireless/libertas/if_usb.c:919: example_access: lbs_private.dnld_sent is being accessed with lock "priv->driver_lock" held.
drivers/net/wireless/libertas/main.c:513: example_lock: Locking "priv->driver_lock".
drivers/net/wireless/libertas/main.c:515: example_access: lbs_private.dnld_sent is being accessed with lock "priv->driver_lock" held.
drivers/net/wireless/libertas/if_usb.c:803: missing_lock: Accessing variable "priv->dnld_sent" (lbs_private.dnld_sent) requires the lbs_private.driver_lock lock.

Error: MISSING_LOCK:
fs/afs/vlocation.c:418: example_lock: Locking "vl->lock".
fs/afs/vlocation.c:419: example_access: afs_vlocation.state is being accessed with lock "vl->lock" held.
fs/afs/vlocation.c:440: example_lock: Locking "vl->lock".
fs/afs/vlocation.c:447: example_access: afs_vlocation.state is being accessed with lock "vl->lock" held.
fs/afs/vlocation.c:472: example_lock: Locking "vl->lock".
fs/afs/vlocation.c:473: example_access: afs_vlocation.state is being accessed with lock "vl->lock" held.
fs/afs/vlocation.c:673: example_lock: Locking "vl->lock".
fs/afs/vlocation.c:677: example_access: afs_vlocation.state is being accessed with lock "vl->lock" held.
fs/afs/vlocation.c:673: example_lock: Locking "vl->lock".
fs/afs/vlocation.c:680: example_access: afs_vlocation.state is being accessed with lock "vl->lock" held.
fs/afs/vlocation.c:668: missing_lock: Accessing variable "vl->state" (afs_vlocation.state) requires the afs_vlocation.lock lock.

Error: MISSING_LOCK:
fs/fuse/dir.c:206: example_lock: Locking "fc->lock".
fs/fuse/dir.c:207: example_access: fuse_inode.nlookup is being accessed with lock "fc->lock" held.
fs/fuse/inode.c:252: example_lock: Locking "fc->lock".
fs/fuse/inode.c:253: example_access: fuse_inode.nlookup is being accessed with lock "fc->lock" held.
fs/fuse/inode.c:61: missing_lock: Accessing variable "fi->nlookup" (fuse_inode.nlookup) requires the fuse_conn.lock lock.

Error: MISSING_LOCK:
ipc/mqueue.c:279: example_lock: Locking "mq_lock".
ipc/mqueue.c:284: example_access: queues_count is being accessed with lock "mq_lock" held.
ipc/mqueue.c:290: example_lock: Locking "mq_lock".
ipc/mqueue.c:291: example_access: queues_count is being accessed with lock "mq_lock" held.
ipc/mqueue.c:264: example_lock: Locking "mq_lock".
ipc/mqueue.c:266: example_access: queues_count is being accessed with lock "mq_lock" held.
ipc/mqueue.c:1279: missing_lock: Accessing variable "queues_count" (queues_count) requires the mq_lock lock.

Error: MISSING_LOCK:
sound/oss/ad1848.c:1332: example_lock: Locking "devc->lock".
sound/oss/ad1848.c:1349: example_access: ad1848_info.audio_mode is being accessed with lock "devc->lock" held.
sound/oss/ad1848.c:1332: example_lock: Locking "devc->lock".
sound/oss/ad1848.c:1355: example_access: ad1848_info.audio_mode is being accessed with lock "devc->lock" held.
sound/oss/ad1848.c:1368: example_lock: Locking "devc->lock".
sound/oss/ad1848.c:1385: example_access: ad1848_info.audio_mode is being accessed with lock "devc->lock" held.
sound/oss/ad1848.c:1368: example_lock: Locking "devc->lock".
sound/oss/ad1848.c:1391: example_access: ad1848_info.audio_mode is being accessed with lock "devc->lock" held.
sound/oss/ad1848.c:1023: example_lock: Locking "devc->lock".
sound/oss/ad1848.c:1025: example_access: ad1848_info.audio_mode is being accessed with lock "devc->lock" held.
sound/oss/ad1848.c:1099: missing_lock: Accessing variable "devc->audio_mode" (ad1848_info.audio_mode) requires the ad1848_info.lock lock.

Error: MISSING_LOCK:
arch/x86/kernel/io_apic.c:2184: example_lock: Locking "desc->lock".
arch/x86/kernel/io_apic.c:2187: example_access: irq_desc.status is being accessed with lock "desc->lock" held.
kernel/irq/autoprobe.c:169: example_lock: Locking "desc->lock".
kernel/irq/autoprobe.c:178: example_access: irq_desc.status is being accessed with lock "desc->lock" held.
kernel/irq/autoprobe.c:71: example_lock: Locking "desc->lock".
kernel/irq/autoprobe.c:73: example_access: irq_desc.status is being accessed with lock "desc->lock" held.
kernel/irq/autoprobe.c:71: example_lock: Locking "desc->lock".
kernel/irq/autoprobe.c:75: example_access: irq_desc.status is being accessed with lock "desc->lock" held.
kernel/irq/autoprobe.c:89: example_lock: Locking "desc->lock".
kernel/irq/autoprobe.c:95: example_access: irq_desc.status is being accessed with lock "desc->lock" held.
kernel/irq/chip.c:227: missing_lock: Accessing variable "desc->status" (irq_desc.status) requires the irq_desc.lock lock.

Error: MISSING_LOCK:
drivers/scsi/lpfc/lpfc_hbadisc.c:1143: example_lock: Locking "phba->hbalock".
drivers/scsi/lpfc/lpfc_hbadisc.c:1144: example_access: lpfc_sli.sli_flag is being accessed with lock "phba->hbalock" held.
drivers/scsi/lpfc/lpfc_hbadisc.c:874: example_lock: Locking "phba->hbalock".
drivers/scsi/lpfc/lpfc_hbadisc.c:875: example_access: lpfc_sli.sli_flag is being accessed with lock "phba->hbalock" held.
drivers/scsi/lpfc/lpfc_hbadisc.c:898: example_lock: Locking "phba->hbalock".
drivers/scsi/lpfc/lpfc_hbadisc.c:899: example_access: lpfc_sli.sli_flag is being accessed with lock "phba->hbalock" held.
drivers/scsi/lpfc/lpfc_init.c:1719: example_lock: Locking "phba->hbalock".
drivers/scsi/lpfc/lpfc_init.c:1720: example_access: lpfc_sli.sli_flag is being accessed with lock "phba->hbalock" held.
drivers/scsi/lpfc/lpfc_init.c:1797: example_lock: Locking "phba->hbalock".
drivers/scsi/lpfc/lpfc_init.c:1798: example_access: lpfc_sli.sli_flag is being accessed with lock "phba->hbalock" held.
drivers/scsi/lpfc/lpfc_hbadisc.c:1209: missing_lock: Accessing variable "phba->sli.sli_flag" (lpfc_sli.sli_flag) requires the lpfc_hba.hbalock lock.

Error: MISSING_LOCK:
drivers/scsi/lpfc/lpfc_hbadisc.c:1143: example_lock: Locking "phba->hbalock".
drivers/scsi/lpfc/lpfc_hbadisc.c:1144: example_access: lpfc_sli.sli_flag is being accessed with lock "phba->hbalock" held.
drivers/scsi/lpfc/lpfc_hbadisc.c:874: example_lock: Locking "phba->hbalock".
drivers/scsi/lpfc/lpfc_hbadisc.c:875: example_access: lpfc_sli.sli_flag is being accessed with lock "phba->hbalock" held.
drivers/scsi/lpfc/lpfc_hbadisc.c:898: example_lock: Locking "phba->hbalock".
drivers/scsi/lpfc/lpfc_hbadisc.c:899: example_access: lpfc_sli.sli_flag is being accessed with lock "phba->hbalock" held.
drivers/scsi/lpfc/lpfc_init.c:1719: example_lock: Locking "phba->hbalock".
drivers/scsi/lpfc/lpfc_init.c:1720: example_access: lpfc_sli.sli_flag is being accessed with lock "phba->hbalock" held.
drivers/scsi/lpfc/lpfc_init.c:1797: example_lock: Locking "phba->hbalock".
drivers/scsi/lpfc/lpfc_init.c:1798: example_access: lpfc_sli.sli_flag is being accessed with lock "phba->hbalock" held.
drivers/scsi/lpfc/lpfc_hbadisc.c:1211: missing_lock: Accessing variable "phba->sli.sli_flag" (lpfc_sli.sli_flag) requires the lpfc_hba.hbalock lock.

Error: MISSING_LOCK:
sound/pci/echoaudio/midi.c:216: example_lock: Locking "chip->lock".
sound/pci/echoaudio/midi.c:217: example_access: echoaudio.midi_full is being accessed with lock "chip->lock" held.
sound/pci/echoaudio/midi.c:216: example_lock: Locking "chip->lock".
sound/pci/echoaudio/midi.c:227: example_access: echoaudio.midi_full is being accessed with lock "chip->lock" held.
sound/pci/echoaudio/midi.c:216: example_lock: Locking "chip->lock".
sound/pci/echoaudio/midi.c:236: example_access: echoaudio.midi_full is being accessed with lock "chip->lock" held.
sound/pci/echoaudio/midi.c:197: missing_lock: Accessing variable "chip->midi_full" (echoaudio.midi_full) requires the echoaudio.lock lock.

Error: MISSING_LOCK:
drivers/isdn/capi/capi.c:1265: example_lock: Locking "workaround_lock".
drivers/isdn/capi/capi.c:1266: example_access: capiminor.ttyinstop is being accessed with lock "workaround_lock" held.
drivers/isdn/capi/capi.c:1254: missing_lock: Accessing variable "mp->ttyinstop" (capiminor.ttyinstop) requires the workaround_lock lock.

Error: MISSING_LOCK:
drivers/isdn/capi/capi.c:1291: example_lock: Locking "workaround_lock".
drivers/isdn/capi/capi.c:1292: example_access: capiminor.ttyoutstop is being accessed with lock "workaround_lock" held.
drivers/isdn/capi/capi.c:1279: missing_lock: Accessing variable "mp->ttyoutstop" (capiminor.ttyoutstop) requires the workaround_lock lock.

Error: MISSING_LOCK:
sound/oss/ad1848.c:1332: example_lock: Locking "devc->lock".
sound/oss/ad1848.c:1349: example_access: ad1848_info.audio_mode is being accessed with lock "devc->lock" held.
sound/oss/ad1848.c:1332: example_lock: Locking "devc->lock".
sound/oss/ad1848.c:1355: example_access: ad1848_info.audio_mode is being accessed with lock "devc->lock" held.
sound/oss/ad1848.c:1368: example_lock: Locking "devc->lock".
sound/oss/ad1848.c:1385: example_access: ad1848_info.audio_mode is being accessed with lock "devc->lock" held.
sound/oss/ad1848.c:1368: example_lock: Locking "devc->lock".
sound/oss/ad1848.c:1391: example_access: ad1848_info.audio_mode is being accessed with lock "devc->lock" held.
sound/oss/ad1848.c:1023: example_lock: Locking "devc->lock".
sound/oss/ad1848.c:1025: example_access: ad1848_info.audio_mode is being accessed with lock "devc->lock" held.
sound/oss/ad1848.c:1058: missing_lock: Accessing variable "devc->audio_mode" (ad1848_info.audio_mode) requires the ad1848_info.lock lock.

Error: MISSING_LOCK:
drivers/net/wireless/libertas/cmd.c:1835: example_lock: Locking "priv->driver_lock".
drivers/net/wireless/libertas/cmd.c:1838: example_access: lbs_private.dnld_sent is being accessed with lock "priv->driver_lock" held.
drivers/net/wireless/libertas/if_cs.c:404: example_lock: Locking "priv->driver_lock".
drivers/net/wireless/libertas/if_cs.c:405: example_access: lbs_private.dnld_sent is being accessed with lock "priv->driver_lock" held.
drivers/net/wireless/libertas/if_usb.c:911: example_lock: Locking "priv->driver_lock".
drivers/net/wireless/libertas/if_usb.c:913: example_access: lbs_private.dnld_sent is being accessed with lock "priv->driver_lock" held.
drivers/net/wireless/libertas/if_usb.c:918: example_lock: Locking "priv->driver_lock".
drivers/net/wireless/libertas/if_usb.c:919: example_access: lbs_private.dnld_sent is being accessed with lock "priv->driver_lock" held.
drivers/net/wireless/libertas/main.c:513: example_lock: Locking "priv->driver_lock".
drivers/net/wireless/libertas/main.c:515: example_access: lbs_private.dnld_sent is being accessed with lock "priv->driver_lock" held.
drivers/net/wireless/libertas/if_sdio.c:734: missing_lock: Accessing variable "priv->dnld_sent" (lbs_private.dnld_sent) requires the lbs_private.driver_lock lock.

Error: MISSING_LOCK:
drivers/net/wireless/libertas/cmd.c:1835: example_lock: Locking "priv->driver_lock".
drivers/net/wireless/libertas/cmd.c:1838: example_access: lbs_private.dnld_sent is being accessed with lock "priv->driver_lock" held.
drivers/net/wireless/libertas/if_cs.c:404: example_lock: Locking "priv->driver_lock".
drivers/net/wireless/libertas/if_cs.c:405: example_access: lbs_private.dnld_sent is being accessed with lock "priv->driver_lock" held.
drivers/net/wireless/libertas/if_usb.c:911: example_lock: Locking "priv->driver_lock".
drivers/net/wireless/libertas/if_usb.c:913: example_access: lbs_private.dnld_sent is being accessed with lock "priv->driver_lock" held.
drivers/net/wireless/libertas/if_usb.c:918: example_lock: Locking "priv->driver_lock".
drivers/net/wireless/libertas/if_usb.c:919: example_access: lbs_private.dnld_sent is being accessed with lock "priv->driver_lock" held.
drivers/net/wireless/libertas/main.c:513: example_lock: Locking "priv->driver_lock".
drivers/net/wireless/libertas/main.c:515: example_access: lbs_private.dnld_sent is being accessed with lock "priv->driver_lock" held.
drivers/net/wireless/libertas/if_sdio.c:737: missing_lock: Accessing variable "priv->dnld_sent" (lbs_private.dnld_sent) requires the lbs_private.driver_lock lock.

Error: MISSING_LOCK:
drivers/net/wireless/iwlwifi/iwl3945-base.c:6616: example_lock: Locking "priv->lock".
drivers/net/wireless/iwlwifi/iwl3945-base.c:6617: example_access: iwl3945_priv.vif is being accessed with lock "priv->lock" held.
drivers/net/wireless/iwlwifi/iwl3945-base.c:6941: missing_lock: Accessing variable "priv->vif" (iwl3945_priv.vif) requires the iwl3945_priv.lock lock.

Error: MISSING_LOCK:
net/atm/mpoa_caches.c:460: example_lock: Locking "client->egress_lock".
net/atm/mpoa_caches.c:461: example_access: eg_cache_entry.next is being accessed with lock "client->egress_lock" held.
net/atm/mpoa_caches.c:423: missing_lock: Accessing variable "entry->prev->next" (eg_cache_entry.next) requires the mpoa_client.egress_lock lock.

Error: MISSING_LOCK:
drivers/message/fusion/mptctl.c:456: example_lock: Locking "ioc->FreeQlock".
drivers/message/fusion/mptctl.c:459: example_access: _MPT_SCSI_HOST.tmPending is being accessed with lock "ioc->FreeQlock" held.
drivers/message/fusion/mptctl.c:432: example_lock: Locking "hd->ioc->FreeQlock".
drivers/message/fusion/mptctl.c:436: example_access: _MPT_SCSI_HOST.tmPending is being accessed with lock "hd->ioc->FreeQlock" held.
drivers/message/fusion/mptsas.c:3178: example_lock: Locking "ioc->FreeQlock".
drivers/message/fusion/mptsas.c:3255: example_access: _MPT_SCSI_HOST.tmPending is being accessed with lock "ioc->FreeQlock" held.
drivers/message/fusion/mptscsih.c:2699: example_lock: Locking "ioc->FreeQlock".
drivers/message/fusion/mptscsih.c:2700: example_access: _MPT_SCSI_HOST.tmPending is being accessed with lock "ioc->FreeQlock" held.
drivers/message/fusion/mptscsih.c:2234: example_lock: Locking "ioc->FreeQlock".
drivers/message/fusion/mptscsih.c:2235: example_access: _MPT_SCSI_HOST.tmPending is being accessed with lock "ioc->FreeQlock" held.
drivers/message/fusion/mptscsih.c:2028: missing_lock: Accessing variable "hd->tmPending" (_MPT_SCSI_HOST.tmPending) requires the _MPT_ADAPTER.FreeQlock lock.

Error: MISSING_LOCK:
drivers/isdn/divert/divert_procfs.c:158: example_lock: Locking "divert_info_lock".
drivers/isdn/divert/divert_procfs.c:162: example_access: divert_info.usage_cnt is being accessed with lock "divert_info_lock" held.
drivers/isdn/divert/divert_procfs.c:52: example_lock: Locking "divert_info_lock".
drivers/isdn/divert/divert_procfs.c:53: example_access: divert_info.usage_cnt is being accessed with lock "divert_info_lock" held.
drivers/isdn/divert/divert_procfs.c:93: missing_lock: Accessing variable "inf->usage_cnt" (divert_info.usage_cnt) requires the divert_info_lock lock.

Error: MISSING_LOCK:
drivers/scsi/gdth.c:3948: example_lock: Locking "ha->smp_lock".
drivers/scsi/gdth.c:3949: example_access: gdth_polling is being accessed with lock "ha->smp_lock" held.
drivers/scsi/gdth.c:3948: example_lock: Locking "ha->smp_lock".
drivers/scsi/gdth.c:3955: example_access: gdth_polling is being accessed with lock "ha->smp_lock" held.
drivers/scsi/gdth.c:3961: example_lock: Locking "ha->smp_lock".
drivers/scsi/gdth.c:3964: example_access: gdth_polling is being accessed with lock "ha->smp_lock" held.
drivers/scsi/gdth.c:3961: example_lock: Locking "ha->smp_lock".
drivers/scsi/gdth.c:3969: example_access: gdth_polling is being accessed with lock "ha->smp_lock" held.
drivers/scsi/gdth.c:5153: missing_lock: Accessing variable "gdth_polling" (gdth_polling) requires the gdth_ha_str.smp_lock lock.

Error: MISSING_LOCK:
drivers/scsi/gdth.c:3948: example_lock: Locking "ha->smp_lock".
drivers/scsi/gdth.c:3949: example_access: gdth_polling is being accessed with lock "ha->smp_lock" held.
drivers/scsi/gdth.c:3948: example_lock: Locking "ha->smp_lock".
drivers/scsi/gdth.c:3955: example_access: gdth_polling is being accessed with lock "ha->smp_lock" held.
drivers/scsi/gdth.c:3961: example_lock: Locking "ha->smp_lock".
drivers/scsi/gdth.c:3964: example_access: gdth_polling is being accessed with lock "ha->smp_lock" held.
drivers/scsi/gdth.c:3961: example_lock: Locking "ha->smp_lock".
drivers/scsi/gdth.c:3969: example_access: gdth_polling is being accessed with lock "ha->smp_lock" held.
drivers/scsi/gdth.c:5191: missing_lock: Accessing variable "gdth_polling" (gdth_polling) requires the gdth_ha_str.smp_lock lock.

Error: MISSING_LOCK:
fs/afs/dir.c:668: example_lock: Locking "dentry->d_lock".
fs/afs/dir.c:669: example_access: dentry.d_flags is being accessed with lock "dentry->d_lock" held.
fs/autofs4/root.c:129: example_lock: Locking "dentry->d_lock".
fs/autofs4/root.c:130: example_access: dentry.d_flags is being accessed with lock "dentry->d_lock" held.
fs/autofs4/root.c:144: example_lock: Locking "dentry->d_lock".
fs/autofs4/root.c:145: example_access: dentry.d_flags is being accessed with lock "dentry->d_lock" held.
fs/autofs4/root.c:152: example_lock: Locking "dentry->d_lock".
fs/autofs4/root.c:153: example_access: dentry.d_flags is being accessed with lock "dentry->d_lock" held.
fs/autofs4/root.c:163: example_lock: Locking "dentry->d_lock".
fs/autofs4/root.c:164: example_access: dentry.d_flags is being accessed with lock "dentry->d_lock" held.
fs/pipe.c:860: missing_lock: Accessing variable "dentry->d_flags" (dentry.d_flags) requires the dentry.d_lock lock.

Error: MISSING_LOCK:
drivers/net/wireless/iwlwifi/iwl3945-base.c:4298: example_lock: Locking "priv->lock".
drivers/net/wireless/iwlwifi/iwl3945-base.c:4299: example_access: iwl3945_priv.assoc_id is being accessed with lock "priv->lock" held.
drivers/net/wireless/iwlwifi/iwl3945-base.c:7310: example_lock: Locking "priv->lock".
drivers/net/wireless/iwlwifi/iwl3945-base.c:7317: example_access: iwl3945_priv.assoc_id is being accessed with lock "priv->lock" held.
drivers/net/wireless/iwlwifi/iwl3945-base.c:7240: example_lock: Locking "priv->lock".
drivers/net/wireless/iwlwifi/iwl3945-base.c:7241: example_access: iwl3945_priv.assoc_id is being accessed with lock "priv->lock" held.
drivers/net/wireless/iwlwifi/iwl3945-base.c:6986: missing_lock: Accessing variable "priv->assoc_id" (iwl3945_priv.assoc_id) requires the iwl3945_priv.lock lock.

Error: MISSING_LOCK:
drivers/net/wireless/iwlwifi/iwl3945-base.c:4298: example_lock: Locking "priv->lock".
drivers/net/wireless/iwlwifi/iwl3945-base.c:4299: example_access: iwl3945_priv.assoc_id is being accessed with lock "priv->lock" held.
drivers/net/wireless/iwlwifi/iwl3945-base.c:7310: example_lock: Locking "priv->lock".
drivers/net/wireless/iwlwifi/iwl3945-base.c:7317: example_access: iwl3945_priv.assoc_id is being accessed with lock "priv->lock" held.
drivers/net/wireless/iwlwifi/iwl3945-base.c:7240: example_lock: Locking "priv->lock".
drivers/net/wireless/iwlwifi/iwl3945-base.c:7241: example_access: iwl3945_priv.assoc_id is being accessed with lock "priv->lock" held.
drivers/net/wireless/iwlwifi/iwl3945-base.c:6998: missing_lock: Accessing variable "priv->assoc_id" (iwl3945_priv.assoc_id) requires the iwl3945_priv.lock lock.

Error: MISSING_LOCK:
drivers/net/wireless/iwlwifi/iwl-agn.c:2735: example_lock: Locking "priv->lock".
drivers/net/wireless/iwlwifi/iwl-agn.c:2736: example_access: iwl_priv.vif is being accessed with lock "priv->lock" held.
drivers/net/wireless/iwlwifi/iwl-agn.c:3097: missing_lock: Accessing variable "priv->vif" (iwl_priv.vif) requires the iwl_priv.lock lock.

Error: MISSING_LOCK:
drivers/isdn/gigaset/common.c:857: example_lock: Locking "cs->lock".
drivers/isdn/gigaset/common.c:858: example_access: cardstate.connected is being accessed with lock "cs->lock" held.
drivers/isdn/gigaset/ev-layer.c:1038: example_lock: Locking "cs->lock".
drivers/isdn/gigaset/ev-layer.c:1039: example_access: cardstate.connected is being accessed with lock "cs->lock" held.
drivers/isdn/gigaset/usb-gigaset.c:883: missing_lock: Accessing variable "cs->connected" (cardstate.connected) requires the cardstate.lock lock.

Error: MISSING_LOCK:
drivers/char/rio/riocmd.c:345: example_lock: Locking "PortP->portSem".
drivers/char/rio/riocmd.c:347: example_access: Port.State is being accessed with lock "PortP->portSem" held.
drivers/char/rio/riocmd.c:415: example_lock: Locking "PortP->portSem".
drivers/char/rio/riocmd.c:504: example_access: Port.State is being accessed with lock "PortP->portSem" held.
drivers/char/rio/riocmd.c:415: example_lock: Locking "PortP->portSem".
drivers/char/rio/riocmd.c:518: example_access: Port.State is being accessed with lock "PortP->portSem" held.
drivers/char/rio/rioctrl.c:420: example_lock: Locking "PortP->portSem".
drivers/char/rio/rioctrl.c:428: example_access: Port.State is being accessed with lock "PortP->portSem" held.
drivers/char/rio/rioctrl.c:973: example_lock: Locking "PortP->portSem".
drivers/char/rio/rioctrl.c:974: example_access: Port.State is being accessed with lock "PortP->portSem" held.
drivers/char/rio/rio_linux.c:670: missing_lock: Accessing variable "port->State" (Port.State) requires the Port.portSem lock.

Error: MISSING_LOCK:
drivers/net/wan/sbni.c:1436: example_lock: Locking "snl->lock".
drivers/net/wan/sbni.c:1443: example_access: net_local.link is being accessed with lock "snl->lock" held.
drivers/net/wan/sbni.c:1436: example_lock: Locking "snl->lock".
drivers/net/wan/sbni.c:1449: example_access: net_local.link is being accessed with lock "snl->lock" held.
drivers/net/wan/sbni.c:1403: example_lock: Locking "snl->lock".
drivers/net/wan/sbni.c:1406: example_access: net_local.link is being accessed with lock "snl->lock" held.
drivers/net/wan/sbni.c:1403: example_lock: Locking "snl->lock".
drivers/net/wan/sbni.c:1407: example_access: net_local.link is being accessed with lock "snl->lock" held.
drivers/net/wireless/wavelan_cs.c:4600: missing_lock: Accessing variable "((net_local *)netdev_priv(dev))->link" (net_local.link) requires the net_local.lock lock.

Error: MISSING_LOCK:
drivers/scsi/lpfc/lpfc_els.c:1817: example_lock: Locking "shost->host_lock".
drivers/scsi/lpfc/lpfc_els.c:1818: example_access: lpfc_nodelist.nlp_flag is being accessed with lock "shost->host_lock" held.
drivers/scsi/lpfc/lpfc_els.c:1821: example_lock: Locking "shost->host_lock".
drivers/scsi/lpfc/lpfc_els.c:1822: example_access: lpfc_nodelist.nlp_flag is being accessed with lock "shost->host_lock" held.
drivers/scsi/lpfc/lpfc_els.c:2253: example_lock: Locking "shost->host_lock".
drivers/scsi/lpfc/lpfc_els.c:2254: example_access: lpfc_nodelist.nlp_flag is being accessed with lock "shost->host_lock" held.
drivers/scsi/lpfc/lpfc_els.c:2265: example_lock: Locking "shost->host_lock".
drivers/scsi/lpfc/lpfc_els.c:2266: example_access: lpfc_nodelist.nlp_flag is being accessed with lock "shost->host_lock" held.
drivers/scsi/lpfc/lpfc_els.c:3656: example_lock: Locking "shost->host_lock".
drivers/scsi/lpfc/lpfc_els.c:3657: example_access: lpfc_nodelist.nlp_flag is being accessed with lock "shost->host_lock" held.
drivers/scsi/lpfc/lpfc_nportdisc.c:1776: missing_lock: Accessing variable "ndlp->nlp_flag" (lpfc_nodelist.nlp_flag) requires the Scsi_Host.host_lock lock.

Error: MISSING_LOCK:
drivers/net/wan/hdlc.c:191: example_lock: Locking "hdlc->state_lock".
drivers/net/wan/hdlc.c:193: example_access: hdlc_device.open is being accessed with lock "hdlc->state_lock" held.
drivers/net/wan/hdlc.c:166: example_lock: Locking "hdlc->state_lock".
drivers/net/wan/hdlc.c:174: example_access: hdlc_device.open is being accessed with lock "hdlc->state_lock" held.
drivers/net/wan/hdlc.c:253: missing_lock: Accessing variable "hdlc->open" (hdlc_device.open) requires the hdlc_device.state_lock lock.

Error: MISSING_LOCK:
sound/pci/oxygen/oxygen_lib.c:549: example_lock: Locking "chip->reg_lock".
sound/pci/oxygen/oxygen_lib.c:551: example_access: oxygen.interrupt_mask is being accessed with lock "chip->reg_lock" held.
sound/pci/oxygen/oxygen_lib.c:549: example_lock: Locking "chip->reg_lock".
sound/pci/oxygen/oxygen_lib.c:553: example_access: oxygen.interrupt_mask is being accessed with lock "chip->reg_lock" held.
sound/pci/oxygen/oxygen_lib.c:439: example_lock: Locking "chip->reg_lock".
sound/pci/oxygen/oxygen_lib.c:440: example_access: oxygen.interrupt_mask is being accessed with lock "chip->reg_lock" held.
sound/pci/oxygen/oxygen_lib.c:71: example_lock: Locking "chip->reg_lock".
sound/pci/oxygen/oxygen_lib.c:84: example_access: oxygen.interrupt_mask is being accessed with lock "chip->reg_lock" held.
sound/pci/oxygen/oxygen_lib.c:597: example_lock: Locking "chip->reg_lock".
sound/pci/oxygen/oxygen_lib.c:599: example_access: oxygen.interrupt_mask is being accessed with lock "chip->reg_lock" held.
sound/pci/oxygen/oxygen_lib.c:606: missing_lock: Accessing variable "chip->interrupt_mask" (oxygen.interrupt_mask) requires the oxygen.reg_lock lock.

Error: MISSING_LOCK:
drivers/net/wireless/orinoco.c:3466: example_lock: Locking "priv->lock".
drivers/net/wireless/orinoco.c:3467: example_access: orinoco_private.hw_unavailable is being accessed with lock "priv->lock" held.
drivers/net/wireless/orinoco.c:2942: example_lock: Locking "priv->lock".
drivers/net/wireless/orinoco.c:2944: example_access: orinoco_private.hw_unavailable is being accessed with lock "priv->lock" held.
drivers/net/wireless/orinoco_cs.c:338: example_lock: Locking "priv->lock".
drivers/net/wireless/orinoco_cs.c:339: example_access: orinoco_private.hw_unavailable is being accessed with lock "priv->lock" held.
drivers/net/wireless/orinoco_cs.c:391: example_lock: Locking "priv->lock".
drivers/net/wireless/orinoco_cs.c:394: example_access: orinoco_private.hw_unavailable is being accessed with lock "priv->lock" held.
drivers/net/wireless/orinoco_cs.c:359: example_lock: Locking "priv->lock".
drivers/net/wireless/orinoco_cs.c:367: example_access: orinoco_private.hw_unavailable is being accessed with lock "priv->lock" held.
drivers/net/wireless/spectrum_cs.c:455: missing_lock: Accessing variable "priv->hw_unavailable" (orinoco_private.hw_unavailable) requires the orinoco_private.lock lock.

Error: MISSING_LOCK:
net/irda/irlap.c:1109: example_lock: Locking "irlap->hb_spinlock".
net/irda/irlap.c:1110: example_access: irlap_iter_state.id is being accessed with lock "irlap->hb_spinlock" held.
net/irda/irlap.c:1109: example_lock: Locking "irlap->hb_spinlock".
net/irda/irlap.c:1116: example_access: irlap_iter_state.id is being accessed with lock "irlap->hb_spinlock" held.
net/irda/irlap.c:1127: missing_lock: Accessing variable "iter->id" (irlap_iter_state.id) requires the hashbin_t.hb_spinlock lock.

Error: MISSING_LOCK:
drivers/scsi/scsi_transport_fc.c:2473: example_lock: Locking "shost->host_lock".
drivers/scsi/scsi_transport_fc.c:2475: example_access: fc_host_attrs.next_rport_number is being accessed with lock "shost->host_lock" held.
drivers/scsi/scsi_transport_fc.c:391: missing_lock: Accessing variable "fc_host->next_rport_number" (fc_host_attrs.next_rport_number) requires the Scsi_Host.host_lock lock.

Error: MISSING_LOCK:
net/packet/af_packet.c:930: example_lock: Locking "po->bind_lock".
net/packet/af_packet.c:934: example_access: packet_sock.num is being accessed with lock "po->bind_lock" held.
net/packet/af_packet.c:937: example_lock: Locking "po->bind_lock".
net/packet/af_packet.c:940: example_access: packet_sock.num is being accessed with lock "po->bind_lock" held.
net/packet/af_packet.c:1852: example_lock: Locking "po->bind_lock".
net/packet/af_packet.c:1857: example_access: packet_sock.num is being accessed with lock "po->bind_lock" held.
net/packet/af_packet.c:1888: example_lock: Locking "po->bind_lock".
net/packet/af_packet.c:1892: example_access: packet_sock.num is being accessed with lock "po->bind_lock" held.
net/packet/af_packet.c:1061: missing_lock: Accessing variable "po->num" (packet_sock.num) requires the packet_sock.bind_lock lock.

Error: MISSING_LOCK:
net/atm/lec.c:2372: example_lock: Locking "priv->lec_arp_lock".
net/atm/lec.c:2381: example_access: lec_arp_table.status is being accessed with lock "priv->lec_arp_lock" held.
net/atm/lec.c:2158: example_lock: Locking "priv->lec_arp_lock".
net/atm/lec.c:2207: example_access: lec_arp_table.status is being accessed with lock "priv->lec_arp_lock" held.
net/atm/lec.c:2158: example_lock: Locking "priv->lec_arp_lock".
net/atm/lec.c:2245: example_access: lec_arp_table.status is being accessed with lock "priv->lec_arp_lock" held.
net/atm/lec.c:2158: example_lock: Locking "priv->lec_arp_lock".
net/atm/lec.c:2249: example_access: lec_arp_table.status is being accessed with lock "priv->lec_arp_lock" held.
net/atm/lec.c:2158: example_lock: Locking "priv->lec_arp_lock".
net/atm/lec.c:2291: example_access: lec_arp_table.status is being accessed with lock "priv->lec_arp_lock" held.
net/atm/lec.c:1906: missing_lock: Accessing variable "entry->status" (lec_arp_table.status) requires the lec_priv.lec_arp_lock lock.

Error: MISSING_LOCK:
drivers/net/wireless/libertas/cmd.c:1835: example_lock: Locking "priv->driver_lock".
drivers/net/wireless/libertas/cmd.c:1838: example_access: lbs_private.dnld_sent is being accessed with lock "priv->driver_lock" held.
drivers/net/wireless/libertas/if_cs.c:404: example_lock: Locking "priv->driver_lock".
drivers/net/wireless/libertas/if_cs.c:405: example_access: lbs_private.dnld_sent is being accessed with lock "priv->driver_lock" held.
drivers/net/wireless/libertas/if_usb.c:911: example_lock: Locking "priv->driver_lock".
drivers/net/wireless/libertas/if_usb.c:913: example_access: lbs_private.dnld_sent is being accessed with lock "priv->driver_lock" held.
drivers/net/wireless/libertas/if_usb.c:918: example_lock: Locking "priv->driver_lock".
drivers/net/wireless/libertas/if_usb.c:919: example_access: lbs_private.dnld_sent is being accessed with lock "priv->driver_lock" held.
drivers/net/wireless/libertas/main.c:513: example_lock: Locking "priv->driver_lock".
drivers/net/wireless/libertas/main.c:515: example_access: lbs_private.dnld_sent is being accessed with lock "priv->driver_lock" held.
drivers/net/wireless/libertas/if_cs.c:707: missing_lock: Accessing variable "priv->dnld_sent" (lbs_private.dnld_sent) requires the lbs_private.driver_lock lock.

Error: MISSING_LOCK:
drivers/net/wireless/libertas/cmd.c:1835: example_lock: Locking "priv->driver_lock".
drivers/net/wireless/libertas/cmd.c:1838: example_access: lbs_private.dnld_sent is being accessed with lock "priv->driver_lock" held.
drivers/net/wireless/libertas/if_cs.c:404: example_lock: Locking "priv->driver_lock".
drivers/net/wireless/libertas/if_cs.c:405: example_access: lbs_private.dnld_sent is being accessed with lock "priv->driver_lock" held.
drivers/net/wireless/libertas/if_usb.c:911: example_lock: Locking "priv->driver_lock".
drivers/net/wireless/libertas/if_usb.c:913: example_access: lbs_private.dnld_sent is being accessed with lock "priv->driver_lock" held.
drivers/net/wireless/libertas/if_usb.c:918: example_lock: Locking "priv->driver_lock".
drivers/net/wireless/libertas/if_usb.c:919: example_access: lbs_private.dnld_sent is being accessed with lock "priv->driver_lock" held.
drivers/net/wireless/libertas/main.c:513: example_lock: Locking "priv->driver_lock".
drivers/net/wireless/libertas/main.c:515: example_access: lbs_private.dnld_sent is being accessed with lock "priv->driver_lock" held.
drivers/net/wireless/libertas/if_cs.c:712: missing_lock: Accessing variable "priv->dnld_sent" (lbs_private.dnld_sent) requires the lbs_private.driver_lock lock.

Error: MISSING_LOCK:
drivers/usb/class/cdc-acm.c:1291: example_lock: Locking "acm->write_lock".
drivers/usb/class/cdc-acm.c:1292: example_access: acm.susp_count is being accessed with lock "acm->write_lock" held.
drivers/usb/class/cdc-acm.c:1318: missing_lock: Accessing variable "acm->susp_count" (acm.susp_count) requires the acm.write_lock lock.

Error: MISSING_LOCK:
drivers/usb/serial/oti6858.c:976: example_lock: Locking "priv->lock".
drivers/usb/serial/oti6858.c:977: example_access: oti6858_private.flags.read_urb_in_use is being accessed with lock "priv->lock" held.
drivers/usb/serial/oti6858.c:880: example_lock: Locking "priv->lock".
drivers/usb/serial/oti6858.c:918: example_access: oti6858_private.flags.read_urb_in_use is being accessed with lock "priv->lock" held.
drivers/usb/serial/oti6858.c:931: missing_lock: Accessing variable "priv->flags.read_urb_in_use" (oti6858_private.flags.read_urb_in_use) requires the oti6858_private.lock lock.

Error: MISSING_LOCK:
drivers/char/stallion.c:2768: example_lock: Locking "brd_lock".
drivers/char/stallion.c:2769: example_access: stlport.ioaddr is being accessed with lock "brd_lock" held.
drivers/char/stallion.c:3774: missing_lock: Accessing variable "portp->ioaddr" (stlport.ioaddr) requires the brd_lock lock.

Error: MISSING_LOCK:
mm/swapfile.c:1334: example_lock: Locking "swap_lock".
mm/swapfile.c:1338: example_access: swap_info_struct.swap_file is being accessed with lock "swap_lock" held.
mm/swapfile.c:1733: example_lock: Locking "swap_lock".
mm/swapfile.c:1734: example_access: swap_info_struct.swap_file is being accessed with lock "swap_lock" held.
mm/swapfile.c:1524: missing_lock: Accessing variable "p->swap_file" (swap_info_struct.swap_file) requires the swap_lock lock.

Error: MISSING_LOCK:
drivers/video/console/vgacon.c:742: example_lock: Locking "vga_lock".
drivers/video/console/vgacon.c:744: example_access: vgacon_xres is being accessed with lock "vga_lock" held.
drivers/video/console/vgacon.c:531: missing_lock: Accessing variable "vgacon_xres" (vgacon_xres) requires the vga_lock lock.

Error: MISSING_LOCK:
drivers/media/dvb/dvb-core/dvb_demux.c:903: example_lock: Locking "dvbdmx->lock".
drivers/media/dvb/dvb-core/dvb_demux.c:904: example_access: dmx_section_feed.is_filtering is being accessed with lock "dvbdmx->lock" held.
drivers/media/dvb/dvb-core/dvb_demux.c:927: example_lock: Locking "dvbdmx->lock".
drivers/media/dvb/dvb-core/dvb_demux.c:929: example_access: dmx_section_feed.is_filtering is being accessed with lock "dvbdmx->lock" held.
drivers/media/dvb/dvb-core/dvb_demux.c:996: missing_lock: Accessing variable "(*feed)->is_filtering" (dmx_section_feed.is_filtering) requires the dvb_demux.lock lock.

Error: MISSING_LOCK:
drivers/media/dvb/dvb-core/dvb_demux.c:662: example_lock: Locking "demux->lock".
drivers/media/dvb/dvb-core/dvb_demux.c:663: example_access: dmx_ts_feed.is_filtering is being accessed with lock "demux->lock" held.
drivers/media/dvb/dvb-core/dvb_demux.c:691: example_lock: Locking "demux->lock".
drivers/media/dvb/dvb-core/dvb_demux.c:692: example_access: dmx_ts_feed.is_filtering is being accessed with lock "demux->lock" held.
drivers/media/dvb/dvb-core/dvb_demux.c:725: missing_lock: Accessing variable "(*ts_feed)->is_filtering" (dmx_ts_feed.is_filtering) requires the dvb_demux.lock lock.

Error: MISSING_LOCK:
drivers/mmc/host/tifm_sd.c:1006: example_lock: Locking "sock->lock".
drivers/mmc/host/tifm_sd.c:1007: example_access: tifm_sd.eject is being accessed with lock "sock->lock" held.
drivers/mmc/host/tifm_sd.c:1048: missing_lock: Accessing variable "host->eject" (tifm_sd.eject) requires the tifm_dev.lock lock.

Error: MISSING_LOCK:
fs/ocfs2/alloc.c:6353: example_lock: Locking "OCFS2_I(inode)->ip_lock".
fs/ocfs2/alloc.c:6354: example_access: ocfs2_inode_info.ip_clusters is being accessed with lock "OCFS2_I(inode)->ip_lock" held.
fs/ocfs2/alloc.c:163: example_lock: Locking "OCFS2_I(inode)->ip_lock".
fs/ocfs2/alloc.c:164: example_access: ocfs2_inode_info.ip_clusters is being accessed with lock "OCFS2_I(inode)->ip_lock" held.
fs/ocfs2/dlmglue.c:1887: example_lock: Locking "oi->ip_lock".
fs/ocfs2/dlmglue.c:1888: example_access: ocfs2_inode_info.ip_clusters is being accessed with lock "oi->ip_lock" held.
fs/ocfs2/inode.c:1243: example_lock: Locking "OCFS2_I(inode)->ip_lock".
fs/ocfs2/inode.c:1245: example_access: ocfs2_inode_info.ip_clusters is being accessed with lock "OCFS2_I(inode)->ip_lock" held.
fs/ocfs2/resize.c:610: example_lock: Locking "OCFS2_I(main_bm_inode)->ip_lock".
fs/ocfs2/resize.c:611: example_access: ocfs2_inode_info.ip_clusters is being accessed with lock "OCFS2_I(main_bm_inode)->ip_lock" held.
fs/ocfs2/super.c:1176: missing_lock: Accessing variable "oi->ip_clusters" (ocfs2_inode_info.ip_clusters) requires the ocfs2_inode_info.ip_lock lock.

Error: MISSING_LOCK:
drivers/net/b44.c:1913: example_lock: Locking "bp->lock".
drivers/net/b44.c:1915: example_access: b44.rx_pending is being accessed with lock "bp->lock" held.
drivers/net/b44.c:2148: missing_lock: Accessing variable "bp->rx_pending" (b44.rx_pending) requires the b44.lock lock.

Error: MISSING_LOCK:
drivers/usb/class/usblp.c:994: example_lock: Locking "usblp->lock".
drivers/usb/class/usblp.c:995: example_access: usblp.readcount is being accessed with lock "usblp->lock" held.
drivers/usb/class/usblp.c:839: missing_lock: Accessing variable "usblp->readcount" (usblp.readcount) requires the usblp.lock lock.

Error: MISSING_LOCK:
drivers/scsi/qla1280.c:1119: example_lock: Locking "ha->host->host_lock".
drivers/scsi/qla1280.c:1121: example_access: scsi_qla_host.isr_count is being accessed with lock "ha->host->host_lock" held.
drivers/scsi/qla4xxx/ql4_isr.c:621: missing_lock: Accessing variable "ha->isr_count" (scsi_qla_host.isr_count) requires the Scsi_Host.host_lock lock.

Error: MISSING_LOCK:
drivers/usb/gadget/printer.c:505: example_lock: Locking "dev->lock".
drivers/usb/gadget/printer.c:506: example_access: printer_dev.printer_cdev_open is being accessed with lock "dev->lock" held.
drivers/usb/gadget/printer.c:482: example_lock: Locking "dev->lock".
drivers/usb/gadget/printer.c:485: example_access: printer_dev.printer_cdev_open is being accessed with lock "dev->lock" held.
drivers/usb/gadget/printer.c:1494: missing_lock: Accessing variable "dev->printer_cdev_open" (printer_dev.printer_cdev_open) requires the printer_dev.lock lock.

Error: MISSING_LOCK:
sound/usb/usbaudio.c:577: example_lock: Locking "subs->lock".
sound/usb/usbaudio.c:629: example_access: snd_usb_substream.hwptr_done is being accessed with lock "subs->lock" held.
sound/usb/usbaudio.c:577: example_lock: Locking "subs->lock".
sound/usb/usbaudio.c:631: example_access: snd_usb_substream.hwptr_done is being accessed with lock "subs->lock" held.
sound/usb/usbaudio.c:361: example_lock: Locking "subs->lock".
sound/usb/usbaudio.c:363: example_access: snd_usb_substream.hwptr_done is being accessed with lock "subs->lock" held.
sound/usb/usbaudio.c:361: example_lock: Locking "subs->lock".
sound/usb/usbaudio.c:365: example_access: snd_usb_substream.hwptr_done is being accessed with lock "subs->lock" held.
sound/usb/usbaudio.c:1542: missing_lock: Accessing variable "subs->hwptr_done" (snd_usb_substream.hwptr_done) requires the snd_usb_substream.lock lock.

Error: MISSING_LOCK:
sound/usb/usbaudio.c:577: example_lock: Locking "subs->lock".
sound/usb/usbaudio.c:585: example_access: snd_usb_substream.transfer_done is being accessed with lock "subs->lock" held.
sound/usb/usbaudio.c:577: example_lock: Locking "subs->lock".
sound/usb/usbaudio.c:587: example_access: snd_usb_substream.transfer_done is being accessed with lock "subs->lock" held.
sound/usb/usbaudio.c:577: example_lock: Locking "subs->lock".
sound/usb/usbaudio.c:597: example_access: snd_usb_substream.transfer_done is being accessed with lock "subs->lock" held.
sound/usb/usbaudio.c:361: example_lock: Locking "subs->lock".
sound/usb/usbaudio.c:366: example_access: snd_usb_substream.transfer_done is being accessed with lock "subs->lock" held.
sound/usb/usbaudio.c:361: example_lock: Locking "subs->lock".
sound/usb/usbaudio.c:368: example_access: snd_usb_substream.transfer_done is being accessed with lock "subs->lock" held.
sound/usb/usbaudio.c:1543: missing_lock: Accessing variable "subs->transfer_done" (snd_usb_substream.transfer_done) requires the snd_usb_substream.lock lock.

Error: MISSING_LOCK:
drivers/usb/host/sl811-hcd.c:1212: example_lock: Locking "sl811->lock".
drivers/usb/host/sl811-hcd.c:1231: example_access: sl811.port1 is being accessed with lock "sl811->lock" held.
drivers/usb/host/sl811-hcd.c:1212: example_lock: Locking "sl811->lock".
drivers/usb/host/sl811-hcd.c:1265: example_access: sl811.port1 is being accessed with lock "sl811->lock" held.
drivers/usb/host/sl811-hcd.c:1212: example_lock: Locking "sl811->lock".
drivers/usb/host/sl811-hcd.c:1312: example_access: sl811.port1 is being accessed with lock "sl811->lock" held.
drivers/usb/host/sl811-hcd.c:1212: example_lock: Locking "sl811->lock".
drivers/usb/host/sl811-hcd.c:1319: example_access: sl811.port1 is being accessed with lock "sl811->lock" held.
drivers/usb/host/sl811-hcd.c:629: example_lock: Locking "sl811->lock".
drivers/usb/host/sl811-hcd.c:722: example_access: sl811.port1 is being accessed with lock "sl811->lock" held.
drivers/usb/host/sl811-hcd.c:1785: missing_lock: Accessing variable "sl811->port1" (sl811.port1) requires the sl811.lock lock.

Error: MISSING_LOCK:
drivers/char/synclink.c:1876: example_lock: Locking "info->irq_spinlock".
drivers/char/synclink.c:1880: example_access: mgsl_struct.xmit_head is being accessed with lock "info->irq_spinlock" held.
drivers/char/synclink.c:2314: example_lock: Locking "info->irq_spinlock".
drivers/char/synclink.c:2315: example_access: mgsl_struct.xmit_head is being accessed with lock "info->irq_spinlock" held.
drivers/char/synclink.c:2035: example_lock: Locking "info->irq_spinlock".
drivers/char/synclink.c:2039: example_access: mgsl_struct.xmit_head is being accessed with lock "info->irq_spinlock" held.
drivers/char/synclink.c:2035: example_lock: Locking "info->irq_spinlock".
drivers/char/synclink.c:2040: example_access: mgsl_struct.xmit_head is being accessed with lock "info->irq_spinlock" held.
drivers/char/synclink.c:7596: example_lock: Locking "info->irq_spinlock".
drivers/char/synclink.c:7598: example_access: mgsl_struct.xmit_head is being accessed with lock "info->irq_spinlock" held.
drivers/char/synclink.c:1250: missing_lock: Accessing variable "info->xmit_head" (mgsl_struct.xmit_head) requires the mgsl_struct.irq_spinlock lock.

Error: MISSING_LOCK:
fs/afs/dir.c:668: example_lock: Locking "dentry->d_lock".
fs/afs/dir.c:669: example_access: dentry.d_flags is being accessed with lock "dentry->d_lock" held.
fs/autofs4/root.c:129: example_lock: Locking "dentry->d_lock".
fs/autofs4/root.c:130: example_access: dentry.d_flags is being accessed with lock "dentry->d_lock" held.
fs/autofs4/root.c:144: example_lock: Locking "dentry->d_lock".
fs/autofs4/root.c:145: example_access: dentry.d_flags is being accessed with lock "dentry->d_lock" held.
fs/autofs4/root.c:152: example_lock: Locking "dentry->d_lock".
fs/autofs4/root.c:153: example_access: dentry.d_flags is being accessed with lock "dentry->d_lock" held.
fs/autofs4/root.c:163: example_lock: Locking "dentry->d_lock".
fs/autofs4/root.c:164: example_access: dentry.d_flags is being accessed with lock "dentry->d_lock" held.
fs/autofs/root.c:232: missing_lock: Accessing variable "dentry->d_flags" (dentry.d_flags) requires the dentry.d_lock lock.

Error: MISSING_LOCK:
drivers/scsi/lpfc/lpfc_scsi.c:1497: example_lock: Locking "shost->host_lock".
drivers/scsi/lpfc/lpfc_scsi.c:1498: example_access: lpfc_scsi_buf.waitq is being accessed with lock "shost->host_lock" held.
drivers/scsi/lpfc/lpfc_scsi.c:1491: missing_lock: Accessing variable "lpfc_cmd->waitq" (lpfc_scsi_buf.waitq) requires the Scsi_Host.host_lock lock.

Error: MISSING_LOCK:
drivers/net/irda/irda-usb.c:1825: example_lock: Locking "self->lock".
drivers/net/irda/irda-usb.c:1829: example_access: irda_usb_cb.present is being accessed with lock "self->lock" held.
drivers/net/irda/irda-usb.c:1736: missing_lock: Accessing variable "self->present" (irda_usb_cb.present) requires the irda_usb_cb.lock lock.

Error: MISSING_LOCK:
drivers/message/fusion/mptctl.c:456: example_lock: Locking "ioc->FreeQlock".
drivers/message/fusion/mptctl.c:459: example_access: _MPT_SCSI_HOST.tmPending is being accessed with lock "ioc->FreeQlock" held.
drivers/message/fusion/mptctl.c:432: example_lock: Locking "hd->ioc->FreeQlock".
drivers/message/fusion/mptctl.c:436: example_access: _MPT_SCSI_HOST.tmPending is being accessed with lock "hd->ioc->FreeQlock" held.
drivers/message/fusion/mptsas.c:3178: example_lock: Locking "ioc->FreeQlock".
drivers/message/fusion/mptsas.c:3255: example_access: _MPT_SCSI_HOST.tmPending is being accessed with lock "ioc->FreeQlock" held.
drivers/message/fusion/mptscsih.c:2699: example_lock: Locking "ioc->FreeQlock".
drivers/message/fusion/mptscsih.c:2700: example_access: _MPT_SCSI_HOST.tmPending is being accessed with lock "ioc->FreeQlock" held.
drivers/message/fusion/mptscsih.c:2234: example_lock: Locking "ioc->FreeQlock".
drivers/message/fusion/mptscsih.c:2235: example_access: _MPT_SCSI_HOST.tmPending is being accessed with lock "ioc->FreeQlock" held.
drivers/message/fusion/mptspi.c:1467: missing_lock: Accessing variable "hd->tmPending" (_MPT_SCSI_HOST.tmPending) requires the _MPT_ADAPTER.FreeQlock lock.

Error: MISSING_LOCK:
drivers/net/usb/kaweth.c:960: example_lock: Locking "kaweth->device_lock".
drivers/net/usb/kaweth.c:961: example_access: kaweth_device.status is being accessed with lock "kaweth->device_lock" held.
drivers/net/usb/kaweth.c:943: example_lock: Locking "kaweth->device_lock".
drivers/net/usb/kaweth.c:944: example_access: kaweth_device.status is being accessed with lock "kaweth->device_lock" held.
drivers/net/usb/kaweth.c:740: missing_lock: Accessing variable "kaweth->status" (kaweth_device.status) requires the kaweth_device.device_lock lock.

Error: MISSING_LOCK:
drivers/net/usb/kaweth.c:960: example_lock: Locking "kaweth->device_lock".
drivers/net/usb/kaweth.c:961: example_access: kaweth_device.status is being accessed with lock "kaweth->device_lock" held.
drivers/net/usb/kaweth.c:943: example_lock: Locking "kaweth->device_lock".
drivers/net/usb/kaweth.c:944: example_access: kaweth_device.status is being accessed with lock "kaweth->device_lock" held.
drivers/net/usb/kaweth.c:744: missing_lock: Accessing variable "kaweth->status" (kaweth_device.status) requires the kaweth_device.device_lock lock.

Error: MISSING_LOCK:
drivers/net/wan/sbni.c:1235: example_lock: Locking "nl->lock".
drivers/net/wan/sbni.c:1237: example_access: net_local.second is being accessed with lock "nl->lock" held.
drivers/net/wan/sbni.c:1179: missing_lock: Accessing variable "((struct net_local *)(*p)->priv)->second" (net_local.second) requires the net_local.lock lock.

Error: MISSING_LOCK:
drivers/scsi/initio.c:963: example_lock: Locking "host->semaph_lock".
drivers/scsi/initio.c:964: example_access: initio_host.semaph is being accessed with lock "host->semaph_lock" held.
drivers/scsi/initio.c:1061: example_lock: Locking "host->semaph_lock".
drivers/scsi/initio.c:1069: example_access: initio_host.semaph is being accessed with lock "host->semaph_lock" held.
drivers/scsi/initio.c:1074: example_lock: Locking "host->semaph_lock".
drivers/scsi/initio.c:1075: example_access: initio_host.semaph is being accessed with lock "host->semaph_lock" held.
drivers/scsi/initio.c:2900: missing_lock: Accessing variable "host->semaph" (initio_host.semaph) requires the initio_host.semaph_lock lock.

Error: MISSING_LOCK:
net/packet/af_packet.c:930: example_lock: Locking "po->bind_lock".
net/packet/af_packet.c:934: example_access: packet_sock.num is being accessed with lock "po->bind_lock" held.
net/packet/af_packet.c:937: example_lock: Locking "po->bind_lock".
net/packet/af_packet.c:940: example_access: packet_sock.num is being accessed with lock "po->bind_lock" held.
net/packet/af_packet.c:1852: example_lock: Locking "po->bind_lock".
net/packet/af_packet.c:1857: example_access: packet_sock.num is being accessed with lock "po->bind_lock" held.
net/packet/af_packet.c:1888: example_lock: Locking "po->bind_lock".
net/packet/af_packet.c:1892: example_access: packet_sock.num is being accessed with lock "po->bind_lock" held.
net/packet/af_packet.c:887: missing_lock: Accessing variable "po->num" (packet_sock.num) requires the packet_sock.bind_lock lock.

Error: MISSING_LOCK:
fs/jfs/jfs_dmap.c:535: example_lock: Locking "log->synclock".
fs/jfs/jfs_dmap.c:550: example_access: metapage.clsn is being accessed with lock "log->synclock" held.
fs/jfs/jfs_dmap.c:535: example_lock: Locking "log->synclock".
fs/jfs/jfs_dmap.c:559: example_access: metapage.clsn is being accessed with lock "log->synclock" held.
fs/jfs/jfs_imap.c:2830: example_lock: Locking "log->synclock".
fs/jfs/jfs_imap.c:2845: example_access: metapage.clsn is being accessed with lock "log->synclock" held.
fs/jfs/jfs_imap.c:2830: example_lock: Locking "log->synclock".
fs/jfs/jfs_imap.c:2852: example_access: metapage.clsn is being accessed with lock "log->synclock" held.
fs/jfs/jfs_metapage.c:309: example_lock: Locking "log->synclock".
fs/jfs/jfs_metapage.c:313: example_access: metapage.clsn is being accessed with lock "log->synclock" held.
fs/jfs/jfs_metapage.c:193: missing_lock: Accessing variable "mp->clsn" (metapage.clsn) requires the jfs_log.synclock lock.

Error: MISSING_LOCK:
fs/jfs/jfs_dmap.c:535: example_lock: Locking "log->synclock".
fs/jfs/jfs_dmap.c:552: example_access: metapage.log is being accessed with lock "log->synclock" held.
fs/jfs/jfs_imap.c:2830: example_lock: Locking "log->synclock".
fs/jfs/jfs_imap.c:2847: example_access: metapage.log is being accessed with lock "log->synclock" held.
fs/jfs/jfs_logmgr.c:263: example_lock: Locking "log->synclock".
fs/jfs/jfs_logmgr.c:269: example_access: metapage.log is being accessed with lock "log->synclock" held.
fs/jfs/jfs_metapage.c:309: example_lock: Locking "log->synclock".
fs/jfs/jfs_metapage.c:311: example_access: metapage.log is being accessed with lock "log->synclock" held.
fs/jfs/jfs_metapage.c:194: missing_lock: Accessing variable "mp->log" (metapage.log) requires the jfs_log.synclock lock.

Error: MISSING_LOCK:
fs/jfs/jfs_dmap.c:535: example_lock: Locking "log->synclock".
fs/jfs/jfs_dmap.c:540: example_access: metapage.lsn is being accessed with lock "log->synclock" held.
fs/jfs/jfs_dmap.c:535: example_lock: Locking "log->synclock".
fs/jfs/jfs_dmap.c:553: example_access: metapage.lsn is being accessed with lock "log->synclock" held.
fs/jfs/jfs_imap.c:2830: example_lock: Locking "log->synclock".
fs/jfs/jfs_imap.c:2836: example_access: metapage.lsn is being accessed with lock "log->synclock" held.
fs/jfs/jfs_imap.c:2830: example_lock: Locking "log->synclock".
fs/jfs/jfs_imap.c:2848: example_access: metapage.lsn is being accessed with lock "log->synclock" held.
fs/jfs/jfs_logmgr.c:263: example_lock: Locking "log->synclock".
fs/jfs/jfs_logmgr.c:270: example_access: metapage.lsn is being accessed with lock "log->synclock" held.
fs/jfs/jfs_metapage.c:190: missing_lock: Accessing variable "mp->lsn" (metapage.lsn) requires the jfs_log.synclock lock.

Error: MISSING_LOCK:
drivers/scsi/megaraid/megaraid_sas.c:134: example_lock: Locking "instance->cmd_pool_lock".
drivers/scsi/megaraid/megaraid_sas.c:136: example_access: megasas_cmd.scmd is being accessed with lock "instance->cmd_pool_lock" held.
drivers/scsi/megaraid/megaraid_sas.c:978: missing_lock: Accessing variable "cmd->scmd" (megasas_cmd.scmd) requires the megasas_instance.cmd_pool_lock lock.

Error: MISSING_LOCK:
net/netrom/af_netrom.c:983: example_lock: Locking "sk->sk_lock.slock".
net/netrom/af_netrom.c:985: example_access: nr_sock.my_index is being accessed with lock "sk->sk_lock.slock" held.
net/netrom/af_netrom.c:712: missing_lock: Accessing variable "nr->my_index" (nr_sock.my_index) requires the socket_lock_t.slock lock.

Error: MISSING_LOCK:
drivers/watchdog/eurotechwdt.c:289: example_lock: Locking "eurwdt_lock".
drivers/watchdog/eurotechwdt.c:290: example_access: eurwdt_timeout is being accessed with lock "eurwdt_lock" held.
drivers/watchdog/eurotechwdt.c:316: missing_lock: Accessing variable "eurwdt_timeout" (eurwdt_timeout) requires the eurwdt_lock lock.

Error: MISSING_LOCK:
drivers/usb/serial/garmin_gps.c:942: example_lock: Locking "garmin_data_p->lock".
drivers/usb/serial/garmin_gps.c:943: example_access: garmin_data.ignorePkts is being accessed with lock "garmin_data_p->lock" held.
drivers/usb/serial/garmin_gps.c:952: example_lock: Locking "garmin_data_p->lock".
drivers/usb/serial/garmin_gps.c:953: example_access: garmin_data.ignorePkts is being accessed with lock "garmin_data_p->lock" held.
drivers/usb/serial/garmin_gps.c:1373: example_lock: Locking "garmin_data_p->lock".
drivers/usb/serial/garmin_gps.c:1376: example_access: garmin_data.ignorePkts is being accessed with lock "garmin_data_p->lock" held.
drivers/usb/serial/garmin_gps.c:1408: example_lock: Locking "garmin_data_p->lock".
drivers/usb/serial/garmin_gps.c:1409: example_access: garmin_data.ignorePkts is being accessed with lock "garmin_data_p->lock" held.
drivers/usb/serial/garmin_gps.c:1212: missing_lock: Accessing variable "garmin_data_p->ignorePkts" (garmin_data.ignorePkts) requires the garmin_data.lock lock.

Error: MISSING_LOCK:
drivers/usb/serial/garmin_gps.c:984: example_lock: Locking "garmin_data_p->lock".
drivers/usb/serial/garmin_gps.c:985: example_access: garmin_data.mode is being accessed with lock "garmin_data_p->lock" held.
drivers/usb/serial/garmin_gps.c:1186: missing_lock: Accessing variable "garmin_data_p->mode" (garmin_data.mode) requires the garmin_data.lock lock.

Error: MISSING_LOCK:
fs/cifs/misc.c:64: example_lock: Locking "GlobalMid_Lock".
fs/cifs/misc.c:67: example_access: GlobalTotalActiveXid is being accessed with lock "GlobalMid_Lock" held.
fs/cifs/misc.c:48: example_lock: Locking "GlobalMid_Lock".
fs/cifs/misc.c:49: example_access: GlobalTotalActiveXid is being accessed with lock "GlobalMid_Lock" held.
fs/cifs/cifsfs.c:1087: missing_lock: Accessing variable "GlobalTotalActiveXid" (GlobalTotalActiveXid) requires the GlobalMid_Lock lock.

Error: MISSING_LOCK:
drivers/net/wireless/iwlwifi/iwl-agn.c:1569: example_lock: Locking "priv->lock".
drivers/net/wireless/iwlwifi/iwl-agn.c:1570: example_access: iwl_priv.assoc_id is being accessed with lock "priv->lock" held.
drivers/net/wireless/iwlwifi/iwl-agn.c:3583: example_lock: Locking "priv->lock".
drivers/net/wireless/iwlwifi/iwl-agn.c:3590: example_access: iwl_priv.assoc_id is being accessed with lock "priv->lock" held.
drivers/net/wireless/iwlwifi/iwl-agn.c:3502: example_lock: Locking "priv->lock".
drivers/net/wireless/iwlwifi/iwl-agn.c:3503: example_access: iwl_priv.assoc_id is being accessed with lock "priv->lock" held.
drivers/net/wireless/iwlwifi/iwl-agn.c:3148: missing_lock: Accessing variable "priv->assoc_id" (iwl_priv.assoc_id) requires the iwl_priv.lock lock.

Error: MISSING_LOCK:
drivers/net/wireless/iwlwifi/iwl-agn.c:1569: example_lock: Locking "priv->lock".
drivers/net/wireless/iwlwifi/iwl-agn.c:1570: example_access: iwl_priv.assoc_id is being accessed with lock "priv->lock" held.
drivers/net/wireless/iwlwifi/iwl-agn.c:3583: example_lock: Locking "priv->lock".
drivers/net/wireless/iwlwifi/iwl-agn.c:3590: example_access: iwl_priv.assoc_id is being accessed with lock "priv->lock" held.
drivers/net/wireless/iwlwifi/iwl-agn.c:3502: example_lock: Locking "priv->lock".
drivers/net/wireless/iwlwifi/iwl-agn.c:3503: example_access: iwl_priv.assoc_id is being accessed with lock "priv->lock" held.
drivers/net/wireless/iwlwifi/iwl-agn.c:3163: missing_lock: Accessing variable "priv->assoc_id" (iwl_priv.assoc_id) requires the iwl_priv.lock lock.

Error: MISSING_LOCK:
net/sunrpc/rpc_pipe.c:135: example_lock: Locking "inode->i_lock".
net/sunrpc/rpc_pipe.c:139: example_access: rpc_inode.pipelen is being accessed with lock "inode->i_lock" held.
net/sunrpc/rpc_pipe.c:95: example_lock: Locking "inode->i_lock".
net/sunrpc/rpc_pipe.c:100: example_access: rpc_inode.pipelen is being accessed with lock "inode->i_lock" held.
net/sunrpc/rpc_pipe.c:95: example_lock: Locking "inode->i_lock".
net/sunrpc/rpc_pipe.c:108: example_access: rpc_inode.pipelen is being accessed with lock "inode->i_lock" held.
net/sunrpc/rpc_pipe.c:239: example_lock: Locking "inode->i_lock".
net/sunrpc/rpc_pipe.c:245: example_access: rpc_inode.pipelen is being accessed with lock "inode->i_lock" held.
net/sunrpc/rpc_pipe.c:209: example_lock: Locking "inode->i_lock".
net/sunrpc/rpc_pipe.c:211: example_access: rpc_inode.pipelen is being accessed with lock "inode->i_lock" held.
net/sunrpc/rpc_pipe.c:911: missing_lock: Accessing variable "rpci->pipelen" (rpc_inode.pipelen) requires the inode.i_lock lock.

Error: MISSING_LOCK:
drivers/ide/ide-io.c:1452: example_lock: Locking "ide_lock".
drivers/ide/ide-io.c:1460: example_access: ide_drive_s.service_time is being accessed with lock "ide_lock" held.
drivers/ide/ide-io.c:1261: missing_lock: Accessing variable "drive->service_time" (ide_drive_s.service_time) requires the ide_lock lock.

Error: MISSING_LOCK:
fs/afs/dir.c:668: example_lock: Locking "dentry->d_lock".
fs/afs/dir.c:669: example_access: dentry.d_flags is being accessed with lock "dentry->d_lock" held.
fs/autofs4/root.c:129: example_lock: Locking "dentry->d_lock".
fs/autofs4/root.c:130: example_access: dentry.d_flags is being accessed with lock "dentry->d_lock" held.
fs/autofs4/root.c:144: example_lock: Locking "dentry->d_lock".
fs/autofs4/root.c:145: example_access: dentry.d_flags is being accessed with lock "dentry->d_lock" held.
fs/autofs4/root.c:152: example_lock: Locking "dentry->d_lock".
fs/autofs4/root.c:153: example_access: dentry.d_flags is being accessed with lock "dentry->d_lock" held.
fs/autofs4/root.c:163: example_lock: Locking "dentry->d_lock".
fs/autofs4/root.c:164: example_access: dentry.d_flags is being accessed with lock "dentry->d_lock" held.
fs/anon_inodes.c:42: missing_lock: Accessing variable "dentry->d_flags" (dentry.d_flags) requires the dentry.d_lock lock.

Error: MISSING_LOCK:
arch/x86/kernel/io_apic.c:2184: example_lock: Locking "desc->lock".
arch/x86/kernel/io_apic.c:2187: example_access: irq_desc.status is being accessed with lock "desc->lock" held.
kernel/irq/autoprobe.c:169: example_lock: Locking "desc->lock".
kernel/irq/autoprobe.c:178: example_access: irq_desc.status is being accessed with lock "desc->lock" held.
kernel/irq/autoprobe.c:71: example_lock: Locking "desc->lock".
kernel/irq/autoprobe.c:73: example_access: irq_desc.status is being accessed with lock "desc->lock" held.
kernel/irq/autoprobe.c:71: example_lock: Locking "desc->lock".
kernel/irq/autoprobe.c:75: example_access: irq_desc.status is being accessed with lock "desc->lock" held.
kernel/irq/autoprobe.c:89: example_lock: Locking "desc->lock".
kernel/irq/autoprobe.c:95: example_access: irq_desc.status is being accessed with lock "desc->lock" held.
kernel/irq/chip.c:256: missing_lock: Accessing variable "desc->status" (irq_desc.status) requires the irq_desc.lock lock.

Error: MISSING_LOCK:
drivers/input/keyboard/atkbd.c:646: example_lock: Locking "atkbd->ps2dev.serio->lock".
drivers/input/keyboard/atkbd.c:647: example_access: atkbd.enabled is being accessed with lock "atkbd->ps2dev.serio->lock" held.
drivers/input/keyboard/atkbd.c:634: example_lock: Locking "atkbd->ps2dev.serio->lock".
drivers/input/keyboard/atkbd.c:635: example_access: atkbd.enabled is being accessed with lock "atkbd->ps2dev.serio->lock" held.
drivers/input/keyboard/atkbd.c:404: missing_lock: Accessing variable "atkbd->enabled" (atkbd.enabled) requires the serio.lock lock.

Error: MISSING_LOCK:
net/9p/client.c:153: example_lock: Locking "c->lock".
net/9p/client.c:166: example_access: p9_req_t.status is being accessed with lock "c->lock" held.
net/9p/client.c:572: example_lock: Locking "c->lock".
net/9p/client.c:574: example_access: p9_req_t.status is being accessed with lock "c->lock" held.
net/9p/client.c:337: example_lock: Locking "c->lock".
net/9p/client.c:342: example_access: p9_req_t.status is being accessed with lock "c->lock" held.
net/9p/client.c:349: example_lock: Locking "c->lock".
net/9p/client.c:351: example_access: p9_req_t.status is being accessed with lock "c->lock" held.
net/9p/trans_fd.c:192: example_lock: Locking "m->client->lock".
net/9p/trans_fd.c:202: example_access: p9_req_t.status is being accessed with lock "m->client->lock" held.
net/9p/trans_virtio.c:203: missing_lock: Accessing variable "req->status" (p9_req_t.status) requires the p9_client.lock lock.

Error: MISSING_LOCK:
drivers/usb/host/uhci-hcd.c:491: example_lock: Locking "uhci->lock".
drivers/usb/host/uhci-hcd.c:492: example_access: uhci_hcd.is_initialized is being accessed with lock "uhci->lock" held.
drivers/usb/host/uhci-hcd.c:693: missing_lock: Accessing variable "uhci->is_initialized" (uhci_hcd.is_initialized) requires the uhci_hcd.lock lock.

Error: MISSING_LOCK:
drivers/message/fusion/mptctl.c:456: example_lock: Locking "ioc->FreeQlock".
drivers/message/fusion/mptctl.c:459: example_access: _MPT_SCSI_HOST.tmPending is being accessed with lock "ioc->FreeQlock" held.
drivers/message/fusion/mptctl.c:432: example_lock: Locking "hd->ioc->FreeQlock".
drivers/message/fusion/mptctl.c:436: example_access: _MPT_SCSI_HOST.tmPending is being accessed with lock "hd->ioc->FreeQlock" held.
drivers/message/fusion/mptsas.c:3178: example_lock: Locking "ioc->FreeQlock".
drivers/message/fusion/mptsas.c:3255: example_access: _MPT_SCSI_HOST.tmPending is being accessed with lock "ioc->FreeQlock" held.
drivers/message/fusion/mptscsih.c:2699: example_lock: Locking "ioc->FreeQlock".
drivers/message/fusion/mptscsih.c:2700: example_access: _MPT_SCSI_HOST.tmPending is being accessed with lock "ioc->FreeQlock" held.
drivers/message/fusion/mptscsih.c:2234: example_lock: Locking "ioc->FreeQlock".
drivers/message/fusion/mptscsih.c:2235: example_access: _MPT_SCSI_HOST.tmPending is being accessed with lock "ioc->FreeQlock" held.
drivers/message/fusion/mptfc.c:1295: missing_lock: Accessing variable "hd->tmPending" (_MPT_SCSI_HOST.tmPending) requires the _MPT_ADAPTER.FreeQlock lock.

Error: MISSING_LOCK:
drivers/message/fusion/mptfc.c:1506: example_lock: Locking "ioc->fc_rescan_work_lock".
drivers/message/fusion/mptfc.c:1507: example_access: _MPT_ADAPTER.fc_rescan_work_q is being accessed with lock "ioc->fc_rescan_work_lock" held.
drivers/message/fusion/mptfc.c:1331: missing_lock: Accessing variable "ioc->fc_rescan_work_q" (_MPT_ADAPTER.fc_rescan_work_q) requires the _MPT_ADAPTER.fc_rescan_work_lock lock.

Error: MISSING_LOCK:
drivers/char/rio/riocmd.c:345: example_lock: Locking "PortP->portSem".
drivers/char/rio/riocmd.c:347: example_access: Port.State is being accessed with lock "PortP->portSem" held.
drivers/char/rio/riocmd.c:415: example_lock: Locking "PortP->portSem".
drivers/char/rio/riocmd.c:504: example_access: Port.State is being accessed with lock "PortP->portSem" held.
drivers/char/rio/riocmd.c:415: example_lock: Locking "PortP->portSem".
drivers/char/rio/riocmd.c:518: example_access: Port.State is being accessed with lock "PortP->portSem" held.
drivers/char/rio/rioctrl.c:420: example_lock: Locking "PortP->portSem".
drivers/char/rio/rioctrl.c:428: example_access: Port.State is being accessed with lock "PortP->portSem" held.
drivers/char/rio/rioctrl.c:973: example_lock: Locking "PortP->portSem".
drivers/char/rio/rioctrl.c:974: example_access: Port.State is being accessed with lock "PortP->portSem" held.
drivers/char/rio/rio_linux.c:687: missing_lock: Accessing variable "port->State" (Port.State) requires the Port.portSem lock.

Error: ORDER_REVERSAL:
kernel/sched.c:4463: lock_acquire: Calling function "_spin_lock_irq" acquires lock "rq->lock".
mm/slub.c:2409: lock_acquire: Calling function "_spin_lock_irqsave" acquires lock "n->list_lock".
mm/slub.c:2416: example_lock_order: Calling "list_slab_objects" acquires lock "rq.lock" after lock "n->list_lock".
mm/slub.c:2392: getlock: Acquiring lock named <unset>.
kernel/printk.c:564: getlock: Acquiring lock named <unset>.
kernel/printk.c:737: getlock: Acquiring lock named <unset>.
kernel/sched.c:4531: getlock: Acquiring lock named <unset>.
kernel/sched.c:4463: getlock: Acquiring lock named rq.lock.
mm/slub.c:3320: lock_acquire: Calling function "_spin_lock_irqsave" acquires lock "n->list_lock".
mm/slub.c:3323: example_lock_order: Calling "validate_slab_slab" acquires lock "rq.lock" after lock "n->list_lock".
mm/slub.c:3304: getlock: Acquiring lock named <unset>.
kernel/printk.c:564: getlock: Acquiring lock named <unset>.
kernel/printk.c:737: getlock: Acquiring lock named <unset>.
kernel/sched.c:4531: getlock: Acquiring lock named <unset>.
kernel/sched.c:4463: getlock: Acquiring lock named rq.lock.
kernel/sched.c:4493: lock_order: Calling "context_switch" acquires lock "kmem_cache_node.list_lock" after lock "rq->lock" (count: 2 / 4).
kernel/sched.c:2665: getlock: Acquiring lock named <unset>.
kernel/sched.c:2592: getlock: Acquiring lock named <unset>.
include/linux/sched.h:1530: getlock: Acquiring lock named <unset>.
kernel/fork.c:156: getlock: Acquiring lock named <unset>.
kernel/fork.c:140: getlock: Acquiring lock named <unset>.
mm/slub.c:1734: getlock: Acquiring lock named <unset>.
mm/slub.c:1723: getlock: Acquiring lock named <unset>.
mm/slub.c:1690: getlock: Acquiring lock named <unset>.
mm/slub.c:944: getlock: Acquiring lock named <unset>.
mm/slub.c:821: getlock: Acquiring lock named kmem_cache_node.list_lock.

Error: ORDER_REVERSAL:
fs/dcache.c:500: lock_acquire: Calling function "_spin_lock" acquires lock "dentry->d_lock".
drivers/infiniband/hw/ipath/ipath_fs.c:278: lock_acquire: Calling function "_spin_lock" acquires lock "dcache_lock".
drivers/infiniband/hw/ipath/ipath_fs.c:279: example_lock_order: Calling "_spin_lock" acquires lock "tmp->d_lock" after lock "dcache_lock".
fs/autofs4/root.c:732: lock_acquire: Calling function "_spin_lock" acquires lock "dcache_lock".
fs/autofs4/root.c:741: example_lock_order: Calling "_spin_lock" acquires lock "dentry->d_lock" after lock "dcache_lock".
fs/autofs4/root.c:707: lock_acquire: Calling function "_spin_lock" acquires lock "dcache_lock".
fs/autofs4/root.c:712: example_lock_order: Calling "_spin_lock" acquires lock "dentry->d_lock" after lock "dcache_lock".
fs/autofs4/root.c:370: lock_acquire: Calling function "_spin_lock" acquires lock "dcache_lock".
fs/autofs4/root.c:381: example_lock_order: Calling "_spin_lock" acquires lock "dentry->d_lock" after lock "dcache_lock".
fs/autofs4/root.c:422: lock_acquire: Calling function "_spin_lock" acquires lock "dcache_lock".
fs/autofs4/root.c:433: example_lock_order: Calling "_spin_lock" acquires lock "dentry->d_lock" after lock "dcache_lock".
fs/dcache.c:510: lock_order: Calling "prune_one_dentry" acquires lock "dcache_lock" after lock "dentry->d_lock" (count: 1 / 28).
fs/dcache.c:432: getlock: Acquiring lock named dcache_lock.

Error: ORDER_REVERSAL:
fs/xfs/xfs_log.c:2875: lock_acquire: Calling function "_atomic_dec_and_lock" acquires lock "log->l_icloglock".
lib/dec_and_lock.c:28: lock: "_spin_lock" locks "*lock".
fs/xfs/quota/xfs_dquot.c:1340: lock_acquire: Calling function "_spin_lock" acquires lock "dqp->q_mount->m_ail_lock".
fs/xfs/quota/xfs_dquot.c:1345: example_lock_order: Calling "xfs_trans_delete_ail" acquires lock "log.l_icloglock" after lock "dqp->q_mount->m_ail_lock".
fs/xfs/xfs_trans_ail.c:426: getlock: Acquiring lock named <unset>.
fs/xfs/xfs_log.c:843: getlock: Acquiring lock named log.l_icloglock.
fs/xfs/quota/xfs_dquot_item.c:573: lock_acquire: Calling function "_spin_lock" acquires lock "qfs->qql_item.li_mountp->m_ail_lock".
fs/xfs/quota/xfs_dquot_item.c:578: example_lock_order: Calling "xfs_trans_delete_ail" acquires lock "log.l_icloglock" after lock "qfs->qql_item.li_mountp->m_ail_lock".
fs/xfs/xfs_trans_ail.c:426: getlock: Acquiring lock named <unset>.
fs/xfs/xfs_log.c:843: getlock: Acquiring lock named log.l_icloglock.
fs/xfs/xfs_buf_item.c:1141: lock_acquire: Calling function "_spin_lock" acquires lock "mp->m_ail_lock".
fs/xfs/xfs_buf_item.c:1145: example_lock_order: Calling "xfs_trans_delete_ail" acquires lock "log.l_icloglock" after lock "mp->m_ail_lock".
fs/xfs/xfs_trans_ail.c:426: getlock: Acquiring lock named <unset>.
fs/xfs/xfs_log.c:843: getlock: Acquiring lock named log.l_icloglock.
fs/xfs/xfs_buf_item.c:411: lock_acquire: Calling function "_spin_lock" acquires lock "mp->m_ail_lock".
fs/xfs/xfs_buf_item.c:412: example_lock_order: Calling "xfs_trans_delete_ail" acquires lock "log.l_icloglock" after lock "mp->m_ail_lock".
fs/xfs/xfs_trans_ail.c:426: getlock: Acquiring lock named <unset>.
fs/xfs/xfs_log.c:843: getlock: Acquiring lock named log.l_icloglock.
fs/xfs/xfs_extfree_item.c:355: lock_acquire: Calling function "_spin_lock" acquires lock "mp->m_ail_lock".
fs/xfs/xfs_extfree_item.c:363: example_lock_order: Calling "xfs_trans_delete_ail" acquires lock "log.l_icloglock" after lock "mp->m_ail_lock".
fs/xfs/xfs_trans_ail.c:426: getlock: Acquiring lock named <unset>.
fs/xfs/xfs_log.c:843: getlock: Acquiring lock named log.l_icloglock.
fs/xfs/xfs_log.c:2887: lock_order: Calling "xlog_assign_tail_lsn" acquires lock "xfs_mount.m_ail_lock" after lock "log->l_icloglock" (count: 1 / 14).
fs/xfs/xfs_log.c:955: getlock: Acquiring lock named <unset>.
fs/xfs/xfs_trans_ail.c:59: getlock: Acquiring lock named xfs_mount.m_ail_lock.

Error: ORDER_REVERSAL:
mm/hugetlb.c:2002: lock_acquire: Calling function "_spin_lock" acquires lock "mm->page_table_lock".
arch/x86/mm/hugetlbpage.c:72: lock_acquire: Calling function "_spin_lock" acquires lock "mapping->i_mmap_lock".
arch/x86/mm/hugetlbpage.c:90: example_lock_order: Calling "_spin_lock" acquires lock "mm->page_table_lock" after lock "mapping->i_mmap_lock".
fs/hugetlbfs/inode.c:464: lock_acquire: Calling function "_spin_lock" acquires lock "mapping->i_mmap_lock".
fs/hugetlbfs/inode.c:466: example_lock_order: Calling "hugetlb_vmtruncate_list" acquires lock "mm_struct.page_table_lock" after lock "mapping->i_mmap_lock".
fs/hugetlbfs/inode.c:449: getlock: Acquiring lock named <unset>.
mm/hugetlb.c:1734: getlock: Acquiring lock named mm_struct.page_table_lock.
mm/hugetlb.c:1785: lock_acquire: Calling function "_spin_lock" acquires lock "vma->vm_file->f_mapping->i_mmap_lock".
mm/hugetlb.c:1786: example_lock_order: Calling "__unmap_hugepage_range" acquires lock "mm_struct.page_table_lock" after lock "vma->vm_file->f_mapping->i_mmap_lock".
mm/hugetlb.c:1734: getlock: Acquiring lock named mm_struct.page_table_lock.
mm/hugetlb.c:2218: lock_acquire: Calling function "_spin_lock" acquires lock "vma->vm_file->f_mapping->i_mmap_lock".
mm/hugetlb.c:2219: example_lock_order: Calling "_spin_lock" acquires lock "mm->page_table_lock" after lock "vma->vm_file->f_mapping->i_mmap_lock".
mm/hugetlb.c:2017: lock_order: Calling "hugetlb_cow" acquires lock "address_space.i_mmap_lock" after lock "mm->page_table_lock" (count: 2 / 6).
mm/hugetlb.c:1884: getlock: Acquiring lock named <unset>.
mm/hugetlb.c:1827: getlock: Acquiring lock named <unset>.
mm/hugetlb.c:1785: getlock: Acquiring lock named address_space.i_mmap_lock.

Error: ORDER_REVERSAL:
mm/hugetlb.c:2080: lock_acquire: Calling function "_spin_lock" acquires lock "mm->page_table_lock".
arch/x86/mm/hugetlbpage.c:72: lock_acquire: Calling function "_spin_lock" acquires lock "mapping->i_mmap_lock".
arch/x86/mm/hugetlbpage.c:90: example_lock_order: Calling "_spin_lock" acquires lock "mm->page_table_lock" after lock "mapping->i_mmap_lock".
fs/hugetlbfs/inode.c:464: lock_acquire: Calling function "_spin_lock" acquires lock "mapping->i_mmap_lock".
fs/hugetlbfs/inode.c:466: example_lock_order: Calling "hugetlb_vmtruncate_list" acquires lock "mm_struct.page_table_lock" after lock "mapping->i_mmap_lock".
fs/hugetlbfs/inode.c:449: getlock: Acquiring lock named <unset>.
mm/hugetlb.c:1734: getlock: Acquiring lock named mm_struct.page_table_lock.
mm/hugetlb.c:1785: lock_acquire: Calling function "_spin_lock" acquires lock "vma->vm_file->f_mapping->i_mmap_lock".
mm/hugetlb.c:1786: example_lock_order: Calling "__unmap_hugepage_range" acquires lock "mm_struct.page_table_lock" after lock "vma->vm_file->f_mapping->i_mmap_lock".
mm/hugetlb.c:1734: getlock: Acquiring lock named mm_struct.page_table_lock.
mm/hugetlb.c:2218: lock_acquire: Calling function "_spin_lock" acquires lock "vma->vm_file->f_mapping->i_mmap_lock".
mm/hugetlb.c:2219: example_lock_order: Calling "_spin_lock" acquires lock "mm->page_table_lock" after lock "vma->vm_file->f_mapping->i_mmap_lock".
mm/hugetlb.c:2088: lock_order: Calling "hugetlb_cow" acquires lock "address_space.i_mmap_lock" after lock "mm->page_table_lock" (count: 2 / 6).
mm/hugetlb.c:1884: getlock: Acquiring lock named <unset>.
mm/hugetlb.c:1827: getlock: Acquiring lock named <unset>.
mm/hugetlb.c:1785: getlock: Acquiring lock named address_space.i_mmap_lock.

Error: ORDER_REVERSAL:
kernel/signal.c:1604: lock_acquire: Calling function "_spin_lock_irq" acquires lock "get_current()->sighand->siglock".
drivers/char/tty_io.c:604: lock_acquire: Calling function "_read_lock" acquires lock "tasklist_lock".
drivers/char/tty_io.c:607: example_lock_order: Calling "_spin_lock_irq" acquires lock "p->sighand->siglock" after lock "tasklist_lock".
drivers/char/tty_io.c:832: lock_acquire: Calling function "_read_lock" acquires lock "tasklist_lock".
drivers/char/tty_io.c:833: example_lock_order: Calling "session_clear_tty" acquires lock "sighand_struct.siglock" after lock "tasklist_lock".
drivers/char/tty_io.c:747: getlock: Acquiring lock named <unset>.
drivers/char/tty_io.c:3040: getlock: Acquiring lock named sighand_struct.siglock.
drivers/char/tty_io.c:1704: lock_acquire: Calling function "_read_lock" acquires lock "tasklist_lock".
drivers/char/tty_io.c:1705: example_lock_order: Calling "session_clear_tty" acquires lock "sighand_struct.siglock" after lock "tasklist_lock".
drivers/char/tty_io.c:747: getlock: Acquiring lock named <unset>.
drivers/char/tty_io.c:3040: getlock: Acquiring lock named sighand_struct.siglock.
drivers/char/tty_io.c:2689: lock_acquire: Calling function "_read_lock" acquires lock "tasklist_lock".
drivers/char/tty_io.c:2695: example_lock_order: Calling "send_sig" acquires lock "sighand_struct.siglock" after lock "tasklist_lock".
kernel/signal.c:1194: getlock: Acquiring lock named <unset>.
kernel/signal.c:1182: getlock: Acquiring lock named sighand_struct.siglock.
drivers/char/tty_io.c:2222: lock_acquire: Calling function "_read_lock" acquires lock "tasklist_lock".
drivers/char/tty_io.c:2223: example_lock_order: Calling "session_clear_tty" acquires lock "sighand_struct.siglock" after lock "tasklist_lock".
drivers/char/tty_io.c:747: getlock: Acquiring lock named <unset>.
drivers/char/tty_io.c:3040: getlock: Acquiring lock named sighand_struct.siglock.
kernel/signal.c:1605: lock_order: Calling "ptrace_stop" acquires lock "tasklist_lock" after lock "get_current()->sighand->siglock" (count: 3 / 36).
kernel/signal.c:1552: getlock: Acquiring lock named tasklist_lock.

Error: ORDER_REVERSAL:
mm/slub.c:2409: lock_acquire: Calling function "_spin_lock_irqsave" acquires lock "n->list_lock".
kernel/sched.c:4463: lock_acquire: Calling function "_spin_lock_irq" acquires lock "rq->lock".
kernel/sched.c:4493: example_lock_order: Calling "context_switch" acquires lock "kmem_cache_node.list_lock" after lock "rq->lock".
kernel/sched.c:2665: getlock: Acquiring lock named <unset>.
kernel/sched.c:2592: getlock: Acquiring lock named <unset>.
include/linux/sched.h:1530: getlock: Acquiring lock named <unset>.
kernel/fork.c:156: getlock: Acquiring lock named <unset>.
kernel/fork.c:140: getlock: Acquiring lock named <unset>.
mm/slub.c:1734: getlock: Acquiring lock named <unset>.
mm/slub.c:1723: getlock: Acquiring lock named <unset>.
mm/slub.c:1690: getlock: Acquiring lock named <unset>.
mm/slub.c:944: getlock: Acquiring lock named <unset>.
mm/slub.c:821: getlock: Acquiring lock named kmem_cache_node.list_lock.
kernel/sched.c:6281: lock_acquire: Calling function "_spin_lock_irq" acquires lock "rq->lock".
kernel/sched.c:6283: example_lock_order: Calling "put_task_struct" acquires lock "kmem_cache_node.list_lock" after lock "rq->lock".
include/linux/sched.h:1530: getlock: Acquiring lock named <unset>.
kernel/fork.c:156: getlock: Acquiring lock named <unset>.
kernel/fork.c:140: getlock: Acquiring lock named <unset>.
mm/slub.c:1734: getlock: Acquiring lock named <unset>.
mm/slub.c:1723: getlock: Acquiring lock named <unset>.
mm/slub.c:1690: getlock: Acquiring lock named <unset>.
mm/slub.c:944: getlock: Acquiring lock named <unset>.
mm/slub.c:821: getlock: Acquiring lock named kmem_cache_node.list_lock.
mm/slub.c:2416: lock_order: Calling "list_slab_objects" acquires lock "rq.lock" after lock "n->list_lock" (count: 2 / 4).
mm/slub.c:2392: getlock: Acquiring lock named <unset>.
kernel/printk.c:564: getlock: Acquiring lock named <unset>.
kernel/printk.c:737: getlock: Acquiring lock named <unset>.
kernel/sched.c:4531: getlock: Acquiring lock named <unset>.
kernel/sched.c:4463: getlock: Acquiring lock named rq.lock.

Error: ORDER_REVERSAL:
drivers/pci/iova.c:406: lock_acquire: Calling function "_spin_lock" acquires lock "from->iova_rbtree_lock".
drivers/pci/iova.c:366: lock_acquire: Calling function "_spin_lock_irqsave" acquires lock "iovad->iova_alloc_lock".
drivers/pci/iova.c:367: example_lock_order: Calling "_spin_lock" acquires lock "iovad->iova_rbtree_lock" after lock "iovad->iova_alloc_lock".
drivers/pci/iova.c:405: lock_acquire: Calling function "_spin_lock_irqsave" acquires lock "from->iova_alloc_lock".
drivers/pci/iova.c:406: example_lock_order: Calling "_spin_lock" acquires lock "from->iova_rbtree_lock" after lock "from->iova_alloc_lock".
drivers/pci/iova.c:204: lock_acquire: Calling function "_spin_lock_irqsave" acquires lock "iovad->iova_alloc_lock".
drivers/pci/iova.c:205: example_lock_order: Calling "__alloc_and_insert_iova_range" acquires lock "iova_domain.iova_rbtree_lock" after lock "iovad->iova_alloc_lock".
drivers/pci/iova.c:86: getlock: Acquiring lock named iova_domain.iova_rbtree_lock.
drivers/pci/iova.c:410: lock_order: Calling "reserve_iova" acquires lock "iova_domain.iova_alloc_lock" after lock "from->iova_rbtree_lock" (count: 1 / 4).
drivers/pci/iova.c:366: getlock: Acquiring lock named iova_domain.iova_alloc_lock.

Error: ORDER_REVERSAL:
fs/ocfs2/dlm/dlmast.c:112: lock_acquire: Calling function "_spin_lock" acquires lock "lock->spinlock".
fs/ocfs2/dlm/dlmconvert.c:507: lock_acquire: Calling function "_spin_lock" acquires lock "res->spinlock".
fs/ocfs2/dlm/dlmconvert.c:513: example_lock_order: Calling "__dlmconvert_master" acquires lock "dlm_lock.spinlock" after lock "res->spinlock".
fs/ocfs2/dlm/dlmconvert.c:136: getlock: Acquiring lock named dlm_lock.spinlock.
fs/ocfs2/dlm/dlmconvert.c:85: lock_acquire: Calling function "_spin_lock" acquires lock "res->spinlock".
fs/ocfs2/dlm/dlmconvert.c:91: example_lock_order: Calling "__dlmconvert_master" acquires lock "dlm_lock.spinlock" after lock "res->spinlock".
fs/ocfs2/dlm/dlmconvert.c:136: getlock: Acquiring lock named dlm_lock.spinlock.
fs/ocfs2/dlm/dlmconvert.c:274: lock_acquire: Calling function "_spin_lock" acquires lock "res->spinlock".
fs/ocfs2/dlm/dlmconvert.c:286: example_lock_order: Calling "__dlm_print_one_lock_resource" acquires lock "dlm_lock.spinlock" after lock "res->spinlock".
fs/ocfs2/dlm/dlmdebug.c:123: getlock: Acquiring lock named <unset>.
fs/ocfs2/dlm/dlmdebug.c:76: getlock: Acquiring lock named dlm_lock.spinlock.
fs/ocfs2/dlm/dlmdebug.c:52: lock_acquire: Calling function "_spin_lock" acquires lock "res->spinlock".
fs/ocfs2/dlm/dlmdebug.c:53: example_lock_order: Calling "__dlm_print_one_lock_resource" acquires lock "dlm_lock.spinlock" after lock "res->spinlock".
fs/ocfs2/dlm/dlmdebug.c:123: getlock: Acquiring lock named <unset>.
fs/ocfs2/dlm/dlmdebug.c:76: getlock: Acquiring lock named dlm_lock.spinlock.
fs/ocfs2/dlm/dlmdebug.c:663: lock_acquire: Calling function "_spin_lock" acquires lock "dl->dl_res->spinlock".
fs/ocfs2/dlm/dlmdebug.c:664: example_lock_order: Calling "dump_lockres" acquires lock "dlm_lock.spinlock" after lock "dl->dl_res->spinlock".
fs/ocfs2/dlm/dlmdebug.c:614: getlock: Acquiring lock named <unset>.
fs/ocfs2/dlm/dlmdebug.c:557: getlock: Acquiring lock named dlm_lock.spinlock.
fs/ocfs2/dlm/dlmast.c:131: lock_order: Calling "dlm_lockres_release_ast" acquires lock "dlm_lock_resource.spinlock" after lock "lock->spinlock" (count: 1 / 10).
fs/ocfs2/dlm/dlmmaster.c:3384: getlock: Acquiring lock named dlm_lock_resource.spinlock.
lib/dec_and_lock.c:28: lock: "_spin_lock" locks "*lock".

Error: ORDER_REVERSAL:
drivers/char/ipmi/ipmi_si_intf.c:352: lock_acquire: Calling function "_spin_lock" acquires lock "smi_info->msg_lock".
drivers/char/ipmi/ipmi_si_intf.c:908: lock_acquire: Calling function "_spin_lock_irqsave" acquires lock "smi_info->si_lock".
drivers/char/ipmi/ipmi_si_intf.c:910: example_lock_order: Calling "start_next_msg" acquires lock "smi_info.msg_lock" after lock "smi_info->si_lock".
drivers/char/ipmi/ipmi_si_intf.c:352: getlock: Acquiring lock named smi_info.msg_lock.
drivers/char/ipmi/ipmi_si_intf.c:386: lock_order: Calling "return_hosed_msg" acquires lock "smi_info.si_lock" after lock "smi_info->msg_lock" (count: 1 / 2).
drivers/char/ipmi/ipmi_si_intf.c:336: getlock: Acquiring lock named <unset>.
drivers/char/ipmi/ipmi_si_intf.c:318: getlock: Acquiring lock named smi_info.si_lock.

Error: ORDER_REVERSAL:
drivers/mtd/chips/cfi_cmdset_0001.c:933: lock_acquire: Calling function "_spin_lock" acquires lock "shared->lock".
drivers/mtd/chips/cfi_cmdset_0001.c:878: lock_acquire: Calling function "_spin_lock" acquires lock "chip->mutex".
drivers/mtd/chips/cfi_cmdset_0001.c:888: example_lock_order: Calling "_spin_lock" acquires lock "shared->lock" after lock "chip->mutex".
drivers/mtd/chips/cfi_cmdset_0001.c:910: lock_acquire: Calling function "_spin_lock" acquires lock "chip->mutex".
drivers/mtd/chips/cfi_cmdset_0001.c:860: example_lock_order: Calling "_spin_lock" acquires lock "shared->lock" after lock "chip->mutex".
drivers/mtd/chips/cfi_cmdset_0001.c:2122: lock_acquire: Calling function "_spin_lock" acquires lock "chip->mutex".
drivers/mtd/chips/cfi_cmdset_0001.c:2143: example_lock_order: Calling "put_chip" acquires lock "flchip_shared.lock" after lock "chip->mutex".
drivers/mtd/chips/cfi_cmdset_0001.c:933: getlock: Acquiring lock named flchip_shared.lock.
drivers/mtd/chips/cfi_cmdset_0001.c:1393: lock_acquire: Calling function "_spin_lock" acquires lock "chip->mutex".
drivers/mtd/chips/cfi_cmdset_0001.c:1408: example_lock_order: Calling "put_chip" acquires lock "flchip_shared.lock" after lock "chip->mutex".
drivers/mtd/chips/cfi_cmdset_0001.c:933: getlock: Acquiring lock named flchip_shared.lock.
drivers/mtd/chips/cfi_cmdset_0001.c:1365: lock_acquire: Calling function "_spin_lock" acquires lock "chip->mutex".
drivers/mtd/chips/cfi_cmdset_0001.c:1373: example_lock_order: Calling "put_chip" acquires lock "flchip_shared.lock" after lock "chip->mutex".
drivers/mtd/chips/cfi_cmdset_0001.c:933: getlock: Acquiring lock named flchip_shared.lock.
drivers/mtd/chips/cfi_cmdset_0001.c:940: lock_order: Calling "_spin_lock" acquires lock "loaner->mutex" after lock "shared->lock" (count: 1 / 11).

Error: ORDER_REVERSAL:
kernel/sched.c:6281: lock_acquire: Calling function "_spin_lock_irq" acquires lock "rq->lock".
mm/slub.c:2409: lock_acquire: Calling function "_spin_lock_irqsave" acquires lock "n->list_lock".
mm/slub.c:2416: example_lock_order: Calling "list_slab_objects" acquires lock "rq.lock" after lock "n->list_lock".
mm/slub.c:2392: getlock: Acquiring lock named <unset>.
kernel/printk.c:564: getlock: Acquiring lock named <unset>.
kernel/printk.c:737: getlock: Acquiring lock named <unset>.
kernel/sched.c:4531: getlock: Acquiring lock named <unset>.
kernel/sched.c:4463: getlock: Acquiring lock named rq.lock.
mm/slub.c:3320: lock_acquire: Calling function "_spin_lock_irqsave" acquires lock "n->list_lock".
mm/slub.c:3323: example_lock_order: Calling "validate_slab_slab" acquires lock "rq.lock" after lock "n->list_lock".
mm/slub.c:3304: getlock: Acquiring lock named <unset>.
kernel/printk.c:564: getlock: Acquiring lock named <unset>.
kernel/printk.c:737: getlock: Acquiring lock named <unset>.
kernel/sched.c:4531: getlock: Acquiring lock named <unset>.
kernel/sched.c:4463: getlock: Acquiring lock named rq.lock.
kernel/sched.c:6283: lock_order: Calling "put_task_struct" acquires lock "kmem_cache_node.list_lock" after lock "rq->lock" (count: 2 / 4).
include/linux/sched.h:1530: getlock: Acquiring lock named <unset>.
kernel/fork.c:156: getlock: Acquiring lock named <unset>.
kernel/fork.c:140: getlock: Acquiring lock named <unset>.
mm/slub.c:1734: getlock: Acquiring lock named <unset>.
mm/slub.c:1723: getlock: Acquiring lock named <unset>.
mm/slub.c:1690: getlock: Acquiring lock named <unset>.
mm/slub.c:944: getlock: Acquiring lock named <unset>.
mm/slub.c:821: getlock: Acquiring lock named kmem_cache_node.list_lock.

Error: ORDER_REVERSAL:
drivers/char/rio/riotable.c:472: lock_acquire: Calling function "_spin_lock_irqsave" acquires lock "HostP->HostLock".
drivers/char/rio/riocmd.c:825: lock_acquire: Calling function "_spin_lock_irqsave" acquires lock "PortP->portSem".
drivers/char/rio/riocmd.c:829: example_lock_order: Calling "put_free_end" acquires lock "Host.HostLock" after lock "PortP->portSem".
drivers/char/rio/rioparam.c:612: getlock: Acquiring lock named Host.HostLock.
drivers/char/rio/riotable.c:506: lock_order: Calling "_spin_lock_irqsave" acquires lock "PortP->portSem" after lock "HostP->HostLock" (count: 1 / 2).

Error: ORDER_REVERSAL:
kernel/signal.c:1741: lock_acquire: Calling function "_spin_lock_irq" acquires lock "sighand->siglock".
drivers/char/tty_io.c:604: lock_acquire: Calling function "_read_lock" acquires lock "tasklist_lock".
drivers/char/tty_io.c:607: example_lock_order: Calling "_spin_lock_irq" acquires lock "p->sighand->siglock" after lock "tasklist_lock".
drivers/char/tty_io.c:832: lock_acquire: Calling function "_read_lock" acquires lock "tasklist_lock".
drivers/char/tty_io.c:833: example_lock_order: Calling "session_clear_tty" acquires lock "sighand_struct.siglock" after lock "tasklist_lock".
drivers/char/tty_io.c:747: getlock: Acquiring lock named <unset>.
drivers/char/tty_io.c:3040: getlock: Acquiring lock named sighand_struct.siglock.
drivers/char/tty_io.c:1704: lock_acquire: Calling function "_read_lock" acquires lock "tasklist_lock".
drivers/char/tty_io.c:1705: example_lock_order: Calling "session_clear_tty" acquires lock "sighand_struct.siglock" after lock "tasklist_lock".
drivers/char/tty_io.c:747: getlock: Acquiring lock named <unset>.
drivers/char/tty_io.c:3040: getlock: Acquiring lock named sighand_struct.siglock.
drivers/char/tty_io.c:2689: lock_acquire: Calling function "_read_lock" acquires lock "tasklist_lock".
drivers/char/tty_io.c:2695: example_lock_order: Calling "send_sig" acquires lock "sighand_struct.siglock" after lock "tasklist_lock".
kernel/signal.c:1194: getlock: Acquiring lock named <unset>.
kernel/signal.c:1182: getlock: Acquiring lock named sighand_struct.siglock.
drivers/char/tty_io.c:2222: lock_acquire: Calling function "_read_lock" acquires lock "tasklist_lock".
drivers/char/tty_io.c:2223: example_lock_order: Calling "session_clear_tty" acquires lock "sighand_struct.siglock" after lock "tasklist_lock".
drivers/char/tty_io.c:747: getlock: Acquiring lock named <unset>.
drivers/char/tty_io.c:3040: getlock: Acquiring lock named sighand_struct.siglock.
kernel/signal.c:1765: lock_order: Calling "do_signal_stop" acquires lock "tasklist_lock" after lock "sighand->siglock" (count: 3 / 36).
kernel/signal.c:1682: getlock: Acquiring lock named <unset>.
kernel/signal.c:1618: getlock: Acquiring lock named tasklist_lock.

Error: ORDER_REVERSAL:
kernel/signal.c:1741: lock_acquire: Calling function "_spin_lock_irq" acquires lock "sighand->siglock".
drivers/char/tty_io.c:604: lock_acquire: Calling function "_read_lock" acquires lock "tasklist_lock".
drivers/char/tty_io.c:607: example_lock_order: Calling "_spin_lock_irq" acquires lock "p->sighand->siglock" after lock "tasklist_lock".
drivers/char/tty_io.c:832: lock_acquire: Calling function "_read_lock" acquires lock "tasklist_lock".
drivers/char/tty_io.c:833: example_lock_order: Calling "session_clear_tty" acquires lock "sighand_struct.siglock" after lock "tasklist_lock".
drivers/char/tty_io.c:747: getlock: Acquiring lock named <unset>.
drivers/char/tty_io.c:3040: getlock: Acquiring lock named sighand_struct.siglock.
drivers/char/tty_io.c:1704: lock_acquire: Calling function "_read_lock" acquires lock "tasklist_lock".
drivers/char/tty_io.c:1705: example_lock_order: Calling "session_clear_tty" acquires lock "sighand_struct.siglock" after lock "tasklist_lock".
drivers/char/tty_io.c:747: getlock: Acquiring lock named <unset>.
drivers/char/tty_io.c:3040: getlock: Acquiring lock named sighand_struct.siglock.
drivers/char/tty_io.c:2689: lock_acquire: Calling function "_read_lock" acquires lock "tasklist_lock".
drivers/char/tty_io.c:2695: example_lock_order: Calling "send_sig" acquires lock "sighand_struct.siglock" after lock "tasklist_lock".
kernel/signal.c:1194: getlock: Acquiring lock named <unset>.
kernel/signal.c:1182: getlock: Acquiring lock named sighand_struct.siglock.
drivers/char/tty_io.c:2222: lock_acquire: Calling function "_read_lock" acquires lock "tasklist_lock".
drivers/char/tty_io.c:2223: example_lock_order: Calling "session_clear_tty" acquires lock "sighand_struct.siglock" after lock "tasklist_lock".
drivers/char/tty_io.c:747: getlock: Acquiring lock named <unset>.
drivers/char/tty_io.c:3040: getlock: Acquiring lock named sighand_struct.siglock.
kernel/signal.c:1843: lock_order: Calling "do_signal_stop" acquires lock "tasklist_lock" after lock "sighand->siglock" (count: 3 / 36).
kernel/signal.c:1682: getlock: Acquiring lock named <unset>.
kernel/signal.c:1618: getlock: Acquiring lock named tasklist_lock.

Error: ORDER_REVERSAL:
kernel/signal.c:1741: lock_acquire: Calling function "_spin_lock_irq" acquires lock "sighand->siglock".
drivers/char/tty_io.c:604: lock_acquire: Calling function "_read_lock" acquires lock "tasklist_lock".
drivers/char/tty_io.c:607: example_lock_order: Calling "_spin_lock_irq" acquires lock "p->sighand->siglock" after lock "tasklist_lock".
drivers/char/tty_io.c:832: lock_acquire: Calling function "_read_lock" acquires lock "tasklist_lock".
drivers/char/tty_io.c:833: example_lock_order: Calling "session_clear_tty" acquires lock "sighand_struct.siglock" after lock "tasklist_lock".
drivers/char/tty_io.c:747: getlock: Acquiring lock named <unset>.
drivers/char/tty_io.c:3040: getlock: Acquiring lock named sighand_struct.siglock.
drivers/char/tty_io.c:1704: lock_acquire: Calling function "_read_lock" acquires lock "tasklist_lock".
drivers/char/tty_io.c:1705: example_lock_order: Calling "session_clear_tty" acquires lock "sighand_struct.siglock" after lock "tasklist_lock".
drivers/char/tty_io.c:747: getlock: Acquiring lock named <unset>.
drivers/char/tty_io.c:3040: getlock: Acquiring lock named sighand_struct.siglock.
drivers/char/tty_io.c:2689: lock_acquire: Calling function "_read_lock" acquires lock "tasklist_lock".
drivers/char/tty_io.c:2695: example_lock_order: Calling "send_sig" acquires lock "sighand_struct.siglock" after lock "tasklist_lock".
kernel/signal.c:1194: getlock: Acquiring lock named <unset>.
kernel/signal.c:1182: getlock: Acquiring lock named sighand_struct.siglock.
drivers/char/tty_io.c:2222: lock_acquire: Calling function "_read_lock" acquires lock "tasklist_lock".
drivers/char/tty_io.c:2223: example_lock_order: Calling "session_clear_tty" acquires lock "sighand_struct.siglock" after lock "tasklist_lock".
drivers/char/tty_io.c:747: getlock: Acquiring lock named <unset>.
drivers/char/tty_io.c:3040: getlock: Acquiring lock named sighand_struct.siglock.
kernel/signal.c:1787: lock_order: Calling "ptrace_signal" acquires lock "tasklist_lock" after lock "sighand->siglock" (count: 3 / 36).
kernel/signal.c:1695: getlock: Acquiring lock named <unset>.
kernel/signal.c:1552: getlock: Acquiring lock named tasklist_lock.

Error: ORDER_REVERSAL:
kernel/signal.c:1741: lock_acquire: Calling function "_spin_lock_irq" acquires lock "sighand->siglock".
drivers/char/tty_io.c:2708: lock_acquire: Calling function "task_lock" acquires lock "p->alloc_lock".
include/linux/sched.h:1987: lock: "_spin_lock" locks "p->alloc_lock".
drivers/char/tty_io.c:2725: example_lock_order: Calling "force_sig" acquires lock "sighand_struct.siglock" after lock "p->alloc_lock".
kernel/signal.c:1200: getlock: Acquiring lock named <unset>.
kernel/signal.c:938: getlock: Acquiring lock named sighand_struct.siglock.
kernel/ptrace.c:176: lock_acquire: Calling function "task_lock" acquires lock "task->alloc_lock".
include/linux/sched.h:1987: lock: "_spin_lock" locks "p->alloc_lock".
kernel/ptrace.c:201: example_lock_order: Calling "send_sig_info" acquires lock "sighand_struct.siglock" after lock "task->alloc_lock".
kernel/signal.c:1182: getlock: Acquiring lock named sighand_struct.siglock.
kernel/signal.c:1739: lock_order: Calling "try_to_freeze" acquires lock "task_struct.alloc_lock" after lock "sighand->siglock" (count: 2 / 4).
include/linux/freezer.h:57: getlock: Acquiring lock named <unset>.
kernel/freezer.c:32: getlock: Acquiring lock named <unset>.
include/linux/sched.h:1987: getlock: Acquiring lock named task_struct.alloc_lock.

Error: ORDER_REVERSAL:
kernel/signal.c:1840: lock_acquire: Calling function "_spin_lock_irq" acquires lock "sighand->siglock".
drivers/char/tty_io.c:604: lock_acquire: Calling function "_read_lock" acquires lock "tasklist_lock".
drivers/char/tty_io.c:607: example_lock_order: Calling "_spin_lock_irq" acquires lock "p->sighand->siglock" after lock "tasklist_lock".
drivers/char/tty_io.c:832: lock_acquire: Calling function "_read_lock" acquires lock "tasklist_lock".
drivers/char/tty_io.c:833: example_lock_order: Calling "session_clear_tty" acquires lock "sighand_struct.siglock" after lock "tasklist_lock".
drivers/char/tty_io.c:747: getlock: Acquiring lock named <unset>.
drivers/char/tty_io.c:3040: getlock: Acquiring lock named sighand_struct.siglock.
drivers/char/tty_io.c:1704: lock_acquire: Calling function "_read_lock" acquires lock "tasklist_lock".
drivers/char/tty_io.c:1705: example_lock_order: Calling "session_clear_tty" acquires lock "sighand_struct.siglock" after lock "tasklist_lock".
drivers/char/tty_io.c:747: getlock: Acquiring lock named <unset>.
drivers/char/tty_io.c:3040: getlock: Acquiring lock named sighand_struct.siglock.
drivers/char/tty_io.c:2689: lock_acquire: Calling function "_read_lock" acquires lock "tasklist_lock".
drivers/char/tty_io.c:2695: example_lock_order: Calling "send_sig" acquires lock "sighand_struct.siglock" after lock "tasklist_lock".
kernel/signal.c:1194: getlock: Acquiring lock named <unset>.
kernel/signal.c:1182: getlock: Acquiring lock named sighand_struct.siglock.
drivers/char/tty_io.c:2222: lock_acquire: Calling function "_read_lock" acquires lock "tasklist_lock".
drivers/char/tty_io.c:2223: example_lock_order: Calling "session_clear_tty" acquires lock "sighand_struct.siglock" after lock "tasklist_lock".
drivers/char/tty_io.c:747: getlock: Acquiring lock named <unset>.
drivers/char/tty_io.c:3040: getlock: Acquiring lock named sighand_struct.siglock.
kernel/signal.c:1843: lock_order: Calling "do_signal_stop" acquires lock "tasklist_lock" after lock "sighand->siglock" (count: 3 / 36).
kernel/signal.c:1682: getlock: Acquiring lock named <unset>.
kernel/signal.c:1618: getlock: Acquiring lock named tasklist_lock.

Error: ORDER_REVERSAL:
kernel/signal.c:1840: lock_acquire: Calling function "_spin_lock_irq" acquires lock "sighand->siglock".
drivers/char/tty_io.c:2708: lock_acquire: Calling function "task_lock" acquires lock "p->alloc_lock".
include/linux/sched.h:1987: lock: "_spin_lock" locks "p->alloc_lock".
drivers/char/tty_io.c:2725: example_lock_order: Calling "force_sig" acquires lock "sighand_struct.siglock" after lock "p->alloc_lock".
kernel/signal.c:1200: getlock: Acquiring lock named <unset>.
kernel/signal.c:938: getlock: Acquiring lock named sighand_struct.siglock.
kernel/ptrace.c:176: lock_acquire: Calling function "task_lock" acquires lock "task->alloc_lock".
include/linux/sched.h:1987: lock: "_spin_lock" locks "p->alloc_lock".
kernel/ptrace.c:201: example_lock_order: Calling "send_sig_info" acquires lock "sighand_struct.siglock" after lock "task->alloc_lock".
kernel/signal.c:1182: getlock: Acquiring lock named sighand_struct.siglock.
kernel/signal.c:1739: lock_order: Calling "try_to_freeze" acquires lock "task_struct.alloc_lock" after lock "sighand->siglock" (count: 2 / 4).
include/linux/freezer.h:57: getlock: Acquiring lock named <unset>.
kernel/freezer.c:32: getlock: Acquiring lock named <unset>.
include/linux/sched.h:1987: getlock: Acquiring lock named task_struct.alloc_lock.

Error: ORDER_REVERSAL:
mm/slub.c:3320: lock_acquire: Calling function "_spin_lock_irqsave" acquires lock "n->list_lock".
kernel/sched.c:4463: lock_acquire: Calling function "_spin_lock_irq" acquires lock "rq->lock".
kernel/sched.c:4493: example_lock_order: Calling "context_switch" acquires lock "kmem_cache_node.list_lock" after lock "rq->lock".
kernel/sched.c:2665: getlock: Acquiring lock named <unset>.
kernel/sched.c:2592: getlock: Acquiring lock named <unset>.
include/linux/sched.h:1530: getlock: Acquiring lock named <unset>.
kernel/fork.c:156: getlock: Acquiring lock named <unset>.
kernel/fork.c:140: getlock: Acquiring lock named <unset>.
mm/slub.c:1734: getlock: Acquiring lock named <unset>.
mm/slub.c:1723: getlock: Acquiring lock named <unset>.
mm/slub.c:1690: getlock: Acquiring lock named <unset>.
mm/slub.c:944: getlock: Acquiring lock named <unset>.
mm/slub.c:821: getlock: Acquiring lock named kmem_cache_node.list_lock.
kernel/sched.c:6281: lock_acquire: Calling function "_spin_lock_irq" acquires lock "rq->lock".
kernel/sched.c:6283: example_lock_order: Calling "put_task_struct" acquires lock "kmem_cache_node.list_lock" after lock "rq->lock".
include/linux/sched.h:1530: getlock: Acquiring lock named <unset>.
kernel/fork.c:156: getlock: Acquiring lock named <unset>.
kernel/fork.c:140: getlock: Acquiring lock named <unset>.
mm/slub.c:1734: getlock: Acquiring lock named <unset>.
mm/slub.c:1723: getlock: Acquiring lock named <unset>.
mm/slub.c:1690: getlock: Acquiring lock named <unset>.
mm/slub.c:944: getlock: Acquiring lock named <unset>.
mm/slub.c:821: getlock: Acquiring lock named kmem_cache_node.list_lock.
mm/slub.c:3327: lock_order: Calling "printk" acquires lock "rq.lock" after lock "n->list_lock" (count: 2 / 4).
kernel/printk.c:564: getlock: Acquiring lock named <unset>.
kernel/printk.c:737: getlock: Acquiring lock named <unset>.
kernel/sched.c:4531: getlock: Acquiring lock named <unset>.
kernel/sched.c:4463: getlock: Acquiring lock named rq.lock.

Error: ORDER_REVERSAL:
mm/slub.c:3320: lock_acquire: Calling function "_spin_lock_irqsave" acquires lock "n->list_lock".
kernel/sched.c:4463: lock_acquire: Calling function "_spin_lock_irq" acquires lock "rq->lock".
kernel/sched.c:4493: example_lock_order: Calling "context_switch" acquires lock "kmem_cache_node.list_lock" after lock "rq->lock".
kernel/sched.c:2665: getlock: Acquiring lock named <unset>.
kernel/sched.c:2592: getlock: Acquiring lock named <unset>.
include/linux/sched.h:1530: getlock: Acquiring lock named <unset>.
kernel/fork.c:156: getlock: Acquiring lock named <unset>.
kernel/fork.c:140: getlock: Acquiring lock named <unset>.
mm/slub.c:1734: getlock: Acquiring lock named <unset>.
mm/slub.c:1723: getlock: Acquiring lock named <unset>.
mm/slub.c:1690: getlock: Acquiring lock named <unset>.
mm/slub.c:944: getlock: Acquiring lock named <unset>.
mm/slub.c:821: getlock: Acquiring lock named kmem_cache_node.list_lock.
kernel/sched.c:6281: lock_acquire: Calling function "_spin_lock_irq" acquires lock "rq->lock".
kernel/sched.c:6283: example_lock_order: Calling "put_task_struct" acquires lock "kmem_cache_node.list_lock" after lock "rq->lock".
include/linux/sched.h:1530: getlock: Acquiring lock named <unset>.
kernel/fork.c:156: getlock: Acquiring lock named <unset>.
kernel/fork.c:140: getlock: Acquiring lock named <unset>.
mm/slub.c:1734: getlock: Acquiring lock named <unset>.
mm/slub.c:1723: getlock: Acquiring lock named <unset>.
mm/slub.c:1690: getlock: Acquiring lock named <unset>.
mm/slub.c:944: getlock: Acquiring lock named <unset>.
mm/slub.c:821: getlock: Acquiring lock named kmem_cache_node.list_lock.
mm/slub.c:3338: lock_order: Calling "printk" acquires lock "rq.lock" after lock "n->list_lock" (count: 2 / 4).
kernel/printk.c:564: getlock: Acquiring lock named <unset>.
kernel/printk.c:737: getlock: Acquiring lock named <unset>.
kernel/sched.c:4531: getlock: Acquiring lock named <unset>.
kernel/sched.c:4463: getlock: Acquiring lock named rq.lock.

Error: ORDER_REVERSAL:
mm/slub.c:3320: lock_acquire: Calling function "_spin_lock_irqsave" acquires lock "n->list_lock".
kernel/sched.c:4463: lock_acquire: Calling function "_spin_lock_irq" acquires lock "rq->lock".
kernel/sched.c:4493: example_lock_order: Calling "context_switch" acquires lock "kmem_cache_node.list_lock" after lock "rq->lock".
kernel/sched.c:2665: getlock: Acquiring lock named <unset>.
kernel/sched.c:2592: getlock: Acquiring lock named <unset>.
include/linux/sched.h:1530: getlock: Acquiring lock named <unset>.
kernel/fork.c:156: getlock: Acquiring lock named <unset>.
kernel/fork.c:140: getlock: Acquiring lock named <unset>.
mm/slub.c:1734: getlock: Acquiring lock named <unset>.
mm/slub.c:1723: getlock: Acquiring lock named <unset>.
mm/slub.c:1690: getlock: Acquiring lock named <unset>.
mm/slub.c:944: getlock: Acquiring lock named <unset>.
mm/slub.c:821: getlock: Acquiring lock named kmem_cache_node.list_lock.
kernel/sched.c:6281: lock_acquire: Calling function "_spin_lock_irq" acquires lock "rq->lock".
kernel/sched.c:6283: example_lock_order: Calling "put_task_struct" acquires lock "kmem_cache_node.list_lock" after lock "rq->lock".
include/linux/sched.h:1530: getlock: Acquiring lock named <unset>.
kernel/fork.c:156: getlock: Acquiring lock named <unset>.
kernel/fork.c:140: getlock: Acquiring lock named <unset>.
mm/slub.c:1734: getlock: Acquiring lock named <unset>.
mm/slub.c:1723: getlock: Acquiring lock named <unset>.
mm/slub.c:1690: getlock: Acquiring lock named <unset>.
mm/slub.c:944: getlock: Acquiring lock named <unset>.
mm/slub.c:821: getlock: Acquiring lock named kmem_cache_node.list_lock.
mm/slub.c:3323: lock_order: Calling "validate_slab_slab" acquires lock "rq.lock" after lock "n->list_lock" (count: 2 / 4).
mm/slub.c:3304: getlock: Acquiring lock named <unset>.
kernel/printk.c:564: getlock: Acquiring lock named <unset>.
kernel/printk.c:737: getlock: Acquiring lock named <unset>.
kernel/sched.c:4531: getlock: Acquiring lock named <unset>.
kernel/sched.c:4463: getlock: Acquiring lock named rq.lock.

Error: ORDER_REVERSAL:
mm/slub.c:3320: lock_acquire: Calling function "_spin_lock_irqsave" acquires lock "n->list_lock".
kernel/sched.c:4463: lock_acquire: Calling function "_spin_lock_irq" acquires lock "rq->lock".
kernel/sched.c:4493: example_lock_order: Calling "context_switch" acquires lock "kmem_cache_node.list_lock" after lock "rq->lock".
kernel/sched.c:2665: getlock: Acquiring lock named <unset>.
kernel/sched.c:2592: getlock: Acquiring lock named <unset>.
include/linux/sched.h:1530: getlock: Acquiring lock named <unset>.
kernel/fork.c:156: getlock: Acquiring lock named <unset>.
kernel/fork.c:140: getlock: Acquiring lock named <unset>.
mm/slub.c:1734: getlock: Acquiring lock named <unset>.
mm/slub.c:1723: getlock: Acquiring lock named <unset>.
mm/slub.c:1690: getlock: Acquiring lock named <unset>.
mm/slub.c:944: getlock: Acquiring lock named <unset>.
mm/slub.c:821: getlock: Acquiring lock named kmem_cache_node.list_lock.
kernel/sched.c:6281: lock_acquire: Calling function "_spin_lock_irq" acquires lock "rq->lock".
kernel/sched.c:6283: example_lock_order: Calling "put_task_struct" acquires lock "kmem_cache_node.list_lock" after lock "rq->lock".
include/linux/sched.h:1530: getlock: Acquiring lock named <unset>.
kernel/fork.c:156: getlock: Acquiring lock named <unset>.
kernel/fork.c:140: getlock: Acquiring lock named <unset>.
mm/slub.c:1734: getlock: Acquiring lock named <unset>.
mm/slub.c:1723: getlock: Acquiring lock named <unset>.
mm/slub.c:1690: getlock: Acquiring lock named <unset>.
mm/slub.c:944: getlock: Acquiring lock named <unset>.
mm/slub.c:821: getlock: Acquiring lock named kmem_cache_node.list_lock.
mm/slub.c:3334: lock_order: Calling "validate_slab_slab" acquires lock "rq.lock" after lock "n->list_lock" (count: 2 / 4).
mm/slub.c:3304: getlock: Acquiring lock named <unset>.
kernel/printk.c:564: getlock: Acquiring lock named <unset>.
kernel/printk.c:737: getlock: Acquiring lock named <unset>.
kernel/sched.c:4531: getlock: Acquiring lock named <unset>.
kernel/sched.c:4463: getlock: Acquiring lock named rq.lock.

Error: ORDER_REVERSAL:
drivers/char/tty_io.c:2708: lock_acquire: Calling function "task_lock" acquires lock "p->alloc_lock".
include/linux/sched.h:1987: lock: "_spin_lock" locks "p->alloc_lock".
kernel/signal.c:1741: lock_acquire: Calling function "_spin_lock_irq" acquires lock "sighand->siglock".
kernel/signal.c:1739: example_lock_order: Calling "try_to_freeze" acquires lock "task_struct.alloc_lock" after lock "sighand->siglock".
include/linux/freezer.h:57: getlock: Acquiring lock named <unset>.
kernel/freezer.c:32: getlock: Acquiring lock named <unset>.
include/linux/sched.h:1987: getlock: Acquiring lock named task_struct.alloc_lock.
kernel/signal.c:1840: lock_acquire: Calling function "_spin_lock_irq" acquires lock "sighand->siglock".
kernel/signal.c:1739: example_lock_order: Calling "try_to_freeze" acquires lock "task_struct.alloc_lock" after lock "sighand->siglock".
include/linux/freezer.h:57: getlock: Acquiring lock named <unset>.
kernel/freezer.c:32: getlock: Acquiring lock named <unset>.
include/linux/sched.h:1987: getlock: Acquiring lock named task_struct.alloc_lock.
drivers/char/tty_io.c:2725: lock_order: Calling "force_sig" acquires lock "sighand_struct.siglock" after lock "p->alloc_lock" (count: 2 / 4).
kernel/signal.c:1200: getlock: Acquiring lock named <unset>.
kernel/signal.c:938: getlock: Acquiring lock named sighand_struct.siglock.

Error: ORDER_REVERSAL:
net/bluetooth/sco.c:154: lock_acquire: Calling function "_spin_lock" acquires lock "sk->sk_lock.slock".
net/bluetooth/sco.c:796: lock_acquire: Calling function "_spin_lock" acquires lock "conn->lock".
net/bluetooth/sco.c:800: example_lock_order: Calling "_spin_lock" acquires lock "sk->sk_lock.slock" after lock "conn->lock".
net/bluetooth/sco.c:156: lock_order: Calling "sco_chan_del" acquires lock "sco_conn.lock" after lock "sk->sk_lock.slock" (count: 1 / 2).
net/bluetooth/sco.c:776: getlock: Acquiring lock named sco_conn.lock.

Error: ORDER_REVERSAL:
kernel/sched_rt.c:540: lock_acquire: Calling function "_spin_lock" acquires lock "rt_rq->rt_runtime_lock".
kernel/sched_rt.c:305: lock_acquire: Calling function "_spin_lock" acquires lock "rt_b->rt_runtime_lock".
kernel/sched_rt.c:306: example_lock_order: Calling "_spin_lock" acquires lock "rt_rq->rt_runtime_lock" after lock "rt_b->rt_runtime_lock".
kernel/sched_rt.c:391: lock_acquire: Calling function "_spin_lock" acquires lock "rt_b->rt_runtime_lock".
kernel/sched_rt.c:392: example_lock_order: Calling "_spin_lock" acquires lock "rt_rq->rt_runtime_lock" after lock "rt_b->rt_runtime_lock".
kernel/sched_rt.c:246: lock_acquire: Calling function "_spin_lock" acquires lock "rt_b->rt_runtime_lock".
kernel/sched_rt.c:255: example_lock_order: Calling "_spin_lock" acquires lock "iter->rt_runtime_lock" after lock "rt_b->rt_runtime_lock".
kernel/sched.c:8964: lock_acquire: Calling function "_spin_lock_irq" acquires lock "tg->rt_bandwidth.rt_runtime_lock".
kernel/sched.c:8971: example_lock_order: Calling "_spin_lock" acquires lock "rt_rq->rt_runtime_lock" after lock "tg->rt_bandwidth.rt_runtime_lock".
kernel/sched_rt.c:543: lock_order: Calling "sched_rt_runtime_exceeded" acquires lock "rt_bandwidth.rt_runtime_lock" after lock "rt_rq->rt_runtime_lock" (count: 2 / 6).
kernel/sched_rt.c:492: getlock: Acquiring lock named <unset>.
kernel/sched_rt.c:416: getlock: Acquiring lock named <unset>.
kernel/sched_rt.c:246: getlock: Acquiring lock named rt_bandwidth.rt_runtime_lock.

Error: ORDER_REVERSAL:
drivers/atm/he.c:1685: lock_acquire: Calling function "_read_lock" acquires lock "vcc_sklist_lock".
drivers/atm/he.c:2003: lock_acquire: Calling function "_spin_lock_irqsave" acquires lock "he_dev->global_lock".
drivers/atm/he.c:2016: example_lock_order: Calling "he_service_rbrq" acquires lock "vcc_sklist_lock" after lock "he_dev->global_lock".
drivers/atm/he.c:1685: getlock: Acquiring lock named vcc_sklist_lock.
drivers/atm/he.c:2039: lock_acquire: Calling function "_spin_lock_irqsave" acquires lock "he_dev->global_lock".
drivers/atm/he.c:2057: example_lock_order: Calling "he_service_rbrq" acquires lock "vcc_sklist_lock" after lock "he_dev->global_lock".
drivers/atm/he.c:1685: getlock: Acquiring lock named vcc_sklist_lock.
drivers/atm/he.c:1821: lock_order: Calling "_spin_lock" acquires lock "he_dev->global_lock" after lock "vcc_sklist_lock" (count: 1 / 3).

Error: ORDER_REVERSAL:
kernel/ptrace.c:176: lock_acquire: Calling function "task_lock" acquires lock "task->alloc_lock".
include/linux/sched.h:1987: lock: "_spin_lock" locks "p->alloc_lock".
kernel/signal.c:1741: lock_acquire: Calling function "_spin_lock_irq" acquires lock "sighand->siglock".
kernel/signal.c:1739: example_lock_order: Calling "try_to_freeze" acquires lock "task_struct.alloc_lock" after lock "sighand->siglock".
include/linux/freezer.h:57: getlock: Acquiring lock named <unset>.
kernel/freezer.c:32: getlock: Acquiring lock named <unset>.
include/linux/sched.h:1987: getlock: Acquiring lock named task_struct.alloc_lock.
kernel/signal.c:1840: lock_acquire: Calling function "_spin_lock_irq" acquires lock "sighand->siglock".
kernel/signal.c:1739: example_lock_order: Calling "try_to_freeze" acquires lock "task_struct.alloc_lock" after lock "sighand->siglock".
include/linux/freezer.h:57: getlock: Acquiring lock named <unset>.
kernel/freezer.c:32: getlock: Acquiring lock named <unset>.
include/linux/sched.h:1987: getlock: Acquiring lock named task_struct.alloc_lock.
kernel/ptrace.c:201: lock_order: Calling "send_sig_info" acquires lock "sighand_struct.siglock" after lock "task->alloc_lock" (count: 2 / 4).
kernel/signal.c:1182: getlock: Acquiring lock named sighand_struct.siglock.

Error: ORDER_REVERSAL:
kernel/sched_rt.c:447: lock_acquire: Calling function "_spin_lock" acquires lock "rt_rq->rt_runtime_lock".
kernel/sched_rt.c:305: lock_acquire: Calling function "_spin_lock" acquires lock "rt_b->rt_runtime_lock".
kernel/sched_rt.c:306: example_lock_order: Calling "_spin_lock" acquires lock "rt_rq->rt_runtime_lock" after lock "rt_b->rt_runtime_lock".
kernel/sched_rt.c:391: lock_acquire: Calling function "_spin_lock" acquires lock "rt_b->rt_runtime_lock".
kernel/sched_rt.c:392: example_lock_order: Calling "_spin_lock" acquires lock "rt_rq->rt_runtime_lock" after lock "rt_b->rt_runtime_lock".
kernel/sched_rt.c:246: lock_acquire: Calling function "_spin_lock" acquires lock "rt_b->rt_runtime_lock".
kernel/sched_rt.c:255: example_lock_order: Calling "_spin_lock" acquires lock "iter->rt_runtime_lock" after lock "rt_b->rt_runtime_lock".
kernel/sched.c:8964: lock_acquire: Calling function "_spin_lock_irq" acquires lock "tg->rt_bandwidth.rt_runtime_lock".
kernel/sched.c:8971: example_lock_order: Calling "_spin_lock" acquires lock "rt_rq->rt_runtime_lock" after lock "tg->rt_bandwidth.rt_runtime_lock".
kernel/sched_rt.c:449: lock_order: Calling "balance_runtime" acquires lock "rt_bandwidth.rt_runtime_lock" after lock "rt_rq->rt_runtime_lock" (count: 2 / 6).
kernel/sched_rt.c:416: getlock: Acquiring lock named <unset>.
kernel/sched_rt.c:246: getlock: Acquiring lock named rt_bandwidth.rt_runtime_lock.

Error: ORDER_REVERSAL:
net/bluetooth/sco.c:796: lock_acquire: Calling function "_spin_lock" acquires lock "conn->lock".
net/bluetooth/sco.c:154: lock_acquire: Calling function "_spin_lock" acquires lock "sk->sk_lock.slock".
net/bluetooth/sco.c:156: example_lock_order: Calling "sco_chan_del" acquires lock "sco_conn.lock" after lock "sk->sk_lock.slock".
net/bluetooth/sco.c:776: getlock: Acquiring lock named sco_conn.lock.
net/bluetooth/sco.c:809: lock_order: Calling "_spin_lock" acquires lock "parent->sk_lock.slock" after lock "conn->lock" (count: 1 / 2).

Error: ORDER_REVERSAL:
net/bluetooth/sco.c:796: lock_acquire: Calling function "_spin_lock" acquires lock "conn->lock".
net/bluetooth/sco.c:154: lock_acquire: Calling function "_spin_lock" acquires lock "sk->sk_lock.slock".
net/bluetooth/sco.c:156: example_lock_order: Calling "sco_chan_del" acquires lock "sco_conn.lock" after lock "sk->sk_lock.slock".
net/bluetooth/sco.c:776: getlock: Acquiring lock named sco_conn.lock.
net/bluetooth/sco.c:800: lock_order: Calling "_spin_lock" acquires lock "sk->sk_lock.slock" after lock "conn->lock" (count: 1 / 2).

Error: ORDER_REVERSAL:
fs/ocfs2/dlm/dlmthread.c:659: lock_acquire: Calling function "_spin_lock" acquires lock "res->spinlock".
fs/ocfs2/dlm/dlmthread.c:540: lock_acquire: Calling function "_spin_lock" acquires lock "dlm->ast_lock".
fs/ocfs2/dlm/dlmthread.c:554: example_lock_order: Calling "dlm_lockres_release_ast" acquires lock "dlm_lock_resource.spinlock" after lock "dlm->ast_lock".
fs/ocfs2/dlm/dlmmaster.c:3384: getlock: Acquiring lock named dlm_lock_resource.spinlock.
lib/dec_and_lock.c:28: lock: "_spin_lock" locks "*lock".
fs/ocfs2/dlm/dlmthread.c:588: lock_acquire: Calling function "_spin_lock" acquires lock "dlm->ast_lock".
fs/ocfs2/dlm/dlmthread.c:602: example_lock_order: Calling "dlm_lockres_release_ast" acquires lock "dlm_lock_resource.spinlock" after lock "dlm->ast_lock".
fs/ocfs2/dlm/dlmmaster.c:3384: getlock: Acquiring lock named dlm_lock_resource.spinlock.
lib/dec_and_lock.c:28: lock: "_spin_lock" locks "*lock".
fs/ocfs2/dlm/dlmthread.c:697: lock_order: Calling "dlm_shuffle_lists" acquires lock "dlm_ctxt.ast_lock" after lock "res->spinlock" (count: 1 / 3).
fs/ocfs2/dlm/dlmthread.c:387: getlock: Acquiring lock named <unset>.
fs/ocfs2/dlm/dlmast.c:178: getlock: Acquiring lock named dlm_ctxt.ast_lock.

Error: ORDER_REVERSAL:
drivers/char/rio/riocmd.c:825: lock_acquire: Calling function "_spin_lock_irqsave" acquires lock "PortP->portSem".
drivers/char/rio/riotable.c:472: lock_acquire: Calling function "_spin_lock_irqsave" acquires lock "HostP->HostLock".
drivers/char/rio/riotable.c:506: example_lock_order: Calling "_spin_lock_irqsave" acquires lock "PortP->portSem" after lock "HostP->HostLock".
drivers/char/rio/riocmd.c:829: lock_order: Calling "put_free_end" acquires lock "Host.HostLock" after lock "PortP->portSem" (count: 1 / 2).
drivers/char/rio/rioparam.c:612: getlock: Acquiring lock named Host.HostLock.

Error: ORDER_REVERSAL:
drivers/isdn/hardware/mISDN/hfcmulti.c:5037: lock_acquire: Calling function "_spin_lock_irqsave" acquires lock "HFClock".
drivers/isdn/hardware/mISDN/hfcmulti.c:4407: lock_acquire: Calling function "_spin_lock_irqsave" acquires lock "hc->lock".
drivers/isdn/hardware/mISDN/hfcmulti.c:4441: example_lock_order: Calling "plxsd_checksync" acquires lock "HFClock" after lock "hc->lock".
drivers/isdn/hardware/mISDN/hfcmulti.c:996: getlock: Acquiring lock named <unset>.
drivers/isdn/hardware/mISDN/hfcmulti.c:894: getlock: Acquiring lock named HFClock.
drivers/isdn/hardware/mISDN/hfcmulti.c:3125: lock_acquire: Calling function "_spin_lock_irqsave" acquires lock "hc->lock".
drivers/isdn/hardware/mISDN/hfcmulti.c:3140: example_lock_order: Calling "plxsd_checksync" acquires lock "HFClock" after lock "hc->lock".
drivers/isdn/hardware/mISDN/hfcmulti.c:996: getlock: Acquiring lock named <unset>.
drivers/isdn/hardware/mISDN/hfcmulti.c:894: getlock: Acquiring lock named HFClock.
drivers/isdn/hardware/mISDN/hfcmulti.c:1088: lock_acquire: Calling function "_spin_lock_irqsave" acquires lock "hc->lock".
drivers/isdn/hardware/mISDN/hfcmulti.c:1177: example_lock_order: Calling "_spin_lock_irqsave" acquires lock "HFClock" after lock "hc->lock".
drivers/isdn/hardware/mISDN/hfcmulti.c:2598: lock_acquire: Calling function "_spin_lock" acquires lock "hc->lock".
drivers/isdn/hardware/mISDN/hfcmulti.c:2688: example_lock_order: Calling "plxsd_checksync" acquires lock "HFClock" after lock "hc->lock".
drivers/isdn/hardware/mISDN/hfcmulti.c:996: getlock: Acquiring lock named <unset>.
drivers/isdn/hardware/mISDN/hfcmulti.c:894: getlock: Acquiring lock named HFClock.
drivers/isdn/hardware/mISDN/hfcmulti.c:5038: lock_order: Calling "release_card" acquires lock "hfc_multi.lock" after lock "HFClock" (count: 1 / 5).
drivers/isdn/hardware/mISDN/hfcmulti.c:4495: getlock: Acquiring lock named hfc_multi.lock.

Error: ORDER_REVERSAL:
drivers/char/ipmi/ipmi_si_intf.c:908: lock_acquire: Calling function "_spin_lock_irqsave" acquires lock "smi_info->si_lock".
drivers/char/ipmi/ipmi_si_intf.c:352: lock_acquire: Calling function "_spin_lock" acquires lock "smi_info->msg_lock".
drivers/char/ipmi/ipmi_si_intf.c:386: example_lock_order: Calling "return_hosed_msg" acquires lock "smi_info.si_lock" after lock "smi_info->msg_lock".
drivers/char/ipmi/ipmi_si_intf.c:336: getlock: Acquiring lock named <unset>.
drivers/char/ipmi/ipmi_si_intf.c:318: getlock: Acquiring lock named smi_info.si_lock.
drivers/char/ipmi/ipmi_si_intf.c:910: lock_order: Calling "start_next_msg" acquires lock "smi_info.msg_lock" after lock "smi_info->si_lock" (count: 1 / 2).
drivers/char/ipmi/ipmi_si_intf.c:352: getlock: Acquiring lock named smi_info.msg_lock.

Error: ORDER_REVERSAL:
sound/drivers/opl3/opl3_midi.c:245: lock_acquire: Calling function "_spin_lock_irqsave" acquires lock "opl3->sys_timer_lock".
sound/drivers/opl3/opl3_midi.c:345: lock_acquire: Calling function "_spin_lock_irqsave" acquires lock "opl3->voice_lock".
sound/drivers/opl3/opl3_midi.c:559: example_lock_order: Calling "snd_opl3_start_timer" acquires lock "snd_opl3.sys_timer_lock" after lock "opl3->voice_lock".
sound/drivers/opl3/opl3_midi.c:270: getlock: Acquiring lock named snd_opl3.sys_timer_lock.
sound/drivers/opl3/opl3_midi.c:250: lock_order: Calling "snd_opl3_note_off" acquires lock "snd_opl3.voice_lock" after lock "opl3->sys_timer_lock" (count: 1 / 2).
sound/drivers/opl3/opl3_midi.c:677: getlock: Acquiring lock named snd_opl3.voice_lock.

Error: ORDER_REVERSAL:
fs/ocfs2/dlm/dlmmaster.c:1427: lock_acquire: Calling function "_spin_lock" acquires lock "res->spinlock".
fs/ocfs2/dlm/dlmmaster.c:3169: lock_acquire: Calling function "_spin_lock" acquires lock "dlm->master_lock".
fs/ocfs2/dlm/dlmmaster.c:3246: example_lock_order: Calling "__dlm_lookup_lockres" acquires lock "dlm_lock_resource.spinlock" after lock "dlm->master_lock".
fs/ocfs2/dlm/dlmdomain.c:226: getlock: Acquiring lock named dlm_lock_resource.spinlock.
fs/ocfs2/dlm/dlmmaster.c:3036: lock_acquire: Calling function "_spin_lock" acquires lock "dlm->master_lock".
fs/ocfs2/dlm/dlmmaster.c:3039: example_lock_order: Calling "_spin_lock" acquires lock "res->spinlock" after lock "dlm->master_lock".
fs/ocfs2/dlm/dlmmaster.c:1475: lock_order: Calling "_spin_lock" acquires lock "dlm->master_lock" after lock "res->spinlock" (count: 1 / 3).

Error: ORDER_REVERSAL:
fs/ocfs2/dlm/dlmrecovery.c:1660: lock_acquire: Calling function "_spin_lock" acquires lock "dlm->spinlock".
fs/ocfs2/dlm/dlmdomain.c:892: lock_acquire: Calling function "_spin_lock" acquires lock "dlm_domain_lock".
fs/ocfs2/dlm/dlmdomain.c:896: example_lock_order: Calling "_spin_lock" acquires lock "dlm->spinlock" after lock "dlm_domain_lock".
fs/ocfs2/dlm/dlmdomain.c:930: lock_acquire: Calling function "_spin_lock" acquires lock "dlm_domain_lock".
fs/ocfs2/dlm/dlmdomain.c:934: example_lock_order: Calling "_spin_lock" acquires lock "dlm->spinlock" after lock "dlm_domain_lock".
fs/ocfs2/dlm/dlmdomain.c:488: lock_acquire: Calling function "_spin_lock" acquires lock "dlm_domain_lock".
fs/ocfs2/dlm/dlmdomain.c:489: example_lock_order: Calling "_spin_lock" acquires lock "dlm->spinlock" after lock "dlm_domain_lock".
fs/ocfs2/dlm/dlmdomain.c:792: lock_acquire: Calling function "_spin_lock" acquires lock "dlm_domain_lock".
fs/ocfs2/dlm/dlmdomain.c:822: example_lock_order: Calling "_spin_lock" acquires lock "dlm->spinlock" after lock "dlm_domain_lock".
fs/ocfs2/dlm/dlmrecovery.c:1666: lock_order: Calling "dlm_dispatch_assert_master" acquires lock "dlm_domain_lock" after lock "dlm->spinlock" (count: 1 / 5).
fs/ocfs2/dlm/dlmmaster.c:2037: getlock: Acquiring lock named <unset>.
fs/ocfs2/dlm/dlmdomain.c:359: getlock: Acquiring lock named dlm_domain_lock.

Error: ORDER_REVERSAL:
sound/drivers/opl3/opl3_midi.c:345: lock_acquire: Calling function "_spin_lock_irqsave" acquires lock "opl3->voice_lock".
sound/drivers/opl3/opl3_midi.c:245: lock_acquire: Calling function "_spin_lock_irqsave" acquires lock "opl3->sys_timer_lock".
sound/drivers/opl3/opl3_midi.c:250: example_lock_order: Calling "snd_opl3_note_off" acquires lock "snd_opl3.voice_lock" after lock "opl3->sys_timer_lock".
sound/drivers/opl3/opl3_midi.c:677: getlock: Acquiring lock named snd_opl3.voice_lock.
sound/drivers/opl3/opl3_midi.c:559: lock_order: Calling "snd_opl3_start_timer" acquires lock "snd_opl3.sys_timer_lock" after lock "opl3->voice_lock" (count: 1 / 2).
sound/drivers/opl3/opl3_midi.c:270: getlock: Acquiring lock named snd_opl3.sys_timer_lock.
