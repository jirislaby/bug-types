	       ==================================================
	       ===== Classification and Description of Bugs =====
	       ==================================================

This document classifies Linux kernel bugs into categories. It is intended for
people to have better understanding of what can be output by the kernel and what
kind of error it corresponds to.

1 Single-line Bugs
==================
Here we have all the bugs which are caused by an error on _one_ identifiable
location in the source code.

1.1 BUG/WARNING
---------------
This is a kind of assertion included directly in the source code. Programmers
usually do not want the tested condition to happen. But if it happens under some
circumstanses, they really want to hear back from users. If the condition is
true, the control flow jumps to an invalid instruction which causes processor to
generate an exception. OS then outputs to the log exact file and line and as
usual stacktrace with registers dump.

Source: BUG() or WARNING()
Location: Specified by the macros above
Detection: CPU raises an exception
See: BUG.txt, WARNING.txt

1.2 Division by Zero
--------------------
Obvious kind of error -- the code tries to divide and the divisor is zero.
After processor generates an exception, OS dumps only stacktraces and registers
dump.

Source: a = b / c
Location: Specified by the line where division happens
Detection: CPU raises an exception
See: div_by_zero.txt

1.3 Invalid Pointer Dereference
-------------------------------
The code tries to access some memory, but the pointer used is invalid. The
special case is NULL pointer where the value of the pointer is below page size
(on x86 it is 4096). A processor generates an exception that the accessed
virtual address is not mapped to any real memory. OS dumps only stacktraces and
registers dump.

Source: *ptr, ptr[offset], ptr->member etc.
Location: Specified by the line where the dereference happens
Detection: CPU raises an exception
See: oops_NULL.txt, oops_paging.txt

1.4 Memory Corruption
---------------------
Somebody holds an orphaned pointer and writes to memory of somebody else. The
writer might be either HW (by DMA) or SW. The pointer usually points to memory
which was allocated earlier by a driver, but freed later by mistake or even
intentionally without telling the rest of the driver to stop using it.

Also a source of the problem might be accessing an array out-of-bounds. This can
happen both on the stack and on the heap. Heap cases might be caught by
slub_debug kernel facility. Heap ones by canary patterns (stack protector). They
both work on the same principle. They allocate/reserve more than requested
memory and pre- and append some pattern. If the pattern is ever changed, it is
reported by OS as an error. Also heap protection also overwrites the memory
after it is freed by the driver. Next allocation of such memory then watches the
pattern change the same as above.

Source: ptr = alloc(10); ptr[20] = value; free(ptr); *ptr = value; etc.
Location: Specified by the line where the write happens
Detection: CPU raises an exception
See: slub_debug.txt

1.5 Memory Leaks
----------------
Some code allocates some memory, but forgets to free it on some/all paths. This
can be checked by the kernel runtime checker called Kmemleak. It works the same
as Valgrind -- like a tracing garbage collector.

Source: ptr = alloc(10) followed by no free(ptr) on some path
Location: Specified by the line where the allocation happens
Detection: Kmemleak
See: kmemleak.txt

1.6

2 Multi-line Bugs
==================
These bugs need some specific coincidence of errors in the code. Or sometimes
there may be only one error in the code, but only in cooperation with the
correct code at a different place, it will trigger a bug. The tools are mostly
uncertain which one is the correct one so they report both to user to choose.

In other wording, if a bug may refer to multiple location and the checker cannot
decide, all are reported.

2.1 Lock Imbalances
-------------------
Obviously the code contains locks without unlocks, vice versa, double locks or
unlocks, circular locking dependency* and so on.

* For example one function first locks A, then B, another function first locks B
  then C and yet another one first locks C then A. If all three are scheduled to
  run and all lock their first lock, they cannot lock the second because they
  just deadlocked.

Source: lock(A); lock(A); lock(B); if (x) return; unlock(B); etc.
Locations: Specified by the line where the affected lock/unlock functions happen
Detection: Lockdep
See: lockdep.txt, lockdep-classes.txt

2.2 Hung Task
-------------
Tasks may hang when there is an awaited event which never triggers or triggers
after a very long time. Or when a programmer writes a loop without thorough
thinking about invariant. Then the loop may last forever.

Source: something like 'while (no_message()) loop;'
Locations: Specified by lines where the code is looping
Detection: Hung Task Checker
See: hung_task.txt
